{"version":3,"file":"index.js","mappings":"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","sources":["webpack://StacksSbtc/webpack/universalModuleDefinition","webpack://StacksSbtc/webpack/runtime/create fake namespace object","webpack://StacksSbtc/../../node_modules/@btc-helpers/rpc/dist/index.js","webpack://StacksSbtc/../../node_modules/@noble/hashes/_assert.js","webpack://StacksSbtc/../../node_modules/@noble/hashes/_sha2.js","webpack://StacksSbtc/../../node_modules/@noble/hashes/cryptoBrowser.js","webpack://StacksSbtc/../../node_modules/@noble/hashes/sha256.js","webpack://StacksSbtc/../../node_modules/@noble/hashes/utils.js","webpack://StacksSbtc/../../node_modules/@scure/base/lib/index.js","webpack://StacksSbtc/../../node_modules/base-x/src/index.js","webpack://StacksSbtc/../../node_modules/bs58/index.js","webpack://StacksSbtc/../../node_modules/c32check/lib/address.js","webpack://StacksSbtc/../../node_modules/c32check/lib/base58check.js","webpack://StacksSbtc/../../node_modules/c32check/lib/checksum.js","webpack://StacksSbtc/../../node_modules/c32check/lib/encoding.js","webpack://StacksSbtc/../../node_modules/c32check/lib/index.js","webpack://StacksSbtc/../../node_modules/cross-fetch/dist/browser-polyfill.js","webpack://StacksSbtc/../../node_modules/lodash.clonedeep/index.js","webpack://StacksSbtc/webpack/bootstrap","webpack://StacksSbtc/webpack/runtime/compat get default export","webpack://StacksSbtc/webpack/runtime/define property getters","webpack://StacksSbtc/webpack/runtime/global","webpack://StacksSbtc/webpack/runtime/hasOwnProperty shorthand","webpack://StacksSbtc/webpack/runtime/make namespace object","webpack://StacksSbtc/webpack/runtime/node module decorator","webpack://StacksSbtc/./node_modules/@noble/hashes/esm/_assert.js","webpack://StacksSbtc/./node_modules/@noble/hashes/esm/utils.js","webpack://StacksSbtc/./node_modules/@noble/hashes/esm/hmac.js","webpack://StacksSbtc/./node_modules/@noble/hashes/esm/_sha2.js","webpack://StacksSbtc/./node_modules/@noble/hashes/esm/ripemd160.js","webpack://StacksSbtc/./node_modules/@noble/hashes/esm/sha256.js","webpack://StacksSbtc/./node_modules/@noble/hashes/esm/_u64.js","webpack://StacksSbtc/./node_modules/@noble/hashes/esm/sha512.js","webpack://StacksSbtc/../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js","webpack://StacksSbtc/../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js","webpack://StacksSbtc/../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js","webpack://StacksSbtc/../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js","webpack://StacksSbtc/../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js","webpack://StacksSbtc/../../node_modules/@noble/curves/esm/abstract/utils.js","webpack://StacksSbtc/../../node_modules/@noble/curves/esm/abstract/modular.js","webpack://StacksSbtc/../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js","webpack://StacksSbtc/../../node_modules/@noble/curves/esm/abstract/curve.js","webpack://StacksSbtc/../../node_modules/@noble/curves/esm/abstract/weierstrass.js","webpack://StacksSbtc/../../node_modules/@noble/curves/esm/_shortw_utils.js","webpack://StacksSbtc/../../node_modules/@noble/curves/esm/secp256k1.js","webpack://StacksSbtc/../../node_modules/@scure/base/lib/esm/index.js","webpack://StacksSbtc/./node_modules/@scure/bip32/lib/esm/index.js","webpack://StacksSbtc/./node_modules/@scure/bip39/esm/index.js","webpack://StacksSbtc/./node_modules/@noble/hashes/esm/pbkdf2.js","webpack://StacksSbtc/../../node_modules/@scure/btc-signer/node_modules/@noble/hashes/esm/_assert.js","webpack://StacksSbtc/../../node_modules/@scure/btc-signer/node_modules/@noble/hashes/esm/utils.js","webpack://StacksSbtc/../../node_modules/@scure/btc-signer/node_modules/@noble/hashes/esm/_sha2.js","webpack://StacksSbtc/../../node_modules/@scure/btc-signer/node_modules/@noble/hashes/esm/sha256.js","webpack://StacksSbtc/../../node_modules/@scure/btc-signer/node_modules/@noble/hashes/esm/ripemd160.js","webpack://StacksSbtc/../../node_modules/micro-packed/index.js","webpack://StacksSbtc/../../node_modules/@scure/btc-signer/index.js","webpack://StacksSbtc/../common/dist/esm/utils.js","webpack://StacksSbtc/../common/dist/esm/buffer.js","webpack://StacksSbtc/../transactions/dist/esm/constants.js","webpack://StacksSbtc/../../node_modules/@noble/hashes/esm/_assert.js","webpack://StacksSbtc/../../node_modules/@noble/hashes/esm/utils.js","webpack://StacksSbtc/../../node_modules/@noble/hashes/esm/cryptoBrowser.js","webpack://StacksSbtc/../../node_modules/@noble/hashes/esm/_sha2.js","webpack://StacksSbtc/../../node_modules/@noble/hashes/esm/ripemd160.js","webpack://StacksSbtc/../../node_modules/@noble/hashes/esm/sha256.js","webpack://StacksSbtc/../../node_modules/@noble/hashes/esm/_u64.js","webpack://StacksSbtc/../../node_modules/@noble/hashes/esm/sha512.js","webpack://StacksSbtc/../../node_modules/@noble/secp256k1/lib/esm/index.js","webpack://StacksSbtc/../transactions/dist/esm/utils.js","webpack://StacksSbtc/../transactions/dist/esm/postcondition-types.js","webpack://StacksSbtc/../transactions/dist/esm/types.js","webpack://StacksSbtc/../transactions/dist/esm/clarity/constants.js","webpack://StacksSbtc/../transactions/dist/esm/errors.js","webpack://StacksSbtc/../transactions/dist/esm/clarity/serialize.js","webpack://StacksSbtc/../../node_modules/@noble/hashes/esm/hmac.js","webpack://StacksSbtc/../common/dist/esm/keys.js","webpack://StacksSbtc/../common/dist/esm/constants.js","webpack://StacksSbtc/../transactions/dist/esm/keys.js","webpack://StacksSbtc/../transactions/dist/esm/common.js","webpack://StacksSbtc/./node_modules/@stacks/common/dist/esm/utils.js","webpack://StacksSbtc/../transactions/dist/esm/clarity/types/principalCV.js","webpack://StacksSbtc/../encryption/dist/esm/keys.js","webpack://StacksSbtc/../transactions/dist/esm/clarity/types/intCV.js","webpack://StacksSbtc/../transactions/dist/esm/bytesReader.js","webpack://StacksSbtc/../transactions/dist/esm/clarity/types/stringCV.js","webpack://StacksSbtc/../transactions/dist/esm/cl.js","webpack://StacksSbtc/../transactions/dist/esm/clarity/deserialize.js","webpack://StacksSbtc/../transactions/dist/esm/clarity/types/bufferCV.js","webpack://StacksSbtc/../transactions/dist/esm/clarity/types/booleanCV.js","webpack://StacksSbtc/../transactions/dist/esm/clarity/types/responseCV.js","webpack://StacksSbtc/../transactions/dist/esm/clarity/types/optionalCV.js","webpack://StacksSbtc/../transactions/dist/esm/clarity/types/listCV.js","webpack://StacksSbtc/../transactions/dist/esm/clarity/types/tupleCV.js","webpack://StacksSbtc/./src/constants.ts","webpack://StacksSbtc/./src/utils.ts","webpack://StacksSbtc/./src/api.ts","webpack://StacksSbtc/./src/transactions/deposit.ts","webpack://StacksSbtc/./src/transactions/withdraw.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StacksSbtc\"] = factory();\n\telse\n\t\troot[\"StacksSbtc\"] = factory();\n})(this, () => {\nreturn ","var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// lib/index.ts\nvar lib_exports = {};\n__export(lib_exports, {\n  default: () => RpcClient\n});\nmodule.exports = __toCommonJS(lib_exports);\nvar import_polyfill = require(\"cross-fetch/polyfill\");\nvar import_base = require(\"@scure/base\");\nvar RpcClient = class {\n  hostname;\n  port;\n  protocol;\n  auth;\n  constructor(opts) {\n    if (typeof opts === \"string\") {\n      opts = decodeUrl(opts);\n    }\n    const defaultOptions = {\n      host: \"127.0.0.1\",\n      port: 8332,\n      user: \"devnet\",\n      pass: \"devnet\",\n      protocol: \"http\"\n    };\n    const options = Object.assign(defaultOptions, opts || {});\n    this.hostname = options.host;\n    this.port = options.port;\n    this.protocol = options.protocol;\n    this.auth = import_base.base64.encode(\n      new TextEncoder().encode(`${options.user}:${options.pass}`)\n    );\n  }\n  get Typed() {\n    return new Proxy(this, {\n      get(target, property, receiver) {\n        if (property in target)\n          return Reflect.get(target, property, receiver);\n        return async function(params) {\n          return await target.call({\n            jsonrpc: \"2.0\",\n            method: property.toString().toLowerCase(),\n            params,\n            id: getRandomId()\n          });\n        };\n      }\n    });\n  }\n  async call(body) {\n    const options = {\n      method: \"POST\",\n      headers: {\n        Authorization: `Basic ${this.auth}`,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body)\n    };\n    const errorPrefix = \"Bitcoin JSON-RPC: \";\n    const res = await fetch(\n      `${this.protocol}//${this.hostname}:${this.port}`,\n      options\n    );\n    if (res.status === 401) {\n      throw new Error(errorPrefix + \"Connection Rejected: 401 Unnauthorized\");\n    }\n    if (res.status === 403) {\n      throw new Error(errorPrefix + \"Connection Rejected: 403 Forbidden\");\n    }\n    const text = await res.text();\n    if (res.status === 500) {\n      if (text === \"Work queue depth exceeded\") {\n        const exceededError = new Error(errorPrefix + text);\n        exceededError.code = 429;\n        throw exceededError;\n      }\n    }\n    const json = JSON.parse(text);\n    if (!res.ok)\n      throw new Error(\n        `${errorPrefix}${json?.error?.code} ${json?.error?.message}`\n      );\n    return json.result;\n  }\n};\nfunction decodeUrl(url) {\n  const parsedUrl = new URL(url);\n  return {\n    host: parsedUrl.hostname,\n    port: parseInt(parsedUrl.port, 10),\n    protocol: parsedUrl.protocol,\n    user: parsedUrl.username,\n    pass: parsedUrl.password\n  };\n}\nfunction getRandomId() {\n  return parseInt(Math.random() * 1e5);\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {});\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nexports.number = number;\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nexports.bool = bool;\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new TypeError('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nexports.bytes = bytes;\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nexports.hash = hash;\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nexports.exists = exists;\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexports.output = output;\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output,\n};\nexports.default = assert;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SHA2 = void 0;\nconst _assert_js_1 = require(\"./_assert.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends utils_js_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_js_1.createView)(this.buffer);\n    }\n    update(data) {\n        _assert_js_1.default.exists(this);\n        const { view, buffer, blockLen } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_js_1.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        _assert_js_1.default.exists(this);\n        _assert_js_1.default.output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_js_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\nexports.SHA2 = SHA2;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.crypto = void 0;\nexports.crypto = {\n    node: undefined,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sha224 = exports.sha256 = void 0;\nconst _sha2_js_1 = require(\"./_sha2.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends _sha2_js_1.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());\nexports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());\n","\"use strict\";\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;\n// The import here is via the package name. This is to ensure\n// that exports mapping/resolution does fall into place.\nconst crypto_1 = require(\"@noble/hashes/crypto\");\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nexports.rotr = rotr;\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.\n// So, just to be sure not to corrupt anything.\nif (!exports.isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))\n */\nfunction bytesToHex(uint8a) {\n    // pre-caching improves the speed 6x\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\n/**\n * @example hexToBytes('deadbeef')\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise\n// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\nexports.asyncLoop = asyncLoop;\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string') {\n        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n    }\n    return new TextEncoder().encode(str);\n}\nexports.utf8ToBytes = utf8ToBytes;\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!(data instanceof Uint8Array))\n        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n    return data;\n}\nexports.toBytes = toBytes;\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\nfunction concatBytes(...arrays) {\n    if (!arrays.every((a) => a instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nexports.concatBytes = concatBytes;\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.Hash = Hash;\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n        throw new TypeError('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexports.checkOpts = checkOpts;\nfunction wrapConstructor(hashConstructor) {\n    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();\n    const tmp = hashConstructor();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashConstructor();\n    return hashC;\n}\nexports.wrapConstructor = wrapConstructor;\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\n/**\n * Secure PRNG\n */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto.web) {\n        return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    }\n    else if (crypto_1.crypto.node) {\n        return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);\n    }\n    else {\n        throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n}\nexports.randomBytes = randomBytes;\n","\"use strict\";\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nexports.assertNumber = assertNumber;\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = Array.from(args)\n        .reverse()\n        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of strings');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of strings');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\nexports.utils = { alphabet, chain, checksum, radix, radix2, join, padding };\n// RFC 4648 aka RFC 3548\n// ---------------------\nexports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexports.base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexports.base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nexports.base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nexports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexports.base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = exports.base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst base58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), exports.base58);\nexports.base58check = base58check;\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nexports.bech32 = genBech32('bech32');\nexports.bech32m = genBech32('bech32m');\nexports.utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nexports.hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8: exports.utf8, hex: exports.hex, base16: exports.base16, base32: exports.base32, base64: exports.base64, base64url: exports.base64url, base58: exports.base58, base58xmr: exports.base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!(bytes instanceof Uint8Array))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nexports.bytesToString = bytesToString;\nexports.str = exports.bytesToString; // as in python, but for bytes only\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nexports.stringToBytes = stringToBytes;\nexports.bytes = exports.stringToBytes;\n","'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n","const basex = require('base-x')\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.c32ToB58 = exports.b58ToC32 = exports.c32addressDecode = exports.c32address = exports.versions = void 0;\nconst checksum_1 = require(\"./checksum\");\nconst base58check = require(\"./base58check\");\nconst utils_1 = require(\"@noble/hashes/utils\");\nexports.versions = {\n    mainnet: {\n        p2pkh: 22,\n        p2sh: 20, // 'M'\n    },\n    testnet: {\n        p2pkh: 26,\n        p2sh: 21, // 'N'\n    },\n};\n// address conversion : bitcoin to stacks\nconst ADDR_BITCOIN_TO_STACKS = {};\nADDR_BITCOIN_TO_STACKS[0] = exports.versions.mainnet.p2pkh;\nADDR_BITCOIN_TO_STACKS[5] = exports.versions.mainnet.p2sh;\nADDR_BITCOIN_TO_STACKS[111] = exports.versions.testnet.p2pkh;\nADDR_BITCOIN_TO_STACKS[196] = exports.versions.testnet.p2sh;\n// address conversion : stacks to bitcoin\nconst ADDR_STACKS_TO_BITCOIN = {};\nADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2pkh] = 0;\nADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2sh] = 5;\nADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2pkh] = 111;\nADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2sh] = 196;\n/**\n * Make a c32check address with the given version and hash160\n * The only difference between a c32check string and c32 address\n * is that the letter 'S' is pre-pended.\n * @param {number} version - the address version number\n * @param {string} hash160hex - the hash160 to encode (must be a hash160)\n * @returns {string} the address\n */\nfunction c32address(version, hash160hex) {\n    if (!hash160hex.match(/^[0-9a-fA-F]{40}$/)) {\n        throw new Error('Invalid argument: not a hash160 hex string');\n    }\n    const c32string = (0, checksum_1.c32checkEncode)(version, hash160hex);\n    return `S${c32string}`;\n}\nexports.c32address = c32address;\n/**\n * Decode a c32 address into its version and hash160\n * @param {string} c32addr - the c32check-encoded address\n * @returns {[number, string]} a tuple with the version and hash160\n */\nfunction c32addressDecode(c32addr) {\n    if (c32addr.length <= 5) {\n        throw new Error('Invalid c32 address: invalid length');\n    }\n    if (c32addr[0] != 'S') {\n        throw new Error('Invalid c32 address: must start with \"S\"');\n    }\n    return (0, checksum_1.c32checkDecode)(c32addr.slice(1));\n}\nexports.c32addressDecode = c32addressDecode;\n/*\n * Convert a base58check address to a c32check address.\n * Try to convert the version number if one is not given.\n * @param {string} b58check - the base58check encoded address\n * @param {number} version - the version number, if not inferred from the address\n * @returns {string} the c32 address with the given version number (or the\n *   semantically-equivalent c32 version number, if not given)\n */\nfunction b58ToC32(b58check, version = -1) {\n    const addrInfo = base58check.decode(b58check);\n    const hash160String = (0, utils_1.bytesToHex)(addrInfo.data);\n    const addrVersion = parseInt((0, utils_1.bytesToHex)(addrInfo.prefix), 16);\n    let stacksVersion;\n    if (version < 0) {\n        stacksVersion = addrVersion;\n        if (ADDR_BITCOIN_TO_STACKS[addrVersion] !== undefined) {\n            stacksVersion = ADDR_BITCOIN_TO_STACKS[addrVersion];\n        }\n    }\n    else {\n        stacksVersion = version;\n    }\n    return c32address(stacksVersion, hash160String);\n}\nexports.b58ToC32 = b58ToC32;\n/*\n * Convert a c32check address to a base58check address.\n * @param {string} c32string - the c32check address\n * @param {number} version - the version number, if not inferred from the address\n * @returns {string} the base58 address with the given version number (or the\n *    semantically-equivalent bitcoin version number, if not given)\n */\nfunction c32ToB58(c32string, version = -1) {\n    const addrInfo = c32addressDecode(c32string);\n    const stacksVersion = addrInfo[0];\n    const hash160String = addrInfo[1];\n    let bitcoinVersion;\n    if (version < 0) {\n        bitcoinVersion = stacksVersion;\n        if (ADDR_STACKS_TO_BITCOIN[stacksVersion] !== undefined) {\n            bitcoinVersion = ADDR_STACKS_TO_BITCOIN[stacksVersion];\n        }\n    }\n    else {\n        bitcoinVersion = version;\n    }\n    let prefix = bitcoinVersion.toString(16);\n    if (prefix.length === 1) {\n        prefix = `0${prefix}`;\n    }\n    return base58check.encode(hash160String, prefix);\n}\nexports.c32ToB58 = c32ToB58;\n","/*\n * From https://github.com/wzbg/base58check\n * @Author: zyc\n * @Date:   2016-09-11 23:36:05\n */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decode = exports.encode = void 0;\nconst sha256_1 = require(\"@noble/hashes/sha256\");\nconst utils_1 = require(\"@noble/hashes/utils\");\nconst basex = require(\"base-x\");\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nfunction encode(data, prefix = '00') {\n    const dataBytes = typeof data === 'string' ? (0, utils_1.hexToBytes)(data) : data;\n    const prefixBytes = typeof prefix === 'string' ? (0, utils_1.hexToBytes)(prefix) : data;\n    if (!(dataBytes instanceof Uint8Array) || !(prefixBytes instanceof Uint8Array)) {\n        throw new TypeError('Argument must be of type Uint8Array or string');\n    }\n    const checksum = (0, sha256_1.sha256)((0, sha256_1.sha256)(new Uint8Array([...prefixBytes, ...dataBytes])));\n    return basex(ALPHABET).encode([...prefixBytes, ...dataBytes, ...checksum.slice(0, 4)]);\n}\nexports.encode = encode;\nfunction decode(string) {\n    const bytes = basex(ALPHABET).decode(string);\n    const prefixBytes = bytes.slice(0, 1);\n    const dataBytes = bytes.slice(1, -4);\n    // todo: for better performance replace spread with `concatBytes` method\n    const checksum = (0, sha256_1.sha256)((0, sha256_1.sha256)(new Uint8Array([...prefixBytes, ...dataBytes])));\n    bytes.slice(-4).forEach((check, index) => {\n        if (check !== checksum[index]) {\n            throw new Error('Invalid checksum');\n        }\n    });\n    return { prefix: prefixBytes, data: dataBytes };\n}\nexports.decode = decode;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.c32checkDecode = exports.c32checkEncode = void 0;\nconst sha256_1 = require(\"@noble/hashes/sha256\");\nconst utils_1 = require(\"@noble/hashes/utils\");\nconst encoding_1 = require(\"./encoding\");\n/**\n * Get the c32check checksum of a hex-encoded string\n * @param {string} dataHex - the hex string\n * @returns {string} the c32 checksum, as a bin-encoded string\n */\nfunction c32checksum(dataHex) {\n    const dataHash = (0, sha256_1.sha256)((0, sha256_1.sha256)((0, utils_1.hexToBytes)(dataHex)));\n    const checksum = (0, utils_1.bytesToHex)(dataHash.slice(0, 4));\n    return checksum;\n}\n/**\n * Encode a hex string as a c32check string.  This is a lot like how\n * base58check works in Bitcoin-land, but this algorithm uses the\n * z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * calculate the c32checksum of version + data\n * * c32encode version + data + c32checksum\n * @param {number} version - the version string (between 0 and 31)\n * @param {string} data - the data to encode\n * @returns {string} the c32check representation\n */\nfunction c32checkEncode(version, data) {\n    if (version < 0 || version >= 32) {\n        throw new Error('Invalid version (must be between 0 and 31)');\n    }\n    if (!data.match(/^[0-9a-fA-F]*$/)) {\n        throw new Error('Invalid data (not a hex string)');\n    }\n    data = data.toLowerCase();\n    if (data.length % 2 !== 0) {\n        data = `0${data}`;\n    }\n    let versionHex = version.toString(16);\n    if (versionHex.length === 1) {\n        versionHex = `0${versionHex}`;\n    }\n    const checksumHex = c32checksum(`${versionHex}${data}`);\n    const c32str = (0, encoding_1.c32encode)(`${data}${checksumHex}`);\n    return `${encoding_1.c32[version]}${c32str}`;\n}\nexports.c32checkEncode = c32checkEncode;\n/*\n * Decode a c32check string back into its version and data payload.  This is\n * a lot like how base58check works in Bitcoin-land, but this algorithm uses\n * the z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * extract the version, data, and checksum\n * * verify the checksum matches c32checksum(version + data)\n * * return data\n * @param {string} c32data - the c32check-encoded string\n * @returns {array} [version (number), data (string)].  The returned data\n * will be a hex string.  Throws an exception if the checksum does not match.\n */\nfunction c32checkDecode(c32data) {\n    c32data = (0, encoding_1.c32normalize)(c32data);\n    const dataHex = (0, encoding_1.c32decode)(c32data.slice(1));\n    const versionChar = c32data[0];\n    const version = encoding_1.c32.indexOf(versionChar);\n    const checksum = dataHex.slice(-8);\n    let versionHex = version.toString(16);\n    if (versionHex.length === 1) {\n        versionHex = `0${versionHex}`;\n    }\n    if (c32checksum(`${versionHex}${dataHex.substring(0, dataHex.length - 8)}`) !== checksum) {\n        throw new Error('Invalid c32check string: checksum mismatch');\n    }\n    return [version, dataHex.substring(0, dataHex.length - 8)];\n}\nexports.c32checkDecode = c32checkDecode;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.c32decode = exports.c32normalize = exports.c32encode = exports.c32 = void 0;\nconst utils_1 = require(\"@noble/hashes/utils\");\nexports.c32 = '0123456789ABCDEFGHJKMNPQRSTVWXYZ';\nconst hex = '0123456789abcdef';\n/**\n * Encode a hex string as a c32 string.  Note that the hex string is assumed\n * to be big-endian (and the resulting c32 string will be as well).\n * @param {string} inputHex - the input to encode\n * @param {number} minLength - the minimum length of the c32 string\n * @returns {string} the c32check-encoded representation of the data, as a string\n */\nfunction c32encode(inputHex, minLength) {\n    // must be hex\n    if (!inputHex.match(/^[0-9a-fA-F]*$/)) {\n        throw new Error('Not a hex-encoded string');\n    }\n    if (inputHex.length % 2 !== 0) {\n        inputHex = `0${inputHex}`;\n    }\n    inputHex = inputHex.toLowerCase();\n    let res = [];\n    let carry = 0;\n    for (let i = inputHex.length - 1; i >= 0; i--) {\n        if (carry < 4) {\n            const currentCode = hex.indexOf(inputHex[i]) >> carry;\n            let nextCode = 0;\n            if (i !== 0) {\n                nextCode = hex.indexOf(inputHex[i - 1]);\n            }\n            // carry = 0, nextBits is 1, carry = 1, nextBits is 2\n            const nextBits = 1 + carry;\n            const nextLowBits = nextCode % (1 << nextBits) << (5 - nextBits);\n            const curC32Digit = exports.c32[currentCode + nextLowBits];\n            carry = nextBits;\n            res.unshift(curC32Digit);\n        }\n        else {\n            carry = 0;\n        }\n    }\n    let C32leadingZeros = 0;\n    for (let i = 0; i < res.length; i++) {\n        if (res[i] !== '0') {\n            break;\n        }\n        else {\n            C32leadingZeros++;\n        }\n    }\n    res = res.slice(C32leadingZeros);\n    const zeroPrefix = new TextDecoder().decode((0, utils_1.hexToBytes)(inputHex)).match(/^\\u0000*/);\n    const numLeadingZeroBytesInHex = zeroPrefix ? zeroPrefix[0].length : 0;\n    for (let i = 0; i < numLeadingZeroBytesInHex; i++) {\n        res.unshift(exports.c32[0]);\n    }\n    if (minLength) {\n        const count = minLength - res.length;\n        for (let i = 0; i < count; i++) {\n            res.unshift(exports.c32[0]);\n        }\n    }\n    return res.join('');\n}\nexports.c32encode = c32encode;\n/*\n * Normalize a c32 string\n * @param {string} c32input - the c32-encoded input string\n * @returns {string} the canonical representation of the c32 input string\n */\nfunction c32normalize(c32input) {\n    // must be upper-case\n    // replace all O's with 0's\n    // replace all I's and L's with 1's\n    return c32input.toUpperCase().replace(/O/g, '0').replace(/L|I/g, '1');\n}\nexports.c32normalize = c32normalize;\n/*\n * Decode a c32 string back into a hex string.  Note that the c32 input\n * string is assumed to be big-endian (and the resulting hex string will\n * be as well).\n * @param {string} c32input - the c32-encoded input to decode\n * @param {number} minLength - the minimum length of the output hex string (in bytes)\n * @returns {string} the hex-encoded representation of the data, as a string\n */\nfunction c32decode(c32input, minLength) {\n    c32input = c32normalize(c32input);\n    // must result in a c32 string\n    if (!c32input.match(`^[${exports.c32}]*$`)) {\n        throw new Error('Not a c32-encoded string');\n    }\n    const zeroPrefix = c32input.match(`^${exports.c32[0]}*`);\n    const numLeadingZeroBytes = zeroPrefix ? zeroPrefix[0].length : 0;\n    let res = [];\n    let carry = 0;\n    let carryBits = 0;\n    for (let i = c32input.length - 1; i >= 0; i--) {\n        if (carryBits === 4) {\n            res.unshift(hex[carry]);\n            carryBits = 0;\n            carry = 0;\n        }\n        const currentCode = exports.c32.indexOf(c32input[i]) << carryBits;\n        const currentValue = currentCode + carry;\n        const currentHexDigit = hex[currentValue % 16];\n        carryBits += 1;\n        carry = currentValue >> 4;\n        if (carry > 1 << carryBits) {\n            throw new Error('Panic error in decoding.');\n        }\n        res.unshift(currentHexDigit);\n    }\n    // one last carry\n    res.unshift(hex[carry]);\n    if (res.length % 2 === 1) {\n        res.unshift('0');\n    }\n    let hexLeadingZeros = 0;\n    for (let i = 0; i < res.length; i++) {\n        if (res[i] !== '0') {\n            break;\n        }\n        else {\n            hexLeadingZeros++;\n        }\n    }\n    res = res.slice(hexLeadingZeros - (hexLeadingZeros % 2));\n    let hexStr = res.join('');\n    for (let i = 0; i < numLeadingZeroBytes; i++) {\n        hexStr = `00${hexStr}`;\n    }\n    if (minLength) {\n        const count = minLength * 2 - hexStr.length;\n        for (let i = 0; i < count; i += 2) {\n            hexStr = `00${hexStr}`;\n        }\n    }\n    return hexStr;\n}\nexports.c32decode = c32decode;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.b58ToC32 = exports.c32ToB58 = exports.versions = exports.c32normalize = exports.c32addressDecode = exports.c32address = exports.c32checkDecode = exports.c32checkEncode = exports.c32decode = exports.c32encode = void 0;\nconst encoding_1 = require(\"./encoding\");\nObject.defineProperty(exports, \"c32encode\", { enumerable: true, get: function () { return encoding_1.c32encode; } });\nObject.defineProperty(exports, \"c32decode\", { enumerable: true, get: function () { return encoding_1.c32decode; } });\nObject.defineProperty(exports, \"c32normalize\", { enumerable: true, get: function () { return encoding_1.c32normalize; } });\nconst checksum_1 = require(\"./checksum\");\nObject.defineProperty(exports, \"c32checkEncode\", { enumerable: true, get: function () { return checksum_1.c32checkEncode; } });\nObject.defineProperty(exports, \"c32checkDecode\", { enumerable: true, get: function () { return checksum_1.c32checkDecode; } });\nconst address_1 = require(\"./address\");\nObject.defineProperty(exports, \"c32address\", { enumerable: true, get: function () { return address_1.c32address; } });\nObject.defineProperty(exports, \"c32addressDecode\", { enumerable: true, get: function () { return address_1.c32addressDecode; } });\nObject.defineProperty(exports, \"c32ToB58\", { enumerable: true, get: function () { return address_1.c32ToB58; } });\nObject.defineProperty(exports, \"b58ToC32\", { enumerable: true, get: function () { return address_1.b58ToC32; } });\nObject.defineProperty(exports, \"versions\", { enumerable: true, get: function () { return address_1.versions; } });\n","(function(self) {\n\nvar irrelevant = (function (exports) {\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n})({});\n})(typeof self !== 'undefined' ? self : this);\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/**\n * Adds the key-value `pair` to `map`.\n *\n * @private\n * @param {Object} map The map to modify.\n * @param {Array} pair The key-value pair to add.\n * @returns {Object} Returns `map`.\n */\nfunction addMapEntry(map, pair) {\n  // Don't return `map.set` because it's not chainable in IE 11.\n  map.set(pair[0], pair[1]);\n  return map;\n}\n\n/**\n * Adds `value` to `set`.\n *\n * @private\n * @param {Object} set The set to modify.\n * @param {*} value The value to add.\n * @returns {Object} Returns `set`.\n */\nfunction addSetEntry(set, value) {\n  // Don't return `set.add` because it's not chainable in IE 11.\n  set.add(value);\n  return set;\n}\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    object[key] = value;\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @param {boolean} [isFull] Specify a clone including symbols.\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, isDeep, isFull, customizer, key, object, stack) {\n  var result;\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      if (isHostObject(value)) {\n        return object ? value : {};\n      }\n      result = initCloneObject(isFunc ? {} : value);\n      if (!isDeep) {\n        return copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, baseClone, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (!isArr) {\n    var props = isFull ? getAllKeys(value) : keys(value);\n  }\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));\n  });\n  return result;\n}\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nfunction baseCreate(proto) {\n  return isObject(proto) ? objectCreate(proto) : {};\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var result = new buffer.constructor(buffer.length);\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\n/**\n * Creates a clone of `map`.\n *\n * @private\n * @param {Object} map The map to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned map.\n */\nfunction cloneMap(map, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);\n  return arrayReduce(array, addMapEntry, new map.constructor);\n}\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\n/**\n * Creates a clone of `set`.\n *\n * @private\n * @param {Object} set The set to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned set.\n */\nfunction cloneSet(set, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);\n  return arrayReduce(array, addSetEntry, new set.constructor);\n}\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    assignValue(object, key, newValue === undefined ? source[key] : newValue);\n  }\n  return object;\n}\n\n/**\n * Copies own symbol properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Creates an array of the own enumerable symbol properties of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return cloneMap(object, isDeep, cloneFunc);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return cloneSet(object, isDeep, cloneFunc);\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, true, true);\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = cloneDeep;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n//# sourceMappingURL=_assert.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","import { hash as assertHash, bytes as assertBytes, exists as assertExists } from './_assert.js';\nimport { Hash, toBytes } from './utils.js';\n// HMAC (RFC 2104)\nexport class HMAC extends Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        assertHash(hash);\n        const key = toBytes(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        assertExists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        assertExists(this);\n        assertBytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nexport const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","import { exists, output } from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nexport class SHA2 extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        exists(this);\n        output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map","import { SHA2 } from './_sha2.js';\nimport { wrapConstructor } from './utils.js';\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\nconst Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);\nconst Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++)\n    for (let j of [idxL, idxR])\n        j.push(j[i].map((k) => Rho[k]));\nconst shifts = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\nconst shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst Kl = /* @__PURE__ */ new Uint32Array([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr = /* @__PURE__ */ new Uint32Array([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));\n// It's called f() in spec.\nfunction f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    else if (group === 1)\n        return (x & y) | (~x & z);\n    else if (group === 2)\n        return (x | ~y) ^ z;\n    else if (group === 3)\n        return (x & z) | (y & ~z);\n    else\n        return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst BUF = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends SHA2 {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        BUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a hash function from 1990s.\n * @param message - msg that would be hashed\n */\nexport const ripemd160 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());\n//# sourceMappingURL=ripemd160.js.map","import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n//# sourceMappingURL=sha256.js.map","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { fromBig, split, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add, add3L, add3H, add4L, add4H, add5H, add5L, };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","import { SHA2 } from './_sha2.js';\nimport u64 from './_u64.js';\nimport { wrapConstructor } from './utils.js';\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends SHA2 {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nexport const sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());\nexport const sha512_224 = /* @__PURE__ */ wrapConstructor(() => new SHA512_224());\nexport const sha512_256 = /* @__PURE__ */ wrapConstructor(() => new SHA512_256());\nexport const sha384 = /* @__PURE__ */ wrapConstructor(() => new SHA384());\n//# sourceMappingURL=sha512.js.map","function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n//# sourceMappingURL=_assert.js.map","export const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","import { exists, output } from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nexport class SHA2 extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        exists(this);\n        output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map","import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n//# sourceMappingURL=sha256.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a) => a instanceof Uint8Array;\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexport function numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexport function numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (u8a(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nexport function equalBytes(b1, b2) {\n    // We don't care about timing attacks here\n    if (b1.length !== b2.length)\n        return false;\n    for (let i = 0; i < b1.length; i++)\n        if (b1[i] !== b2[i])\n            return false;\n    return true;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nexport const bitSet = (n, pos, value) => {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || val instanceof Uint8Array,\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nexport function validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nimport { bitMask, numberToBytesBE, numberToBytesLE, bytesToNumberBE, bytesToNumberLE, ensureBytes, validateObject, } from './utils.js';\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nexport function mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nexport function pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nexport function pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nexport function invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p)  1    if a is a square (mod p)\n    // (a | p)  -1   if a is not a square (mod p)\n    // (a | p)  0    if a  0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be  -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nexport function FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P  3 (mod 4)\n    // n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P  9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nexport function validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return validateObject(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nexport function FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nexport function FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nexport function nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: bitMask(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nexport function FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexport function FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nexport function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = ensureBytes('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map","import { hash as assertHash, bytes as assertBytes, exists as assertExists } from './_assert.js';\nimport { Hash, toBytes } from './utils.js';\n// HMAC (RFC 2104)\nexport class HMAC extends Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        assertHash(hash);\n        const key = toBytes(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        assertExists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        assertExists(this);\n        assertBytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nexport const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nimport { validateField, nLength } from './modular.js';\nimport { validateObject } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nexport function wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(1) * (Math.ceil( / ) + 1), where:\n         * -  is the window size\n         * -  is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nexport function validateBasic(curve) {\n    validateField(curve.Fp);\n    validateObject(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...nLength(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y = x + ax + b\nimport * as mod from './modular.js';\nimport * as ut from './utils.js';\nimport { ensureBytes } from './utils.js';\nimport { wNAF, validateBasic } from './curve.js';\nfunction validatePointOpts(curve) {\n    const opts = validateBasic(curve);\n    ut.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nexport const DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        if (!(data instanceof Uint8Array))\n            throw new Error('ui8a expected');\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nexport function weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y = x + ax + b: Short weierstrass curve formula\n     * @returns y\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (key instanceof Uint8Array)\n                key = ut.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : ut.bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = mod.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y\n            const right = weierstrassEquation(x); // x + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z)  (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return ut.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = validateBasic(curve);\n    ut.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nexport function weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return mod.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return mod.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = ut.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = ut.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y = x + ax + b\n                let y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = ensureBytes('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig(ensureBytes('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return ut.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return ut.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = mod.getMinHashLength(CURVE.n);\n            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = item instanceof Uint8Array;\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return ut.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = ensureBytes('msgHash', msgHash);\n        if (prehash)\n            msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n        }\n        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1G - U2P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = ensureBytes('msgHash', msgHash);\n        publicKey = ensureBytes('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || sg instanceof Uint8Array) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU(Fp, opts) {\n    mod.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { concatBytes, randomBytes } from '@noble/hashes/utils';\nimport { weierstrass } from './abstract/weierstrass.js';\n// connects noble-curves to noble-hashes\nexport function getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => hmac(hash, key, concatBytes(...msgs)),\n        randomBytes,\n    };\n}\nexport function createCurve(curveDef, defHash) {\n    const create = (hash) => weierstrass({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha256';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { Field, mod, pow2 } from './abstract/modular.js';\nimport { mapToCurveSimpleSWU } from './abstract/weierstrass.js';\nimport { bytesToNumberBE, concatBytes, ensureBytes, numberToBytesBE } from './abstract/utils.js';\nimport { createHasher, isogenyMap } from './abstract/hash-to-curve.js';\nimport { createCurve } from './_shortw_utils.js';\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = (pow2(b3, _3n, P) * b3) % P;\n    const b9 = (pow2(b6, _3n, P) * b3) % P;\n    const b11 = (pow2(b9, _2n, P) * b2) % P;\n    const b22 = (pow2(b11, _11n, P) * b11) % P;\n    const b44 = (pow2(b22, _22n, P) * b22) % P;\n    const b88 = (pow2(b44, _44n, P) * b44) % P;\n    const b176 = (pow2(b88, _88n, P) * b88) % P;\n    const b220 = (pow2(b176, _44n, P) * b44) % P;\n    const b223 = (pow2(b220, _3n, P) * b3) % P;\n    const t1 = (pow2(b223, _23n, P) * b22) % P;\n    const t2 = (pow2(t1, _6n, P) * b2) % P;\n    const root = pow2(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nexport const secp256k1 = createCurve({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = mod(k - c1 * a1 - c2 * a2, n);\n            let k2 = mod(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = concatBytes(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return sha256(concatBytes(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => numberToBytesBE(n, 32);\nconst modP = (x) => mod(x, secp256k1P);\nconst modN = (x) => mod(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x  p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN(bytesToNumberBE(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = randomBytes(32)) {\n    const m = ensureBytes('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ bytesToNumberBE(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(bytesToNumberBE(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = ensureBytes('signature', signature, 64);\n    const m = ensureBytes('message', message);\n    const pub = ensureBytes('publicKey', publicKey, 32);\n    try {\n        const P = lift_x(bytesToNumberBE(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = bytesToNumberBE(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n        if (!fe(r))\n            return false;\n        const s = bytesToNumberBE(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = sG - eP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nexport const schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE,\n        bytesToNumberBE,\n        taggedHash,\n        mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => isogenyMap(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256,\n}))();\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map","/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */\nexport function assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = Array.from(args)\n        .reverse()\n        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of strings');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of strings');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\nexport const utils = { alphabet, chain, checksum, radix, radix2, join, padding };\n// RFC 4648 aka RFC 3548\n// ---------------------\nexport const base16 = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexport const base32 = /* @__PURE__ */ chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexport const base32hex = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexport const base32crockford = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexport const base64 = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexport const base64url = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nexport const base64urlnopad = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nexport const base58 = /* @__PURE__ */ genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexport const base58flickr = /* @__PURE__ */ genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexport const base58xrp = /* @__PURE__ */ genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexport const base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nexport const base58check = /* @__PURE__ */ (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nexport const bech32 = /* @__PURE__ */ genBech32('bech32');\nexport const bech32m = /* @__PURE__ */ genBech32('bech32m');\nexport const utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nexport const hex = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\nexport const bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!(bytes instanceof Uint8Array))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nexport const str = bytesToString; // as in python, but for bytes only\nexport const stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nexport const bytes = stringToBytes;\n","/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { sha512 } from '@noble/hashes/sha512';\nimport { bytes as assertBytes } from '@noble/hashes/_assert';\nimport { bytesToHex, concatBytes, createView, hexToBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { secp256k1 as secp } from '@noble/curves/secp256k1';\nimport { mod } from '@noble/curves/abstract/modular';\nimport { base58check as base58checker } from '@scure/base';\nconst Point = secp.ProjectivePoint;\nconst base58check = base58checker(sha256);\nfunction bytesToNumber(bytes) {\n    return BigInt(`0x${bytesToHex(bytes)}`);\n}\nfunction numberToBytes(num) {\n    return hexToBytes(num.toString(16).padStart(64, '0'));\n}\nconst MASTER_SECRET = utf8ToBytes('Bitcoin seed');\n// Bitcoin hardcoded by default\nconst BITCOIN_VERSIONS = { private: 0x0488ade4, public: 0x0488b21e };\nexport const HARDENED_OFFSET = 0x80000000;\nconst hash160 = (data) => ripemd160(sha256(data));\nconst fromU32 = (data) => createView(data).getUint32(0, false);\nconst toU32 = (n) => {\n    if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {\n        throw new Error(`Invalid number=${n}. Should be from 0 to 2 ** 32 - 1`);\n    }\n    const buf = new Uint8Array(4);\n    createView(buf).setUint32(0, n, false);\n    return buf;\n};\nexport class HDKey {\n    get fingerprint() {\n        if (!this.pubHash) {\n            throw new Error('No publicKey set!');\n        }\n        return fromU32(this.pubHash);\n    }\n    get identifier() {\n        return this.pubHash;\n    }\n    get pubKeyHash() {\n        return this.pubHash;\n    }\n    get privateKey() {\n        return this.privKeyBytes || null;\n    }\n    get publicKey() {\n        return this.pubKey || null;\n    }\n    get privateExtendedKey() {\n        const priv = this.privateKey;\n        if (!priv) {\n            throw new Error('No private key');\n        }\n        return base58check.encode(this.serialize(this.versions.private, concatBytes(new Uint8Array([0]), priv)));\n    }\n    get publicExtendedKey() {\n        if (!this.pubKey) {\n            throw new Error('No public key');\n        }\n        return base58check.encode(this.serialize(this.versions.public, this.pubKey));\n    }\n    static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {\n        assertBytes(seed);\n        if (8 * seed.length < 128 || 8 * seed.length > 512) {\n            throw new Error(`HDKey: wrong seed length=${seed.length}. Should be between 128 and 512 bits; 256 bits is advised)`);\n        }\n        const I = hmac(sha512, MASTER_SECRET, seed);\n        return new HDKey({\n            versions,\n            chainCode: I.slice(32),\n            privateKey: I.slice(0, 32),\n        });\n    }\n    static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {\n        // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n        const keyBuffer = base58check.decode(base58key);\n        const keyView = createView(keyBuffer);\n        const version = keyView.getUint32(0, false);\n        const opt = {\n            versions,\n            depth: keyBuffer[4],\n            parentFingerprint: keyView.getUint32(5, false),\n            index: keyView.getUint32(9, false),\n            chainCode: keyBuffer.slice(13, 45),\n        };\n        const key = keyBuffer.slice(45);\n        const isPriv = key[0] === 0;\n        if (version !== versions[isPriv ? 'private' : 'public']) {\n            throw new Error('Version mismatch');\n        }\n        if (isPriv) {\n            return new HDKey({ ...opt, privateKey: key.slice(1) });\n        }\n        else {\n            return new HDKey({ ...opt, publicKey: key });\n        }\n    }\n    static fromJSON(json) {\n        return HDKey.fromExtendedKey(json.xpriv);\n    }\n    constructor(opt) {\n        this.depth = 0;\n        this.index = 0;\n        this.chainCode = null;\n        this.parentFingerprint = 0;\n        if (!opt || typeof opt !== 'object') {\n            throw new Error('HDKey.constructor must not be called directly');\n        }\n        this.versions = opt.versions || BITCOIN_VERSIONS;\n        this.depth = opt.depth || 0;\n        this.chainCode = opt.chainCode;\n        this.index = opt.index || 0;\n        this.parentFingerprint = opt.parentFingerprint || 0;\n        if (!this.depth) {\n            if (this.parentFingerprint || this.index) {\n                throw new Error('HDKey: zero depth with non-zero index/parent fingerprint');\n            }\n        }\n        if (opt.publicKey && opt.privateKey) {\n            throw new Error('HDKey: publicKey and privateKey at same time.');\n        }\n        if (opt.privateKey) {\n            if (!secp.utils.isValidPrivateKey(opt.privateKey)) {\n                throw new Error('Invalid private key');\n            }\n            this.privKey =\n                typeof opt.privateKey === 'bigint' ? opt.privateKey : bytesToNumber(opt.privateKey);\n            this.privKeyBytes = numberToBytes(this.privKey);\n            this.pubKey = secp.getPublicKey(opt.privateKey, true);\n        }\n        else if (opt.publicKey) {\n            this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true); // force compressed point\n        }\n        else {\n            throw new Error('HDKey: no public or private key provided');\n        }\n        this.pubHash = hash160(this.pubKey);\n    }\n    derive(path) {\n        if (!/^[mM]'?/.test(path)) {\n            throw new Error('Path must start with \"m\" or \"M\"');\n        }\n        if (/^[mM]'?$/.test(path)) {\n            return this;\n        }\n        const parts = path.replace(/^[mM]'?\\//, '').split('/');\n        // tslint:disable-next-line\n        let child = this;\n        for (const c of parts) {\n            const m = /^(\\d+)('?)$/.exec(c);\n            const m1 = m && m[1];\n            if (!m || m.length !== 3 || typeof m1 !== 'string') {\n                throw new Error(`Invalid child index: ${c}`);\n            }\n            let idx = +m1;\n            if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {\n                throw new Error('Invalid index');\n            }\n            // hardened key\n            if (m[2] === \"'\") {\n                idx += HARDENED_OFFSET;\n            }\n            child = child.deriveChild(idx);\n        }\n        return child;\n    }\n    deriveChild(index) {\n        if (!this.pubKey || !this.chainCode) {\n            throw new Error('No publicKey or chainCode set');\n        }\n        let data = toU32(index);\n        if (index >= HARDENED_OFFSET) {\n            // Hardened\n            const priv = this.privateKey;\n            if (!priv) {\n                throw new Error('Could not derive hardened child key');\n            }\n            // Hardened child: 0x00 || ser256(kpar) || ser32(index)\n            data = concatBytes(new Uint8Array([0]), priv, data);\n        }\n        else {\n            // Normal child: serP(point(kpar)) || ser32(index)\n            data = concatBytes(this.pubKey, data);\n        }\n        const I = hmac(sha512, this.chainCode, data);\n        const childTweak = bytesToNumber(I.slice(0, 32));\n        const chainCode = I.slice(32);\n        if (!secp.utils.isValidPrivateKey(childTweak)) {\n            throw new Error('Tweak bigger than curve order');\n        }\n        const opt = {\n            versions: this.versions,\n            chainCode,\n            depth: this.depth + 1,\n            parentFingerprint: this.fingerprint,\n            index,\n        };\n        try {\n            // Private parent key -> private child key\n            if (this.privateKey) {\n                const added = mod(this.privKey + childTweak, secp.CURVE.n);\n                if (!secp.utils.isValidPrivateKey(added)) {\n                    throw new Error('The tweak was out of range or the resulted private key is invalid');\n                }\n                opt.privateKey = added;\n            }\n            else {\n                const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));\n                // Cryptographically impossible: hmac-sha512 preimage would need to be found\n                if (added.equals(Point.ZERO)) {\n                    throw new Error('The tweak was equal to negative P, which made the result key invalid');\n                }\n                opt.publicKey = added.toRawBytes(true);\n            }\n            return new HDKey(opt);\n        }\n        catch (err) {\n            return this.deriveChild(index + 1);\n        }\n    }\n    sign(hash) {\n        if (!this.privateKey) {\n            throw new Error('No privateKey set!');\n        }\n        assertBytes(hash, 32);\n        return secp.sign(hash, this.privKey).toCompactRawBytes();\n    }\n    verify(hash, signature) {\n        assertBytes(hash, 32);\n        assertBytes(signature, 64);\n        if (!this.publicKey) {\n            throw new Error('No publicKey set!');\n        }\n        let sig;\n        try {\n            sig = secp.Signature.fromCompact(signature);\n        }\n        catch (error) {\n            return false;\n        }\n        return secp.verify(sig, hash, this.publicKey);\n    }\n    wipePrivateData() {\n        this.privKey = undefined;\n        if (this.privKeyBytes) {\n            this.privKeyBytes.fill(0);\n            this.privKeyBytes = undefined;\n        }\n        return this;\n    }\n    toJSON() {\n        return {\n            xpriv: this.privateExtendedKey,\n            xpub: this.publicExtendedKey,\n        };\n    }\n    serialize(version, key) {\n        if (!this.chainCode) {\n            throw new Error('No chainCode set');\n        }\n        assertBytes(key, 33);\n        // version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n        return concatBytes(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);\n    }\n}\n//# sourceMappingURL=index.js.map","import assert from '@noble/hashes/_assert';\nimport { pbkdf2, pbkdf2Async } from '@noble/hashes/pbkdf2';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { sha512 } from '@noble/hashes/sha512';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { utils as baseUtils } from '@scure/base';\nconst isJapanese = (wordlist) => wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093';\nfunction nfkd(str) {\n    if (typeof str !== 'string')\n        throw new TypeError(`Invalid mnemonic type: ${typeof str}`);\n    return str.normalize('NFKD');\n}\nfunction normalize(str) {\n    const norm = nfkd(str);\n    const words = norm.split(' ');\n    if (![12, 15, 18, 21, 24].includes(words.length))\n        throw new Error('Invalid mnemonic');\n    return { nfkd: norm, words };\n}\nfunction assertEntropy(entropy) {\n    assert.bytes(entropy, 16, 20, 24, 28, 32);\n}\nexport function generateMnemonic(wordlist, strength = 128) {\n    assert.number(strength);\n    if (strength % 32 !== 0 || strength > 256)\n        throw new TypeError('Invalid entropy');\n    return entropyToMnemonic(randomBytes(strength / 8), wordlist);\n}\nconst calcChecksum = (entropy) => {\n    const bitsLeft = 8 - entropy.length / 4;\n    return new Uint8Array([(sha256(entropy)[0] >> bitsLeft) << bitsLeft]);\n};\nfunction getCoder(wordlist) {\n    if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== 'string')\n        throw new Error('Worlist: expected array of 2048 strings');\n    wordlist.forEach((i) => {\n        if (typeof i !== 'string')\n            throw new Error(`Wordlist: non-string element: ${i}`);\n    });\n    return baseUtils.chain(baseUtils.checksum(1, calcChecksum), baseUtils.radix2(11, true), baseUtils.alphabet(wordlist));\n}\nexport function mnemonicToEntropy(mnemonic, wordlist) {\n    const { words } = normalize(mnemonic);\n    const entropy = getCoder(wordlist).decode(words);\n    assertEntropy(entropy);\n    return entropy;\n}\nexport function entropyToMnemonic(entropy, wordlist) {\n    assertEntropy(entropy);\n    const words = getCoder(wordlist).encode(entropy);\n    return words.join(isJapanese(wordlist) ? '\\u3000' : ' ');\n}\nexport function validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nconst salt = (passphrase) => nfkd(`mnemonic${passphrase}`);\nexport function mnemonicToSeed(mnemonic, passphrase = '') {\n    return pbkdf2Async(sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });\n}\nexport function mnemonicToSeedSync(mnemonic, passphrase = '') {\n    return pbkdf2(sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });\n}\n//# sourceMappingURL=index.js.map","import { hash as assertHash, number as assertNumber } from './_assert.js';\nimport { hmac } from './hmac.js';\nimport { createView, toBytes, checkOpts, asyncLoop } from './utils.js';\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n    assertHash(hash);\n    const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);\n    const { c, dkLen, asyncTick } = opts;\n    assertNumber(c);\n    assertNumber(dkLen);\n    assertNumber(asyncTick);\n    if (c < 1)\n        throw new Error('PBKDF2: iterations (c) should be >= 1');\n    const password = toBytes(_password);\n    const salt = toBytes(_salt);\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n    const DK = new Uint8Array(dkLen);\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    const PRF = hmac.create(hash, password);\n    const PRFSalt = PRF._cloneInto().update(salt);\n    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW)\n        prfW.destroy();\n    u.fill(0);\n    return DK;\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n */\nexport function pbkdf2(hash, password, salt, opts) {\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = createView(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 +  + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for (let ui = 1; ui < c; ui++) {\n            // Uc = PRF(Password, Uc1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        }\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\nexport async function pbkdf2Async(hash, password, salt, opts) {\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = createView(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 +  + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        await asyncLoop(c - 1, asyncTick, () => {\n            // Uc = PRF(Password, Uc1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        });\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n//# sourceMappingURL=pbkdf2.js.map","function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n//# sourceMappingURL=_assert.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","import { exists, output } from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nexport class SHA2 extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        exists(this);\n        output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map","import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n//# sourceMappingURL=sha256.js.map","import { SHA2 } from './_sha2.js';\nimport { wrapConstructor } from './utils.js';\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\nconst Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);\nconst Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++)\n    for (let j of [idxL, idxR])\n        j.push(j[i].map((k) => Rho[k]));\nconst shifts = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\nconst shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst Kl = /* @__PURE__ */ new Uint32Array([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr = /* @__PURE__ */ new Uint32Array([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));\n// It's called f() in spec.\nfunction f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    else if (group === 1)\n        return (x & y) | (~x & z);\n    else if (group === 2)\n        return (x | ~y) ^ z;\n    else if (group === 3)\n        return (x & z) | (y & ~z);\n    else\n        return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst BUF = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends SHA2 {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        BUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a hash function from 1990s.\n * @param message - msg that would be hashed\n */\nexport const ripemd160 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());\n//# sourceMappingURL=ripemd160.js.map","import * as base from '@scure/base';\nexport const EMPTY = new Uint8Array();\nexport const NULL = new Uint8Array([0]);\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] !== b[i])\n            return false;\n    return true;\n}\nexport function concatBytes(...arrays) {\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nexport const isBytes = (b) => b instanceof Uint8Array;\nexport class Reader {\n    constructor(data, path = [], fieldPath = []) {\n        this.data = data;\n        this.path = path;\n        this.fieldPath = fieldPath;\n        this.pos = 0;\n        this.hasPtr = false;\n        this.bitBuf = 0;\n        this.bitPos = 0;\n    }\n    err(msg) {\n        return new Error(`Reader(${this.fieldPath.join('/')}): ${msg}`);\n    }\n    absBytes(n) {\n        if (n > this.data.length)\n            throw new Error('absBytes: Unexpected end of buffer');\n        return this.data.subarray(n);\n    }\n    bytes(n, peek = false) {\n        if (this.bitPos)\n            throw this.err('readBytes: bitPos not empty');\n        if (!Number.isFinite(n))\n            throw this.err(`readBytes: wrong length=${n}`);\n        if (this.pos + n > this.data.length)\n            throw this.err('readBytes: Unexpected end of buffer');\n        const slice = this.data.subarray(this.pos, this.pos + n);\n        if (!peek)\n            this.pos += n;\n        return slice;\n    }\n    byte(peek = false) {\n        if (this.bitPos)\n            throw this.err('readByte: bitPos not empty');\n        return this.data[peek ? this.pos : this.pos++];\n    }\n    get leftBytes() {\n        return this.data.length - this.pos;\n    }\n    isEnd() {\n        return this.pos >= this.data.length && !this.bitPos;\n    }\n    length(len) {\n        let byteLen;\n        if (isCoder(len))\n            byteLen = Number(len.decodeStream(this));\n        else if (typeof len === 'number')\n            byteLen = len;\n        else if (typeof len === 'string')\n            byteLen = getPath(this.path, len.split('/'));\n        if (typeof byteLen === 'bigint')\n            byteLen = Number(byteLen);\n        if (typeof byteLen !== 'number')\n            throw this.err(`Wrong length: ${byteLen}`);\n        return byteLen;\n    }\n    bits(bits) {\n        if (bits > 32)\n            throw this.err('BitReader: cannot read more than 32 bits in single call');\n        let out = 0;\n        while (bits) {\n            if (!this.bitPos) {\n                this.bitBuf = this.data[this.pos++];\n                this.bitPos = 8;\n            }\n            const take = Math.min(bits, this.bitPos);\n            this.bitPos -= take;\n            out = (out << take) | ((this.bitBuf >> this.bitPos) & (2 ** take - 1));\n            this.bitBuf &= 2 ** this.bitPos - 1;\n            bits -= take;\n        }\n        return out >>> 0;\n    }\n    find(needle, pos = this.pos) {\n        if (!isBytes(needle))\n            throw this.err(`find: needle is not bytes! ${needle}`);\n        if (this.bitPos)\n            throw this.err('findByte: bitPos not empty');\n        if (!needle.length)\n            throw this.err(`find: needle is empty`);\n        for (let idx = pos; (idx = this.data.indexOf(needle[0], idx)) !== -1; idx++) {\n            if (idx === -1)\n                return;\n            const leftBytes = this.data.length - idx;\n            if (leftBytes < needle.length)\n                return;\n            if (equalBytes(needle, this.data.subarray(idx, idx + needle.length)))\n                return idx;\n        }\n    }\n    finish() {\n        if (this.isEnd() || this.hasPtr)\n            return;\n        throw this.err(`${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${base.hex.encode(this.data.slice(this.pos))}`);\n    }\n    fieldPathPush(s) {\n        this.fieldPath.push(s);\n    }\n    fieldPathPop() {\n        this.fieldPath.pop();\n    }\n}\nexport class Writer {\n    constructor(path = [], fieldPath = []) {\n        this.path = path;\n        this.fieldPath = fieldPath;\n        this.buffers = [];\n        this.pos = 0;\n        this.ptrs = [];\n        this.bitBuf = 0;\n        this.bitPos = 0;\n    }\n    err(msg) {\n        return new Error(`Writer(${this.fieldPath.join('/')}): ${msg}`);\n    }\n    bytes(b) {\n        if (this.bitPos)\n            throw this.err('writeBytes: ends with non-empty bit buffer');\n        this.buffers.push(b);\n        this.pos += b.length;\n    }\n    byte(b) {\n        if (this.bitPos)\n            throw this.err('writeByte: ends with non-empty bit buffer');\n        this.buffers.push(new Uint8Array([b]));\n        this.pos++;\n    }\n    get buffer() {\n        if (this.bitPos)\n            throw this.err('buffer: ends with non-empty bit buffer');\n        let buf = concatBytes(...this.buffers);\n        for (let ptr of this.ptrs) {\n            const pos = buf.length;\n            buf = concatBytes(buf, ptr.buffer);\n            const val = ptr.ptr.encode(pos);\n            for (let i = 0; i < val.length; i++)\n                buf[ptr.pos + i] = val[i];\n        }\n        return buf;\n    }\n    length(len, value) {\n        if (len === null)\n            return;\n        if (isCoder(len))\n            return len.encodeStream(this, value);\n        let byteLen;\n        if (typeof len === 'number')\n            byteLen = len;\n        else if (typeof len === 'string')\n            byteLen = getPath(this.path, len.split('/'));\n        if (typeof byteLen === 'bigint')\n            byteLen = Number(byteLen);\n        if (byteLen === undefined || byteLen !== value)\n            throw this.err(`Wrong length: ${byteLen} len=${len} exp=${value}`);\n    }\n    bits(value, bits) {\n        if (bits > 32)\n            throw this.err('writeBits: cannot write more than 32 bits in single call');\n        if (value >= 2 ** bits)\n            throw this.err(`writeBits: value (${value}) >= 2**bits (${bits})`);\n        while (bits) {\n            const take = Math.min(bits, 8 - this.bitPos);\n            this.bitBuf = (this.bitBuf << take) | (value >> (bits - take));\n            this.bitPos += take;\n            bits -= take;\n            value &= 2 ** bits - 1;\n            if (this.bitPos === 8) {\n                this.bitPos = 0;\n                this.buffers.push(new Uint8Array([this.bitBuf]));\n                this.pos++;\n            }\n        }\n    }\n    fieldPathPush(s) {\n        this.fieldPath.push(s);\n    }\n    fieldPathPop() {\n        this.fieldPath.pop();\n    }\n}\nconst swap = (b) => Uint8Array.from(b).reverse();\nexport function checkBounds(p, value, bits, signed) {\n    if (signed) {\n        const signBit = 2n ** (bits - 1n);\n        if (value < -signBit || value >= signBit)\n            throw p.err('sInt: value out of bounds');\n    }\n    else {\n        if (0n > value || value >= 2n ** bits)\n            throw p.err('uInt: value out of bounds');\n    }\n}\nexport function wrap(inner) {\n    return {\n        ...inner,\n        encode: (value) => {\n            const w = new Writer();\n            inner.encodeStream(w, value);\n            return w.buffer;\n        },\n        decode: (data) => {\n            const r = new Reader(data);\n            const res = inner.decodeStream(r);\n            r.finish();\n            return res;\n        },\n    };\n}\nfunction getPath(objPath, path) {\n    objPath = Array.from(objPath);\n    let i = 0;\n    for (; i < path.length; i++) {\n        if (path[i] === '..')\n            objPath.pop();\n        else\n            break;\n    }\n    let cur = objPath.pop();\n    for (; i < path.length; i++) {\n        if (!cur || cur[path[i]] === undefined)\n            return undefined;\n        cur = cur[path[i]];\n    }\n    return cur;\n}\nexport function isCoder(elm) {\n    return (typeof elm.encode === 'function' &&\n        typeof elm.encodeStream === 'function' &&\n        typeof elm.decode === 'function' &&\n        typeof elm.decodeStream === 'function');\n}\nfunction dict() {\n    return {\n        encode: (from) => {\n            const to = {};\n            for (const [name, value] of from) {\n                if (to[name] !== undefined)\n                    throw new Error(`coders.dict: same key(${name}) appears twice in struct`);\n                to[name] = value;\n            }\n            return to;\n        },\n        decode: (to) => Object.entries(to),\n    };\n}\nconst number = {\n    encode: (from) => {\n        if (from > BigInt(Number.MAX_SAFE_INTEGER))\n            throw new Error(`coders.number: element bigger than MAX_SAFE_INTEGER=${from}`);\n        return Number(from);\n    },\n    decode: (to) => BigInt(to),\n};\nfunction tsEnum(e) {\n    return {\n        encode: (from) => e[from],\n        decode: (to) => e[to],\n    };\n}\nfunction decimal(precision) {\n    const decimalMask = 10n ** BigInt(precision);\n    return {\n        encode: (from) => {\n            let s = (from < 0n ? -from : from).toString(10);\n            let sep = s.length - precision;\n            if (sep < 0) {\n                s = s.padStart(s.length - sep, '0');\n                sep = 0;\n            }\n            let i = s.length - 1;\n            for (; i >= sep && s[i] === '0'; i--)\n                ;\n            let [int, frac] = [s.slice(0, sep), s.slice(sep, i + 1)];\n            if (!int)\n                int = '0';\n            if (from < 0n)\n                int = '-' + int;\n            if (!frac)\n                return int;\n            return `${int}.${frac}`;\n        },\n        decode: (to) => {\n            let neg = false;\n            if (to.startsWith('-')) {\n                neg = true;\n                to = to.slice(1);\n            }\n            let sep = to.indexOf('.');\n            sep = sep === -1 ? to.length : sep;\n            const [intS, fracS] = [to.slice(0, sep), to.slice(sep + 1)];\n            const int = BigInt(intS) * decimalMask;\n            const fracLen = Math.min(fracS.length, precision);\n            const frac = BigInt(fracS.slice(0, fracLen)) * 10n ** BigInt(precision - fracLen);\n            const value = int + frac;\n            return neg ? -value : value;\n        },\n    };\n}\nfunction match(lst) {\n    return {\n        encode: (from) => {\n            for (const c of lst) {\n                const elm = c.encode(from);\n                if (elm !== undefined)\n                    return elm;\n            }\n            throw new Error(`match/encode: cannot find match in ${from}`);\n        },\n        decode: (to) => {\n            for (const c of lst) {\n                const elm = c.decode(to);\n                if (elm !== undefined)\n                    return elm;\n            }\n            throw new Error(`match/decode: cannot find match in ${to}`);\n        },\n    };\n}\nexport const coders = { dict, number, tsEnum, decimal, match };\nexport const bits = (len) => wrap({\n    encodeStream: (w, value) => w.bits(value, len),\n    decodeStream: (r) => r.bits(len),\n});\nexport const bigint = (size, le = false, signed = false) => wrap({\n    size,\n    encodeStream: (w, value) => {\n        if (typeof value !== 'number' && typeof value !== 'bigint')\n            throw w.err(`bigint: invalid value: ${value}`);\n        let _value = BigInt(value);\n        const bLen = BigInt(size);\n        checkBounds(w, _value, 8n * bLen, !!signed);\n        const signBit = 2n ** (8n * bLen - 1n);\n        if (signed && _value < 0)\n            _value = _value | signBit;\n        let b = [];\n        for (let i = 0; i < size; i++) {\n            b.push(Number(_value & 255n));\n            _value >>= 8n;\n        }\n        let res = new Uint8Array(b).reverse();\n        w.bytes(le ? res.reverse() : res);\n    },\n    decodeStream: (r) => {\n        const bLen = BigInt(size);\n        let value = r.bytes(size);\n        if (le)\n            value = swap(value);\n        const b = swap(value);\n        const signBit = 2n ** (8n * bLen - 1n);\n        let res = 0n;\n        for (let i = 0; i < b.length; i++)\n            res |= BigInt(b[i]) << (8n * BigInt(i));\n        if (signed && res & signBit)\n            res = (res ^ signBit) - signBit;\n        checkBounds(r, res, 8n * bLen, !!signed);\n        return res;\n    },\n});\nexport const U256LE = bigint(32, true);\nexport const U256BE = bigint(32, false);\nexport const I256LE = bigint(32, true, true);\nexport const I256BE = bigint(32, false, true);\nexport const U128LE = bigint(16, true);\nexport const U128BE = bigint(16, false);\nexport const I128LE = bigint(16, true, true);\nexport const I128BE = bigint(16, false, true);\nexport const U64LE = bigint(8, true);\nexport const U64BE = bigint(8, false);\nexport const I64LE = bigint(8, true, true);\nexport const I64BE = bigint(8, false, true);\nexport const int = (size, le = false, signed = false) => {\n    if (size > 6)\n        throw new Error('int supports size up to 6 bytes (48 bits), for other use bigint');\n    return apply(bigint(size, le, signed), coders.number);\n};\nexport const U32LE = int(4, true);\nexport const U32BE = int(4, false);\nexport const I32LE = int(4, true, true);\nexport const I32BE = int(4, false, true);\nexport const U16LE = int(2, true);\nexport const U16BE = int(2, false);\nexport const I16LE = int(2, true, true);\nexport const I16BE = int(2, false, true);\nexport const U8 = int(1, false);\nexport const I8 = int(1, false, true);\nexport const bool = wrap({\n    size: 1,\n    encodeStream: (w, value) => w.byte(value ? 1 : 0),\n    decodeStream: (r) => {\n        const value = r.byte();\n        if (value !== 0 && value !== 1)\n            throw r.err(`bool: invalid value ${value}`);\n        return value === 1;\n    },\n});\nexport const bytes = (len, le = false) => wrap({\n    size: typeof len === 'number' ? len : undefined,\n    encodeStream: (w, value) => {\n        if (!isBytes(value))\n            throw w.err(`bytes: invalid value ${value}`);\n        if (!isBytes(len))\n            w.length(len, value.length);\n        w.bytes(le ? swap(value) : value);\n        if (isBytes(len))\n            w.bytes(len);\n    },\n    decodeStream: (r) => {\n        let bytes;\n        if (isBytes(len)) {\n            const tPos = r.find(len);\n            if (!tPos)\n                throw r.err(`bytes: cannot find terminator`);\n            bytes = r.bytes(tPos - r.pos);\n            r.bytes(len.length);\n        }\n        else\n            bytes = r.bytes(len === null ? r.leftBytes : r.length(len));\n        return le ? swap(bytes) : bytes;\n    },\n});\nexport const string = (len, le = false) => {\n    const inner = bytes(len, le);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => inner.encodeStream(w, base.utf8.decode(value)),\n        decodeStream: (r) => base.utf8.encode(inner.decodeStream(r)),\n    });\n};\nexport const cstring = string(NULL);\nexport const hex = (len, le = false, withZero = false) => {\n    const inner = bytes(len, le);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => {\n            if (withZero && !value.startsWith('0x'))\n                throw new Error('hex(withZero=true).encode input should start with 0x');\n            const bytes = base.hex.decode(withZero ? value.slice(2) : value);\n            return inner.encodeStream(w, bytes);\n        },\n        decodeStream: (r) => (withZero ? '0x' : '') + base.hex.encode(inner.decodeStream(r)),\n    });\n};\nexport function apply(inner, b) {\n    if (!isCoder(inner))\n        throw new Error(`apply: invalid inner value ${inner}`);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => {\n            let innerValue;\n            try {\n                innerValue = b.decode(value);\n            }\n            catch (e) {\n                throw w.err('' + e);\n            }\n            return inner.encodeStream(w, innerValue);\n        },\n        decodeStream: (r) => {\n            const innerValue = inner.decodeStream(r);\n            try {\n                return b.encode(innerValue);\n            }\n            catch (e) {\n                throw r.err('' + e);\n            }\n        },\n    });\n}\nexport function validate(inner, fn) {\n    if (!isCoder(inner))\n        throw new Error(`validate: invalid inner value ${inner}`);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => inner.encodeStream(w, fn(value)),\n        decodeStream: (r) => fn(inner.decodeStream(r)),\n    });\n}\nexport function lazy(fn) {\n    return wrap({\n        encodeStream: (w, value) => fn().encodeStream(w, value),\n        decodeStream: (r) => fn().decodeStream(r),\n    });\n}\nexport const bytesFormatted = (len, fmt, le = false) => {\n    const inner = bytes(len, le);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => inner.encodeStream(w, base.bytes(fmt, value)),\n        decodeStream: (r) => base.str(fmt, inner.decodeStream(r)),\n    });\n};\nexport const flag = (flagValue, xor = false) => wrap({\n    size: flagValue.length,\n    encodeStream: (w, value) => {\n        if (!!value !== xor)\n            w.bytes(flagValue);\n    },\n    decodeStream: (r) => {\n        let hasFlag = r.leftBytes >= flagValue.length;\n        if (hasFlag) {\n            hasFlag = equalBytes(r.bytes(flagValue.length, true), flagValue);\n            if (hasFlag)\n                r.bytes(flagValue.length);\n        }\n        return hasFlag !== xor;\n    },\n});\nexport function flagged(path, inner, def) {\n    if (!isCoder(inner))\n        throw new Error(`flagged: invalid inner value ${inner}`);\n    return wrap({\n        encodeStream: (w, value) => {\n            if (typeof path === 'string') {\n                if (getPath(w.path, path.split('/')))\n                    inner.encodeStream(w, value);\n                else if (def)\n                    inner.encodeStream(w, def);\n            }\n            else {\n                path.encodeStream(w, !!value);\n                if (!!value)\n                    inner.encodeStream(w, value);\n                else if (def)\n                    inner.encodeStream(w, def);\n            }\n        },\n        decodeStream: (r) => {\n            let hasFlag = false;\n            if (typeof path === 'string')\n                hasFlag = getPath(r.path, path.split('/'));\n            else\n                hasFlag = path.decodeStream(r);\n            if (hasFlag)\n                return inner.decodeStream(r);\n            else if (def)\n                inner.decodeStream(r);\n        },\n    });\n}\nexport function optional(flag, inner, def) {\n    if (!isCoder(flag) || !isCoder(inner))\n        throw new Error(`optional: invalid flag or inner value flag=${flag} inner=${inner}`);\n    return wrap({\n        size: def !== undefined && flag.size && inner.size ? flag.size + inner.size : undefined,\n        encodeStream: (w, value) => {\n            flag.encodeStream(w, !!value);\n            if (value)\n                inner.encodeStream(w, value);\n            else if (def !== undefined)\n                inner.encodeStream(w, def);\n        },\n        decodeStream: (r) => {\n            if (flag.decodeStream(r))\n                return inner.decodeStream(r);\n            else if (def !== undefined)\n                inner.decodeStream(r);\n        },\n    });\n}\nexport function magic(inner, constant, check = true) {\n    if (!isCoder(inner))\n        throw new Error(`flagged: invalid inner value ${inner}`);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => inner.encodeStream(w, constant),\n        decodeStream: (r) => {\n            const value = inner.decodeStream(r);\n            if ((check && typeof value !== 'object' && value !== constant) ||\n                (isBytes(constant) && !equalBytes(constant, value))) {\n                throw r.err(`magic: invalid value: ${value} !== ${constant}`);\n            }\n            return;\n        },\n    });\n}\nexport const magicBytes = (constant) => {\n    const c = typeof constant === 'string' ? base.utf8.decode(constant) : constant;\n    return magic(bytes(c.length), c);\n};\nexport function constant(c) {\n    return wrap({\n        encodeStream: (w, value) => {\n            if (value !== c)\n                throw new Error(`constant: invalid value ${value} (exp: ${c})`);\n        },\n        decodeStream: (r) => c,\n    });\n}\nfunction sizeof(fields) {\n    let size = 0;\n    for (let f of fields) {\n        if (!f.size)\n            return;\n        size += f.size;\n    }\n    return size;\n}\nexport function struct(fields) {\n    if (Array.isArray(fields))\n        throw new Error('Packed.Struct: got array instead of object');\n    return wrap({\n        size: sizeof(Object.values(fields)),\n        encodeStream: (w, value) => {\n            if (typeof value !== 'object' || value === null)\n                throw w.err(`struct: invalid value ${value}`);\n            w.path.push(value);\n            for (let name in fields) {\n                w.fieldPathPush(name);\n                let field = fields[name];\n                field.encodeStream(w, value[name]);\n                w.fieldPathPop();\n            }\n            w.path.pop();\n        },\n        decodeStream: (r) => {\n            let res = {};\n            r.path.push(res);\n            for (let name in fields) {\n                r.fieldPathPush(name);\n                res[name] = fields[name].decodeStream(r);\n                r.fieldPathPop();\n            }\n            r.path.pop();\n            return res;\n        },\n    });\n}\nexport function tuple(fields) {\n    if (!Array.isArray(fields))\n        throw new Error(`Packed.Tuple: got ${typeof fields} instead of array`);\n    return wrap({\n        size: sizeof(fields),\n        encodeStream: (w, value) => {\n            if (!Array.isArray(value))\n                throw w.err(`tuple: invalid value ${value}`);\n            w.path.push(value);\n            for (let i = 0; i < fields.length; i++) {\n                w.fieldPathPush('' + i);\n                fields[i].encodeStream(w, value[i]);\n                w.fieldPathPop();\n            }\n            w.path.pop();\n        },\n        decodeStream: (r) => {\n            let res = [];\n            r.path.push(res);\n            for (let i = 0; i < fields.length; i++) {\n                r.fieldPathPush('' + i);\n                res.push(fields[i].decodeStream(r));\n                r.fieldPathPop();\n            }\n            r.path.pop();\n            return res;\n        },\n    });\n}\nexport function prefix(len, inner) {\n    if (!isCoder(inner))\n        throw new Error(`prefix: invalid inner value ${inner}`);\n    if (isBytes(len))\n        throw new Error(`prefix: len cannot be Uint8Array`);\n    const b = bytes(len);\n    return wrap({\n        size: typeof len === 'number' ? len : undefined,\n        encodeStream: (w, value) => {\n            const wChild = new Writer(w.path, w.fieldPath);\n            inner.encodeStream(wChild, value);\n            b.encodeStream(w, wChild.buffer);\n        },\n        decodeStream: (r) => {\n            const data = b.decodeStream(r);\n            return inner.decodeStream(new Reader(data, r.path, r.fieldPath));\n        },\n    });\n}\nexport function array(len, inner) {\n    if (!isCoder(inner))\n        throw new Error(`array: invalid inner value ${inner}`);\n    return wrap({\n        size: typeof len === 'number' && inner.size ? len * inner.size : undefined,\n        encodeStream: (w, value) => {\n            if (!Array.isArray(value))\n                throw w.err(`array: invalid value ${value}`);\n            if (!isBytes(len))\n                w.length(len, value.length);\n            w.path.push(value);\n            for (let i = 0; i < value.length; i++) {\n                w.fieldPathPush('' + i);\n                const elm = value[i];\n                const startPos = w.pos;\n                inner.encodeStream(w, elm);\n                if (isBytes(len)) {\n                    if (len.length > w.pos - startPos)\n                        continue;\n                    const data = w.buffer.subarray(startPos, w.pos);\n                    if (equalBytes(data.subarray(0, len.length), len))\n                        throw w.err(`array: inner element encoding same as separator. elm=${elm} data=${data}`);\n                }\n                w.fieldPathPop();\n            }\n            w.path.pop();\n            if (isBytes(len))\n                w.bytes(len);\n        },\n        decodeStream: (r) => {\n            let res = [];\n            if (len === null) {\n                let i = 0;\n                r.path.push(res);\n                while (!r.isEnd()) {\n                    r.fieldPathPush('' + i++);\n                    res.push(inner.decodeStream(r));\n                    r.fieldPathPop();\n                    if (inner.size && r.leftBytes < inner.size)\n                        break;\n                }\n                r.path.pop();\n            }\n            else if (isBytes(len)) {\n                let i = 0;\n                r.path.push(res);\n                while (true) {\n                    if (equalBytes(r.bytes(len.length, true), len)) {\n                        r.bytes(len.length);\n                        break;\n                    }\n                    r.fieldPathPush('' + i++);\n                    res.push(inner.decodeStream(r));\n                    r.fieldPathPop();\n                }\n                r.path.pop();\n            }\n            else {\n                r.fieldPathPush('arrayLen');\n                const length = r.length(len);\n                r.fieldPathPop();\n                r.path.push(res);\n                for (let i = 0; i < length; i++) {\n                    r.fieldPathPush('' + i);\n                    res.push(inner.decodeStream(r));\n                    r.fieldPathPop();\n                }\n                r.path.pop();\n            }\n            return res;\n        },\n    });\n}\nexport function map(inner, variants) {\n    if (!isCoder(inner))\n        throw new Error(`map: invalid inner value ${inner}`);\n    const variantNames = new Map();\n    for (const k in variants)\n        variantNames.set(variants[k], k);\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => {\n            if (typeof value !== 'string')\n                throw w.err(`map: invalid value ${value}`);\n            if (!(value in variants))\n                throw w.err(`Map: unknown variant: ${value}`);\n            inner.encodeStream(w, variants[value]);\n        },\n        decodeStream: (r) => {\n            const variant = inner.decodeStream(r);\n            const name = variantNames.get(variant);\n            if (name === undefined)\n                throw r.err(`Enum: unknown value: ${variant} ${Array.from(variantNames.keys())}`);\n            return name;\n        },\n    });\n}\nexport function tag(tag, variants) {\n    if (!isCoder(tag))\n        throw new Error(`tag: invalid tag value ${tag}`);\n    return wrap({\n        size: tag.size,\n        encodeStream: (w, value) => {\n            const { TAG, data } = value;\n            const dataType = variants[TAG];\n            if (!dataType)\n                throw w.err(`Tag: invalid tag ${TAG.toString()}`);\n            tag.encodeStream(w, TAG);\n            dataType.encodeStream(w, data);\n        },\n        decodeStream: (r) => {\n            const TAG = tag.decodeStream(r);\n            const dataType = variants[TAG];\n            if (!dataType)\n                throw r.err(`Tag: invalid tag ${TAG}`);\n            return { TAG, data: dataType.decodeStream(r) };\n        },\n    });\n}\nexport function mappedTag(tagCoder, variants) {\n    if (!isCoder(tagCoder))\n        throw new Error(`mappedTag: invalid tag value ${tag}`);\n    const mapValue = {};\n    const tagValue = {};\n    for (const key in variants) {\n        mapValue[key] = variants[key][0];\n        tagValue[key] = variants[key][1];\n    }\n    return tag(map(tagCoder, mapValue), tagValue);\n}\nexport function bitset(names, pad = false) {\n    return wrap({\n        encodeStream: (w, value) => {\n            if (typeof value !== 'object' || value === null)\n                throw w.err(`bitset: invalid value ${value}`);\n            for (let i = 0; i < names.length; i++)\n                w.bits(+value[names[i]], 1);\n            if (pad && names.length % 8)\n                w.bits(0, 8 - (names.length % 8));\n        },\n        decodeStream: (r) => {\n            let out = {};\n            for (let i = 0; i < names.length; i++)\n                out[names[i]] = !!r.bits(1);\n            if (pad && names.length % 8)\n                r.bits(8 - (names.length % 8));\n            return out;\n        },\n    });\n}\nexport const ZeroPad = (_) => 0;\nfunction padLength(blockSize, len) {\n    if (len % blockSize === 0)\n        return 0;\n    return blockSize - (len % blockSize);\n}\nexport function padLeft(blockSize, inner, padFn) {\n    if (!isCoder(inner))\n        throw new Error(`padLeft: invalid inner value ${inner}`);\n    const _padFn = padFn || ZeroPad;\n    if (!inner.size)\n        throw new Error('padLeft with dynamic size argument is impossible');\n    return wrap({\n        size: inner.size + padLength(blockSize, inner.size),\n        encodeStream: (w, value) => {\n            const padBytes = padLength(blockSize, inner.size);\n            for (let i = 0; i < padBytes; i++)\n                w.byte(_padFn(i));\n            inner.encodeStream(w, value);\n        },\n        decodeStream: (r) => {\n            r.bytes(padLength(blockSize, inner.size));\n            return inner.decodeStream(r);\n        },\n    });\n}\nexport function padRight(blockSize, inner, padFn) {\n    if (!isCoder(inner))\n        throw new Error(`padRight: invalid inner value ${inner}`);\n    const _padFn = padFn || ZeroPad;\n    return wrap({\n        size: inner.size ? inner.size + padLength(blockSize, inner.size) : undefined,\n        encodeStream: (w, value) => {\n            const pos = w.pos;\n            inner.encodeStream(w, value);\n            const padBytes = padLength(blockSize, w.pos - pos);\n            for (let i = 0; i < padBytes; i++)\n                w.byte(_padFn(i));\n        },\n        decodeStream: (r) => {\n            const start = r.pos;\n            const res = inner.decodeStream(r);\n            r.bytes(padLength(blockSize, r.pos - start));\n            return res;\n        },\n    });\n}\nexport function pointer(ptr, inner, sized = false) {\n    if (!isCoder(ptr))\n        throw new Error(`pointer: invalid ptr value ${ptr}`);\n    if (!isCoder(inner))\n        throw new Error(`pointer: invalid inner value ${inner}`);\n    if (!ptr.size)\n        throw new Error('Pointer: unsized ptr');\n    return wrap({\n        size: sized ? ptr.size : undefined,\n        encodeStream: (w, value) => {\n            const start = w.pos;\n            ptr.encodeStream(w, 0);\n            w.ptrs.push({ pos: start, ptr, buffer: inner.encode(value) });\n        },\n        decodeStream: (r) => {\n            const ptrVal = ptr.decodeStream(r);\n            if (ptrVal < r.pos)\n                throw new Error('pointer.decodeStream pointer less than position');\n            r.hasPtr = true;\n            const rChild = new Reader(r.absBytes(ptrVal), r.path, r.fieldPath);\n            return inner.decodeStream(rChild);\n        },\n    });\n}\nexport function base64armor(name, lineLen, inner, checksum) {\n    const markBegin = `-----BEGIN ${name.toUpperCase()}-----`;\n    const markEnd = `-----END ${name.toUpperCase()}-----`;\n    return {\n        encode(value) {\n            const data = inner.encode(value);\n            const encoded = base.base64.encode(data);\n            let lines = [];\n            for (let i = 0; i < encoded.length; i += lineLen) {\n                const s = encoded.slice(i, i + lineLen);\n                if (s.length)\n                    lines.push(`${encoded.slice(i, i + lineLen)}\\n`);\n            }\n            let body = lines.join('');\n            if (checksum)\n                body += `=${base.base64.encode(checksum(data))}\\n`;\n            return `${markBegin}\\n\\n${body}${markEnd}\\n`;\n        },\n        decode(s) {\n            let lines = s.replace(markBegin, '').replace(markEnd, '').trim().split('\\n');\n            lines = lines.map((l) => l.replace('\\r', '').trim());\n            if (checksum && lines[lines.length - 1].startsWith('=')) {\n                const body = base.base64.decode(lines.slice(0, -1).join(''));\n                const cs = lines[lines.length - 1].slice(1);\n                const realCS = base.base64.encode(checksum(body));\n                if (realCS !== cs)\n                    throw new Error(`Base64Armor: invalid checksum ${cs} instead of ${realCS}`);\n                return inner.decode(body);\n            }\n            return inner.decode(base.base64.decode(lines.join('')));\n        },\n    };\n}\nexport const nothing = magic(bytes(0), EMPTY);\nexport function debug(inner) {\n    if (!isCoder(inner))\n        throw new Error(`debug: invalid inner value ${inner}`);\n    const log = (name, rw, value) => {\n        console.log(`DEBUG/${name}(${rw.fieldPath.join('/')}):`, { type: typeof value, value });\n        return value;\n    };\n    return wrap({\n        size: inner.size,\n        encodeStream: (w, value) => inner.encodeStream(w, log('encode', w, value)),\n        decodeStream: (r) => log('decode', r, inner.decodeStream(r)),\n    });\n}\n","/*! scure-btc-signer - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { secp256k1 as _secp, schnorr } from '@noble/curves/secp256k1';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { hex, base58check as _b58, bech32, bech32m } from '@scure/base';\nimport * as P from 'micro-packed';\nconst { ProjectivePoint: ProjPoint, sign: _signECDSA, getPublicKey: _pubECDSA } = _secp;\nconst CURVE_ORDER = _secp.CURVE.n;\n// Same as value || def, but doesn't overwrites zero ('0', 0, 0n, etc)\nconst def = (value, def) => (value === undefined ? def : value);\nconst isBytes = P.isBytes;\nconst hash160 = (msg) => ripemd160(sha256(msg));\nconst sha256x2 = (...msgs) => sha256(sha256(concat(...msgs)));\nconst concat = P.concatBytes;\n// Make base58check work\nexport const base58check = _b58(sha256);\nexport function cloneDeep(obj) {\n    if (Array.isArray(obj))\n        return obj.map((i) => cloneDeep(i));\n    // slice of nodejs Buffer doesn't copy\n    else if (obj instanceof Uint8Array)\n        return Uint8Array.from(obj);\n    // immutable\n    else if (['number', 'bigint', 'boolean', 'string', 'undefined'].includes(typeof obj))\n        return obj;\n    // null is object\n    else if (obj === null)\n        return obj;\n    // should be last, so it won't catch other types\n    else if (typeof obj === 'object') {\n        return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, cloneDeep(v)]));\n    }\n    throw new Error(`cloneDeep: unknown type=${obj} (${typeof obj})`);\n}\nvar PubT;\n(function (PubT) {\n    PubT[PubT[\"ecdsa\"] = 0] = \"ecdsa\";\n    PubT[PubT[\"schnorr\"] = 1] = \"schnorr\";\n})(PubT || (PubT = {}));\nfunction validatePubkey(pub, type) {\n    const len = pub.length;\n    if (type === PubT.ecdsa) {\n        if (len === 32)\n            throw new Error('Expected non-Schnorr key');\n        ProjPoint.fromHex(pub); // does assertValidity\n        return pub;\n    }\n    else if (type === PubT.schnorr) {\n        if (len !== 32)\n            throw new Error('Expected 32-byte Schnorr key');\n        schnorr.utils.lift_x(schnorr.utils.bytesToNumberBE(pub));\n        return pub;\n    }\n    else {\n        throw new Error('Unknown key type');\n    }\n}\nfunction isValidPubkey(pub, type) {\n    try {\n        validatePubkey(pub, type);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n// low-r signature grinding. Used to reduce tx size by 1 byte.\n// noble/secp256k1 does not support the feature: it is not used outside of BTC.\n// We implement it manually, because in BTC it's common.\n// Not best way, but closest to bitcoin implementation (easier to check)\nconst hasLowR = (sig) => sig.r < CURVE_ORDER / 2n;\nfunction signECDSA(hash, privateKey, lowR = false) {\n    let sig = _signECDSA(hash, privateKey);\n    if (lowR && !hasLowR(sig)) {\n        const extraEntropy = new Uint8Array(32);\n        for (let cnt = 0; cnt < Number.MAX_SAFE_INTEGER; cnt++) {\n            extraEntropy.set(P.U32LE.encode(cnt));\n            sig = _signECDSA(hash, privateKey, { extraEntropy });\n            if (hasLowR(sig))\n                break;\n        }\n    }\n    return sig.toDERRawBytes();\n}\nfunction tapTweak(a, b) {\n    const u = schnorr.utils;\n    const t = u.taggedHash('TapTweak', a, b);\n    const tn = u.bytesToNumberBE(t);\n    if (tn >= CURVE_ORDER)\n        throw new Error('tweak higher than curve order');\n    return tn;\n}\nexport function taprootTweakPrivKey(privKey, merkleRoot = new Uint8Array()) {\n    const u = schnorr.utils;\n    const seckey0 = u.bytesToNumberBE(privKey); // seckey0 = int_from_bytes(seckey0)\n    const P = ProjPoint.fromPrivateKey(seckey0); // P = point_mul(G, seckey0)\n    // seckey = seckey0 if has_even_y(P) else SECP256K1_ORDER - seckey0\n    const seckey = P.hasEvenY() ? seckey0 : u.mod(-seckey0, CURVE_ORDER);\n    const xP = u.pointToBytes(P);\n    // t = int_from_bytes(tagged_hash(\"TapTweak\", bytes_from_int(x(P)) + h)); >= SECP256K1_ORDER check\n    const t = tapTweak(xP, merkleRoot);\n    // bytes_from_int((seckey + t) % SECP256K1_ORDER)\n    return u.numberToBytesBE(u.mod(seckey + t, CURVE_ORDER), 32);\n}\nexport function taprootTweakPubkey(pubKey, h) {\n    const u = schnorr.utils;\n    const t = tapTweak(pubKey, h); // t = int_from_bytes(tagged_hash(\"TapTweak\", pubkey + h))\n    const P = u.lift_x(u.bytesToNumberBE(pubKey)); // P = lift_x(int_from_bytes(pubkey))\n    const Q = P.add(ProjPoint.fromPrivateKey(t)); // Q = point_add(P, point_mul(G, t))\n    const parity = Q.hasEvenY() ? 0 : 1; // 0 if has_even_y(Q) else 1\n    return [u.pointToBytes(Q), parity]; // bytes_from_int(x(Q))\n}\n// Can be 33 or 64 bytes\nconst PubKeyECDSA = P.validate(P.bytes(null), (pub) => validatePubkey(pub, PubT.ecdsa));\nconst PubKeySchnorr = P.validate(P.bytes(32), (pub) => validatePubkey(pub, PubT.schnorr));\nconst SignatureSchnorr = P.validate(P.bytes(null), (sig) => {\n    if (sig.length !== 64 && sig.length !== 65)\n        throw new Error('Schnorr signature should be 64 or 65 bytes long');\n    return sig;\n});\nfunction uniqPubkey(pubkeys) {\n    const map = {};\n    for (const pub of pubkeys) {\n        const key = hex.encode(pub);\n        if (map[key])\n            throw new Error(`Multisig: non-uniq pubkey: ${pubkeys.map(hex.encode)}`);\n        map[key] = true;\n    }\n}\nexport const NETWORK = {\n    bech32: 'bc',\n    pubKeyHash: 0x00,\n    scriptHash: 0x05,\n    wif: 0x80,\n};\nexport const TEST_NETWORK = {\n    bech32: 'tb',\n    pubKeyHash: 0x6f,\n    scriptHash: 0xc4,\n    wif: 0xef,\n};\nexport const PRECISION = 8;\nexport const DEFAULT_VERSION = 2;\nexport const DEFAULT_LOCKTIME = 0;\nexport const DEFAULT_SEQUENCE = 4294967295;\nconst EMPTY32 = new Uint8Array(32);\n// Utils\nexport const Decimal = P.coders.decimal(PRECISION);\n// Exported for tests, internal method\nexport function _cmpBytes(a, b) {\n    if (!isBytes(a) || !isBytes(b))\n        throw new Error(`cmp: wrong type a=${typeof a} b=${typeof b}`);\n    // -1 -> a<b, 0 -> a==b, 1 -> a>b\n    const len = Math.min(a.length, b.length);\n    for (let i = 0; i < len; i++)\n        if (a[i] != b[i])\n            return Math.sign(a[i] - b[i]);\n    return Math.sign(a.length - b.length);\n}\n// Coders\n// prettier-ignore\nexport var OP;\n(function (OP) {\n    OP[OP[\"OP_0\"] = 0] = \"OP_0\";\n    OP[OP[\"PUSHDATA1\"] = 76] = \"PUSHDATA1\";\n    OP[OP[\"PUSHDATA2\"] = 77] = \"PUSHDATA2\";\n    OP[OP[\"PUSHDATA4\"] = 78] = \"PUSHDATA4\";\n    OP[OP[\"1NEGATE\"] = 79] = \"1NEGATE\";\n    OP[OP[\"RESERVED\"] = 80] = \"RESERVED\";\n    OP[OP[\"OP_1\"] = 81] = \"OP_1\";\n    OP[OP[\"OP_2\"] = 82] = \"OP_2\";\n    OP[OP[\"OP_3\"] = 83] = \"OP_3\";\n    OP[OP[\"OP_4\"] = 84] = \"OP_4\";\n    OP[OP[\"OP_5\"] = 85] = \"OP_5\";\n    OP[OP[\"OP_6\"] = 86] = \"OP_6\";\n    OP[OP[\"OP_7\"] = 87] = \"OP_7\";\n    OP[OP[\"OP_8\"] = 88] = \"OP_8\";\n    OP[OP[\"OP_9\"] = 89] = \"OP_9\";\n    OP[OP[\"OP_10\"] = 90] = \"OP_10\";\n    OP[OP[\"OP_11\"] = 91] = \"OP_11\";\n    OP[OP[\"OP_12\"] = 92] = \"OP_12\";\n    OP[OP[\"OP_13\"] = 93] = \"OP_13\";\n    OP[OP[\"OP_14\"] = 94] = \"OP_14\";\n    OP[OP[\"OP_15\"] = 95] = \"OP_15\";\n    OP[OP[\"OP_16\"] = 96] = \"OP_16\";\n    // Control\n    OP[OP[\"NOP\"] = 97] = \"NOP\";\n    OP[OP[\"VER\"] = 98] = \"VER\";\n    OP[OP[\"IF\"] = 99] = \"IF\";\n    OP[OP[\"NOTIF\"] = 100] = \"NOTIF\";\n    OP[OP[\"VERIF\"] = 101] = \"VERIF\";\n    OP[OP[\"VERNOTIF\"] = 102] = \"VERNOTIF\";\n    OP[OP[\"ELSE\"] = 103] = \"ELSE\";\n    OP[OP[\"ENDIF\"] = 104] = \"ENDIF\";\n    OP[OP[\"VERIFY\"] = 105] = \"VERIFY\";\n    OP[OP[\"RETURN\"] = 106] = \"RETURN\";\n    // Stack\n    OP[OP[\"TOALTSTACK\"] = 107] = \"TOALTSTACK\";\n    OP[OP[\"FROMALTSTACK\"] = 108] = \"FROMALTSTACK\";\n    OP[OP[\"2DROP\"] = 109] = \"2DROP\";\n    OP[OP[\"2DUP\"] = 110] = \"2DUP\";\n    OP[OP[\"3DUP\"] = 111] = \"3DUP\";\n    OP[OP[\"2OVER\"] = 112] = \"2OVER\";\n    OP[OP[\"2ROT\"] = 113] = \"2ROT\";\n    OP[OP[\"2SWAP\"] = 114] = \"2SWAP\";\n    OP[OP[\"IFDUP\"] = 115] = \"IFDUP\";\n    OP[OP[\"DEPTH\"] = 116] = \"DEPTH\";\n    OP[OP[\"DROP\"] = 117] = \"DROP\";\n    OP[OP[\"DUP\"] = 118] = \"DUP\";\n    OP[OP[\"NIP\"] = 119] = \"NIP\";\n    OP[OP[\"OVER\"] = 120] = \"OVER\";\n    OP[OP[\"PICK\"] = 121] = \"PICK\";\n    OP[OP[\"ROLL\"] = 122] = \"ROLL\";\n    OP[OP[\"ROT\"] = 123] = \"ROT\";\n    OP[OP[\"SWAP\"] = 124] = \"SWAP\";\n    OP[OP[\"TUCK\"] = 125] = \"TUCK\";\n    // Splice\n    OP[OP[\"CAT\"] = 126] = \"CAT\";\n    OP[OP[\"SUBSTR\"] = 127] = \"SUBSTR\";\n    OP[OP[\"LEFT\"] = 128] = \"LEFT\";\n    OP[OP[\"RIGHT\"] = 129] = \"RIGHT\";\n    OP[OP[\"SIZE\"] = 130] = \"SIZE\";\n    // Boolean logic\n    OP[OP[\"INVERT\"] = 131] = \"INVERT\";\n    OP[OP[\"AND\"] = 132] = \"AND\";\n    OP[OP[\"OR\"] = 133] = \"OR\";\n    OP[OP[\"XOR\"] = 134] = \"XOR\";\n    OP[OP[\"EQUAL\"] = 135] = \"EQUAL\";\n    OP[OP[\"EQUALVERIFY\"] = 136] = \"EQUALVERIFY\";\n    OP[OP[\"RESERVED1\"] = 137] = \"RESERVED1\";\n    OP[OP[\"RESERVED2\"] = 138] = \"RESERVED2\";\n    // Numbers\n    OP[OP[\"1ADD\"] = 139] = \"1ADD\";\n    OP[OP[\"1SUB\"] = 140] = \"1SUB\";\n    OP[OP[\"2MUL\"] = 141] = \"2MUL\";\n    OP[OP[\"2DIV\"] = 142] = \"2DIV\";\n    OP[OP[\"NEGATE\"] = 143] = \"NEGATE\";\n    OP[OP[\"ABS\"] = 144] = \"ABS\";\n    OP[OP[\"NOT\"] = 145] = \"NOT\";\n    OP[OP[\"0NOTEQUAL\"] = 146] = \"0NOTEQUAL\";\n    OP[OP[\"ADD\"] = 147] = \"ADD\";\n    OP[OP[\"SUB\"] = 148] = \"SUB\";\n    OP[OP[\"MUL\"] = 149] = \"MUL\";\n    OP[OP[\"DIV\"] = 150] = \"DIV\";\n    OP[OP[\"MOD\"] = 151] = \"MOD\";\n    OP[OP[\"LSHIFT\"] = 152] = \"LSHIFT\";\n    OP[OP[\"RSHIFT\"] = 153] = \"RSHIFT\";\n    OP[OP[\"BOOLAND\"] = 154] = \"BOOLAND\";\n    OP[OP[\"BOOLOR\"] = 155] = \"BOOLOR\";\n    OP[OP[\"NUMEQUAL\"] = 156] = \"NUMEQUAL\";\n    OP[OP[\"NUMEQUALVERIFY\"] = 157] = \"NUMEQUALVERIFY\";\n    OP[OP[\"NUMNOTEQUAL\"] = 158] = \"NUMNOTEQUAL\";\n    OP[OP[\"LESSTHAN\"] = 159] = \"LESSTHAN\";\n    OP[OP[\"GREATERTHAN\"] = 160] = \"GREATERTHAN\";\n    OP[OP[\"LESSTHANOREQUAL\"] = 161] = \"LESSTHANOREQUAL\";\n    OP[OP[\"GREATERTHANOREQUAL\"] = 162] = \"GREATERTHANOREQUAL\";\n    OP[OP[\"MIN\"] = 163] = \"MIN\";\n    OP[OP[\"MAX\"] = 164] = \"MAX\";\n    OP[OP[\"WITHIN\"] = 165] = \"WITHIN\";\n    // Crypto\n    OP[OP[\"RIPEMD160\"] = 166] = \"RIPEMD160\";\n    OP[OP[\"SHA1\"] = 167] = \"SHA1\";\n    OP[OP[\"SHA256\"] = 168] = \"SHA256\";\n    OP[OP[\"HASH160\"] = 169] = \"HASH160\";\n    OP[OP[\"HASH256\"] = 170] = \"HASH256\";\n    OP[OP[\"CODESEPARATOR\"] = 171] = \"CODESEPARATOR\";\n    OP[OP[\"CHECKSIG\"] = 172] = \"CHECKSIG\";\n    OP[OP[\"CHECKSIGVERIFY\"] = 173] = \"CHECKSIGVERIFY\";\n    OP[OP[\"CHECKMULTISIG\"] = 174] = \"CHECKMULTISIG\";\n    OP[OP[\"CHECKMULTISIGVERIFY\"] = 175] = \"CHECKMULTISIGVERIFY\";\n    // Expansion\n    OP[OP[\"NOP1\"] = 176] = \"NOP1\";\n    OP[OP[\"CHECKLOCKTIMEVERIFY\"] = 177] = \"CHECKLOCKTIMEVERIFY\";\n    OP[OP[\"CHECKSEQUENCEVERIFY\"] = 178] = \"CHECKSEQUENCEVERIFY\";\n    OP[OP[\"NOP4\"] = 179] = \"NOP4\";\n    OP[OP[\"NOP5\"] = 180] = \"NOP5\";\n    OP[OP[\"NOP6\"] = 181] = \"NOP6\";\n    OP[OP[\"NOP7\"] = 182] = \"NOP7\";\n    OP[OP[\"NOP8\"] = 183] = \"NOP8\";\n    OP[OP[\"NOP9\"] = 184] = \"NOP9\";\n    OP[OP[\"NOP10\"] = 185] = \"NOP10\";\n    // BIP 342\n    OP[OP[\"CHECKSIGADD\"] = 186] = \"CHECKSIGADD\";\n    // Invalid\n    OP[OP[\"INVALID\"] = 255] = \"INVALID\";\n})(OP || (OP = {}));\n// Converts script bytes to parsed script\n// 5221030000000000000000000000000000000000000000000000000000000000000001210300000000000000000000000000000000000000000000000000000000000000022103000000000000000000000000000000000000000000000000000000000000000353ae\n// =>\n// OP_2\n//   030000000000000000000000000000000000000000000000000000000000000001\n//   030000000000000000000000000000000000000000000000000000000000000002\n//   030000000000000000000000000000000000000000000000000000000000000003\n//   OP_3\n//   CHECKMULTISIG\nexport const Script = P.wrap({\n    encodeStream: (w, value) => {\n        for (let o of value) {\n            if (typeof o === 'string') {\n                if (OP[o] === undefined)\n                    throw new Error(`Unknown opcode=${o}`);\n                w.byte(OP[o]);\n                continue;\n            }\n            else if (typeof o === 'number') {\n                if (o === 0x00) {\n                    w.byte(0x00);\n                    continue;\n                }\n                else if (1 <= o && o <= 16) {\n                    w.byte(OP.OP_1 - 1 + o);\n                    continue;\n                }\n            }\n            // Encode big numbers\n            if (typeof o === 'number')\n                o = ScriptNum().encode(BigInt(o));\n            if (!isBytes(o))\n                throw new Error(`Wrong Script OP=${o} (${typeof o})`);\n            // Bytes\n            const len = o.length;\n            if (len < OP.PUSHDATA1)\n                w.byte(len);\n            else if (len <= 0xff) {\n                w.byte(OP.PUSHDATA1);\n                w.byte(len);\n            }\n            else if (len <= 0xffff) {\n                w.byte(OP.PUSHDATA2);\n                w.bytes(P.U16LE.encode(len));\n            }\n            else {\n                w.byte(OP.PUSHDATA4);\n                w.bytes(P.U32LE.encode(len));\n            }\n            w.bytes(o);\n        }\n    },\n    decodeStream: (r) => {\n        const out = [];\n        while (!r.isEnd()) {\n            const cur = r.byte();\n            // if 0 < cur < 78\n            if (OP.OP_0 < cur && cur <= OP.PUSHDATA4) {\n                let len;\n                if (cur < OP.PUSHDATA1)\n                    len = cur;\n                else if (cur === OP.PUSHDATA1)\n                    len = P.U8.decodeStream(r);\n                else if (cur === OP.PUSHDATA2)\n                    len = P.U16LE.decodeStream(r);\n                else if (cur === OP.PUSHDATA4)\n                    len = P.U32LE.decodeStream(r);\n                else\n                    throw new Error('Should be not possible');\n                out.push(r.bytes(len));\n            }\n            else if (cur === 0x00) {\n                out.push(0);\n            }\n            else if (OP.OP_1 <= cur && cur <= OP.OP_16) {\n                out.push(cur - (OP.OP_1 - 1));\n            }\n            else {\n                const op = OP[cur];\n                if (op === undefined)\n                    throw new Error(`Unknown opcode=${cur.toString(16)}`);\n                out.push(op);\n            }\n        }\n        return out;\n    },\n});\n// We can encode almost any number as ScriptNum, however, parsing will be a problem\n// since we can't know if buffer is a number or something else.\nexport function ScriptNum(bytesLimit = 6, forceMinimal = false) {\n    return P.wrap({\n        encodeStream: (w, value) => {\n            if (value === 0n)\n                return;\n            const neg = value < 0;\n            const val = BigInt(value);\n            const nums = [];\n            for (let abs = neg ? -val : val; abs; abs >>= 8n)\n                nums.push(Number(abs & 0xffn));\n            if (nums[nums.length - 1] >= 0x80)\n                nums.push(neg ? 0x80 : 0);\n            else if (neg)\n                nums[nums.length - 1] |= 0x80;\n            w.bytes(new Uint8Array(nums));\n        },\n        decodeStream: (r) => {\n            const len = r.leftBytes;\n            if (len > bytesLimit)\n                throw new Error(`ScriptNum: number (${len}) bigger than limit=${bytesLimit}`);\n            if (len === 0)\n                return 0n;\n            if (forceMinimal) {\n                // MSB is zero (without sign bit) -> not minimally encoded\n                if ((r.data[len - 1] & 0x7f) === 0) {\n                    // exception\n                    if (len <= 1 || (r.data[len - 2] & 0x80) === 0)\n                        throw new Error('Non-minimally encoded ScriptNum');\n                }\n            }\n            let last = 0;\n            let res = 0n;\n            for (let i = 0; i < len; ++i) {\n                last = r.byte();\n                res |= BigInt(last) << (8n * BigInt(i));\n            }\n            if (last >= 0x80) {\n                res &= (2n ** BigInt(len * 8) - 1n) >> 1n;\n                res = -res;\n            }\n            return res;\n        },\n    });\n}\nexport function OpToNum(op, bytesLimit = 4, forceMinimal = true) {\n    if (typeof op === 'number')\n        return op;\n    if (isBytes(op)) {\n        try {\n            const val = ScriptNum(bytesLimit, forceMinimal).decode(op);\n            if (val > Number.MAX_SAFE_INTEGER)\n                return;\n            return Number(val);\n        }\n        catch (e) {\n            return;\n        }\n    }\n    return;\n}\n// BTC specific variable length integer encoding\n// https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer\nconst CSLimits = {\n    0xfd: [0xfd, 2, 253n, 65535n],\n    0xfe: [0xfe, 4, 65536n, 4294967295n],\n    0xff: [0xff, 8, 4294967296n, 18446744073709551615n],\n};\nexport const CompactSize = P.wrap({\n    encodeStream: (w, value) => {\n        if (typeof value === 'number')\n            value = BigInt(value);\n        if (0n <= value && value <= 252n)\n            return w.byte(Number(value));\n        for (const [flag, bytes, start, stop] of Object.values(CSLimits)) {\n            if (start > value || value > stop)\n                continue;\n            w.byte(flag);\n            for (let i = 0; i < bytes; i++)\n                w.byte(Number((value >> (8n * BigInt(i))) & 0xffn));\n            return;\n        }\n        throw w.err(`VarInt too big: ${value}`);\n    },\n    decodeStream: (r) => {\n        const b0 = r.byte();\n        if (b0 <= 0xfc)\n            return BigInt(b0);\n        const [_, bytes, start] = CSLimits[b0];\n        let num = 0n;\n        for (let i = 0; i < bytes; i++)\n            num |= BigInt(r.byte()) << (8n * BigInt(i));\n        if (num < start)\n            throw r.err(`Wrong CompactSize(${8 * bytes})`);\n        return num;\n    },\n});\n// Same thing, but in number instead of bigint. Checks for safe integer inside\nconst CompactSizeLen = P.apply(CompactSize, P.coders.number);\n// Array of size <CompactSize>\nexport const BTCArray = (t) => P.array(CompactSize, t);\n// ui8a of size <CompactSize>\nexport const VarBytes = P.bytes(CompactSize);\nexport const RawInput = P.struct({\n    txid: P.bytes(32, true),\n    index: P.U32LE,\n    finalScriptSig: VarBytes,\n    sequence: P.U32LE, // ?\n});\nexport const RawOutput = P.struct({ amount: P.U64LE, script: VarBytes });\nconst EMPTY_OUTPUT = {\n    amount: 0xffffffffffffffffn,\n    script: P.EMPTY,\n};\n// SegWit v0 stack of witness buffers\nexport const RawWitness = P.array(CompactSizeLen, VarBytes);\n// https://en.bitcoin.it/wiki/Protocol_documentation#tx\nconst _RawTx = P.struct({\n    version: P.I32LE,\n    segwitFlag: P.flag(new Uint8Array([0x00, 0x01])),\n    inputs: BTCArray(RawInput),\n    outputs: BTCArray(RawOutput),\n    witnesses: P.flagged('segwitFlag', P.array('inputs/length', RawWitness)),\n    // < 500000000\tBlock number at which this transaction is unlocked\n    // >= 500000000\tUNIX timestamp at which this transaction is unlocked\n    // Handled as part of PSBTv2\n    lockTime: P.U32LE,\n});\nfunction validateRawTx(tx) {\n    if (tx.segwitFlag && tx.witnesses && !tx.witnesses.length)\n        throw new Error('Segwit flag with empty witnesses array');\n    return tx;\n}\nexport const RawTx = P.validate(_RawTx, validateRawTx);\nfunction PSBTKeyInfo(info) {\n    const [type, kc, vc, reqInc, allowInc, silentIgnore] = info;\n    return { type, kc, vc, reqInc, allowInc, silentIgnore };\n}\nconst BIP32Der = P.struct({\n    fingerprint: P.U32BE,\n    path: P.array(null, P.U32LE),\n});\n// Complex structure for PSBT fields\n// <control byte with leaf version and parity bit> <internal key p> <C> <E> <AB>\nconst _TaprootControlBlock = P.struct({\n    version: P.U8,\n    internalKey: P.bytes(32),\n    merklePath: P.array(null, P.bytes(32)),\n});\nexport const TaprootControlBlock = P.validate(_TaprootControlBlock, (cb) => {\n    if (cb.merklePath.length > 128)\n        throw new Error('TaprootControlBlock: merklePath should be of length 0..128 (inclusive)');\n    return cb;\n});\nconst TaprootBIP32Der = P.struct({\n    hashes: P.array(CompactSizeLen, P.bytes(32)),\n    der: BIP32Der,\n});\n// The 78 byte serialized extended public key as defined by BIP 32.\nconst GlobalXPUB = P.bytes(78);\nconst tapScriptSigKey = P.struct({ pubKey: PubKeySchnorr, leafHash: P.bytes(32) });\n// {<8-bit uint depth> <8-bit uint leaf version> <compact size uint scriptlen> <bytes script>}*\nconst tapTree = P.array(null, P.struct({\n    depth: P.U8,\n    version: P.U8,\n    script: VarBytes,\n}));\nconst BytesInf = P.bytes(null); // Bytes will conflict with Bytes type\nconst Bytes20 = P.bytes(20);\nconst Bytes32 = P.bytes(32);\n// versionsRequiringExclusing = !versionsAllowsInclusion (as set)\n// {name: [tag, keyCoder, valueCoder, versionsRequiringInclusion, versionsRequiringExclusing, versionsAllowsInclusion, silentIgnore]}\n// SilentIgnore: we use some v2 fields for v1 representation too, so we just clean them before serialize\n// Tables from BIP-0174 (https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki)\n// prettier-ignore\nconst PSBTGlobal = {\n    unsignedTx: [0x00, false, RawTx, [0], [0], false],\n    xpub: [0x01, GlobalXPUB, BIP32Der, [], [0, 2], false],\n    txVersion: [0x02, false, P.U32LE, [2], [2], false],\n    fallbackLocktime: [0x03, false, P.U32LE, [], [2], false],\n    inputCount: [0x04, false, CompactSizeLen, [2], [2], false],\n    outputCount: [0x05, false, CompactSizeLen, [2], [2], false],\n    txModifiable: [0x06, false, P.U8, [], [2], false],\n    version: [0xfb, false, P.U32LE, [], [0, 2], false],\n    proprietary: [0xfc, BytesInf, BytesInf, [], [0, 2], false],\n};\n// prettier-ignore\nconst PSBTInput = {\n    nonWitnessUtxo: [0x00, false, RawTx, [], [0, 2], false],\n    witnessUtxo: [0x01, false, RawOutput, [], [0, 2], false],\n    partialSig: [0x02, PubKeyECDSA, BytesInf, [], [0, 2], false],\n    sighashType: [0x03, false, P.U32LE, [], [0, 2], false],\n    redeemScript: [0x04, false, BytesInf, [], [0, 2], false],\n    witnessScript: [0x05, false, BytesInf, [], [0, 2], false],\n    bip32Derivation: [0x06, PubKeyECDSA, BIP32Der, [], [0, 2], false],\n    finalScriptSig: [0x07, false, BytesInf, [], [0, 2], false],\n    finalScriptWitness: [0x08, false, RawWitness, [], [0, 2], false],\n    porCommitment: [0x09, false, BytesInf, [], [0, 2], false],\n    ripemd160: [0x0a, Bytes20, BytesInf, [], [0, 2], false],\n    sha256: [0x0b, Bytes32, BytesInf, [], [0, 2], false],\n    hash160: [0x0c, Bytes20, BytesInf, [], [0, 2], false],\n    hash256: [0x0d, Bytes32, BytesInf, [], [0, 2], false],\n    txid: [0x0e, false, Bytes32, [2], [2], true],\n    index: [0x0f, false, P.U32LE, [2], [2], true],\n    sequence: [0x10, false, P.U32LE, [], [2], true],\n    requiredTimeLocktime: [0x11, false, P.U32LE, [], [2], false],\n    requiredHeightLocktime: [0x12, false, P.U32LE, [], [2], false],\n    tapKeySig: [0x13, false, SignatureSchnorr, [], [0, 2], false],\n    tapScriptSig: [0x14, tapScriptSigKey, SignatureSchnorr, [], [0, 2], false],\n    tapLeafScript: [0x15, TaprootControlBlock, BytesInf, [], [0, 2], false],\n    tapBip32Derivation: [0x16, Bytes32, TaprootBIP32Der, [], [0, 2], false],\n    tapInternalKey: [0x17, false, PubKeySchnorr, [], [0, 2], false],\n    tapMerkleRoot: [0x18, false, Bytes32, [], [0, 2], false],\n    proprietary: [0xfc, BytesInf, BytesInf, [], [0, 2], false],\n};\n// All other keys removed when finalizing\nconst PSBTInputFinalKeys = [\n    'txid',\n    'sequence',\n    'index',\n    'witnessUtxo',\n    'nonWitnessUtxo',\n    'finalScriptSig',\n    'finalScriptWitness',\n    'unknown',\n];\n// Can be modified even on signed input\nconst PSBTInputUnsignedKeys = [\n    'partialSig',\n    'finalScriptSig',\n    'finalScriptWitness',\n    'tapKeySig',\n    'tapScriptSig',\n];\n// prettier-ignore\nconst PSBTOutput = {\n    redeemScript: [0x00, false, BytesInf, [], [0, 2], false],\n    witnessScript: [0x01, false, BytesInf, [], [0, 2], false],\n    bip32Derivation: [0x02, PubKeyECDSA, BIP32Der, [], [0, 2], false],\n    amount: [0x03, false, P.I64LE, [2], [2], true],\n    script: [0x04, false, BytesInf, [2], [2], true],\n    tapInternalKey: [0x05, false, PubKeySchnorr, [], [0, 2], false],\n    tapTree: [0x06, false, tapTree, [], [0, 2], false],\n    tapBip32Derivation: [0x07, PubKeySchnorr, TaprootBIP32Der, [], [0, 2], false],\n    proprietary: [0xfc, BytesInf, BytesInf, [], [0, 2], false],\n};\n// Can be modified even on signed input\nconst PSBTOutputUnsignedKeys = [];\nconst PSBTKeyPair = P.array(P.NULL, P.struct({\n    //  <key> := <keylen> <keytype> <keydata> WHERE keylen = len(keytype)+len(keydata)\n    key: P.prefix(CompactSizeLen, P.struct({ type: CompactSizeLen, key: P.bytes(null) })),\n    //  <value> := <valuelen> <valuedata>\n    value: P.bytes(CompactSizeLen),\n}));\nconst PSBTUnknownKey = P.struct({ type: CompactSizeLen, key: P.bytes(null) });\n// Key cannot be 'unknown', value coder cannot be array for elements with empty key\nfunction PSBTKeyMap(psbtEnum) {\n    // -> Record<type, [keyName, ...coders]>\n    const byType = {};\n    for (const k in psbtEnum) {\n        const [num, kc, vc] = psbtEnum[k];\n        byType[num] = [k, kc, vc];\n    }\n    return P.wrap({\n        encodeStream: (w, value) => {\n            let out = [];\n            // Because we use order of psbtEnum, keymap is sorted here\n            for (const name in psbtEnum) {\n                const val = value[name];\n                if (val === undefined)\n                    continue;\n                const [type, kc, vc] = psbtEnum[name];\n                if (!kc) {\n                    out.push({ key: { type, key: P.EMPTY }, value: vc.encode(val) });\n                }\n                else {\n                    // Low level interface, returns keys as is (with duplicates). Useful for debug\n                    const kv = val.map(([k, v]) => [\n                        kc.encode(k),\n                        vc.encode(v),\n                    ]);\n                    // sort by keys\n                    kv.sort((a, b) => _cmpBytes(a[0], b[0]));\n                    for (const [key, value] of kv)\n                        out.push({ key: { key, type }, value });\n                }\n            }\n            if (value.unknown) {\n                value.unknown.sort((a, b) => _cmpBytes(a[0].key, b[0].key));\n                for (const [k, v] of value.unknown)\n                    out.push({ key: k, value: v });\n            }\n            PSBTKeyPair.encodeStream(w, out);\n        },\n        decodeStream: (r) => {\n            const raw = PSBTKeyPair.decodeStream(r);\n            const out = {};\n            const noKey = {};\n            for (const elm of raw) {\n                let name = 'unknown';\n                let key = elm.key.key;\n                let value = elm.value;\n                if (byType[elm.key.type]) {\n                    const [_name, kc, vc] = byType[elm.key.type];\n                    name = _name;\n                    if (!kc && key.length) {\n                        throw new Error(`PSBT: Non-empty key for ${name} (key=${hex.encode(key)} value=${hex.encode(value)}`);\n                    }\n                    key = kc ? kc.decode(key) : undefined;\n                    value = vc.decode(value);\n                    if (!kc) {\n                        if (out[name])\n                            throw new Error(`PSBT: Same keys: ${name} (key=${key} value=${value})`);\n                        out[name] = value;\n                        noKey[name] = true;\n                        continue;\n                    }\n                }\n                else {\n                    // For unknown: add key type inside key\n                    key = { type: elm.key.type, key: elm.key.key };\n                }\n                // Only keyed elements at this point\n                if (noKey[name])\n                    throw new Error(`PSBT: Key type with empty key and no key=${name} val=${value}`);\n                if (!out[name])\n                    out[name] = [];\n                out[name].push([key, value]);\n            }\n            return out;\n        },\n    });\n}\n// Basic sanity check for scripts\nfunction checkWSH(s, witnessScript) {\n    if (!P.equalBytes(s.hash, sha256(witnessScript)))\n        throw new Error('checkScript: wsh wrong witnessScript hash');\n    const w = OutScript.decode(witnessScript);\n    if (w.type === 'tr' || w.type === 'tr_ns' || w.type === 'tr_ms')\n        throw new Error(`checkScript: P2${w.type} cannot be wrapped in P2SH`);\n    if (w.type === 'wpkh' || w.type === 'sh')\n        throw new Error(`checkScript: P2${w.type} cannot be wrapped in P2WSH`);\n}\nfunction checkScript(script, redeemScript, witnessScript) {\n    if (script) {\n        const s = OutScript.decode(script);\n        // ms||pk maybe work, but there will be no address, hard to spend\n        if (s.type === 'tr_ns' || s.type === 'tr_ms' || s.type === 'ms' || s.type == 'pk')\n            throw new Error(`checkScript: non-wrapped ${s.type}`);\n        if (s.type === 'sh' && redeemScript) {\n            if (!P.equalBytes(s.hash, hash160(redeemScript)))\n                throw new Error('checkScript: sh wrong redeemScript hash');\n            const r = OutScript.decode(redeemScript);\n            if (r.type === 'tr' || r.type === 'tr_ns' || r.type === 'tr_ms')\n                throw new Error(`checkScript: P2${r.type} cannot be wrapped in P2SH`);\n            // Not sure if this unspendable, but we cannot represent this via PSBT\n            if (r.type === 'sh')\n                throw new Error('checkScript: P2SH cannot be wrapped in P2SH');\n        }\n        if (s.type === 'wsh' && witnessScript)\n            checkWSH(s, witnessScript);\n    }\n    if (redeemScript) {\n        const r = OutScript.decode(redeemScript);\n        if (r.type === 'wsh' && witnessScript)\n            checkWSH(r, witnessScript);\n    }\n}\nconst PSBTInputCoder = P.validate(PSBTKeyMap(PSBTInput), (i) => {\n    if (i.finalScriptWitness && !i.finalScriptWitness.length)\n        throw new Error('validateInput: wmpty finalScriptWitness');\n    //if (i.finalScriptSig && !i.finalScriptSig.length) throw new Error('validateInput: empty finalScriptSig');\n    if (i.partialSig && !i.partialSig.length)\n        throw new Error('Empty partialSig');\n    if (i.partialSig)\n        for (const [k] of i.partialSig)\n            validatePubkey(k, PubT.ecdsa);\n    if (i.bip32Derivation)\n        for (const [k] of i.bip32Derivation)\n            validatePubkey(k, PubT.ecdsa);\n    // Locktime = unsigned little endian integer greater than or equal to 500000000 representing\n    if (i.requiredTimeLocktime !== undefined && i.requiredTimeLocktime < 500000000)\n        throw new Error(`validateInput: wrong timeLocktime=${i.requiredTimeLocktime}`);\n    // unsigned little endian integer greater than 0 and less than 500000000\n    if (i.requiredHeightLocktime !== undefined &&\n        (i.requiredHeightLocktime <= 0 || i.requiredHeightLocktime >= 500000000))\n        throw new Error(`validateInput: wrong heighLocktime=${i.requiredHeightLocktime}`);\n    if (i.nonWitnessUtxo && i.index !== undefined) {\n        const last = i.nonWitnessUtxo.outputs.length - 1;\n        if (i.index > last)\n            throw new Error(`validateInput: index(${i.index}) not in nonWitnessUtxo`);\n        const prevOut = i.nonWitnessUtxo.outputs[i.index];\n        if (i.witnessUtxo &&\n            (!P.equalBytes(i.witnessUtxo.script, prevOut.script) ||\n                i.witnessUtxo.amount !== prevOut.amount))\n            throw new Error('validateInput: witnessUtxo different from nonWitnessUtxo');\n    }\n    if (i.tapLeafScript) {\n        // tap leaf version appears here twice: in control block and at the end of script\n        for (const [k, v] of i.tapLeafScript) {\n            if ((k.version & 254) !== v[v.length - 1])\n                throw new Error('validateInput: tapLeafScript version mimatch');\n            if (v[v.length - 1] & 1)\n                throw new Error('validateInput: tapLeafScript version has parity bit!');\n        }\n    }\n    // Validate txid for nonWitnessUtxo is correct\n    if (i.nonWitnessUtxo && i.index && i.txid) {\n        const outputs = i.nonWitnessUtxo.outputs;\n        if (outputs.length - 1 < i.index)\n            throw new Error('nonWitnessUtxo: incorect output index');\n        const tx = Transaction.fromRaw(RawTx.encode(i.nonWitnessUtxo));\n        const txid = hex.encode(i.txid);\n        if (tx.id !== txid)\n            throw new Error(`nonWitnessUtxo: wrong txid, exp=${txid} got=${tx.id}`);\n    }\n    return i;\n});\nconst PSBTOutputCoder = P.validate(PSBTKeyMap(PSBTOutput), (o) => {\n    if (o.bip32Derivation)\n        for (const [k] of o.bip32Derivation)\n            validatePubkey(k, PubT.ecdsa);\n    return o;\n});\nconst PSBTGlobalCoder = P.validate(PSBTKeyMap(PSBTGlobal), (g) => {\n    const version = g.version || 0;\n    if (version === 0) {\n        if (!g.unsignedTx)\n            throw new Error('PSBTv0: missing unsignedTx');\n        if (g.unsignedTx.segwitFlag || g.unsignedTx.witnesses)\n            throw new Error('PSBTv0: witness in unsingedTx');\n        for (const inp of g.unsignedTx.inputs)\n            if (inp.finalScriptSig && inp.finalScriptSig.length)\n                throw new Error('PSBTv0: input scriptSig found in unsignedTx');\n    }\n    return g;\n});\nexport const _RawPSBTV0 = P.struct({\n    magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n    global: PSBTGlobalCoder,\n    inputs: P.array('global/unsignedTx/inputs/length', PSBTInputCoder),\n    outputs: P.array(null, PSBTOutputCoder),\n});\nexport const _RawPSBTV2 = P.struct({\n    magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n    global: PSBTGlobalCoder,\n    inputs: P.array('global/inputCount', PSBTInputCoder),\n    outputs: P.array('global/outputCount', PSBTOutputCoder),\n});\nexport const _DebugPSBT = P.struct({\n    magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n    items: P.array(null, P.apply(P.array(P.NULL, P.tuple([P.hex(CompactSizeLen), P.bytes(CompactSize)])), P.coders.dict())),\n});\nfunction validatePSBTFields(version, info, lst) {\n    for (const k in lst) {\n        if (k === 'unknown')\n            continue;\n        if (!info[k])\n            continue;\n        const { allowInc } = PSBTKeyInfo(info[k]);\n        if (!allowInc.includes(version))\n            throw new Error(`PSBTv${version}: field ${k} is not allowed`);\n    }\n    for (const k in info) {\n        const { reqInc } = PSBTKeyInfo(info[k]);\n        if (reqInc.includes(version) && lst[k] === undefined)\n            throw new Error(`PSBTv${version}: missing required field ${k}`);\n    }\n}\nfunction cleanPSBTFields(version, info, lst) {\n    const out = {};\n    for (const _k in lst) {\n        const k = _k;\n        if (k !== 'unknown') {\n            if (!info[k])\n                continue;\n            const { allowInc, silentIgnore } = PSBTKeyInfo(info[k]);\n            if (!allowInc.includes(version)) {\n                if (silentIgnore)\n                    continue;\n                throw new Error(`Failed to serialize in PSBTv${version}: ${k} but versions allows inclusion=${allowInc}`);\n            }\n        }\n        out[k] = lst[k];\n    }\n    return out;\n}\nfunction validatePSBT(tx) {\n    const version = (tx && tx.global && tx.global.version) || 0;\n    validatePSBTFields(version, PSBTGlobal, tx.global);\n    for (const i of tx.inputs)\n        validatePSBTFields(version, PSBTInput, i);\n    for (const o of tx.outputs)\n        validatePSBTFields(version, PSBTOutput, o);\n    // We allow only one empty element at the end of map (compat with bitcoinjs-lib bug)\n    const inputCount = !version ? tx.global.unsignedTx.inputs.length : tx.global.inputCount;\n    if (tx.inputs.length < inputCount)\n        throw new Error('Not enough inputs');\n    const inputsLeft = tx.inputs.slice(inputCount);\n    if (inputsLeft.length > 1 || (inputsLeft.length && Object.keys(inputsLeft[0]).length))\n        throw new Error(`Unexpected inputs left in tx=${inputsLeft}`);\n    // Same for inputs\n    const outputCount = !version ? tx.global.unsignedTx.outputs.length : tx.global.outputCount;\n    if (tx.outputs.length < outputCount)\n        throw new Error('Not outputs inputs');\n    const outputsLeft = tx.outputs.slice(outputCount);\n    if (outputsLeft.length > 1 || (outputsLeft.length && Object.keys(outputsLeft[0]).length))\n        throw new Error(`Unexpected outputs left in tx=${outputsLeft}`);\n    return tx;\n}\nfunction mergeKeyMap(psbtEnum, val, cur, allowedFields) {\n    const res = { ...cur, ...val };\n    // All arguments can be provided as hex\n    for (const k in psbtEnum) {\n        const key = k;\n        const [_, kC, vC] = psbtEnum[key];\n        const cannotChange = allowedFields && !allowedFields.includes(k);\n        if (val[k] === undefined && k in val) {\n            if (cannotChange)\n                throw new Error(`Cannot remove signed field=${k}`);\n            delete res[k];\n        }\n        else if (kC) {\n            const oldKV = (cur && cur[k] ? cur[k] : []);\n            let newKV = val[key];\n            if (newKV) {\n                if (!Array.isArray(newKV))\n                    throw new Error(`keyMap(${k}): KV pairs should be [k, v][]`);\n                // Decode hex in k-v\n                newKV = newKV.map((val) => {\n                    if (val.length !== 2)\n                        throw new Error(`keyMap(${k}): KV pairs should be [k, v][]`);\n                    return [\n                        typeof val[0] === 'string' ? kC.decode(hex.decode(val[0])) : val[0],\n                        typeof val[1] === 'string' ? vC.decode(hex.decode(val[1])) : val[1],\n                    ];\n                });\n                const map = {};\n                const add = (kStr, k, v) => {\n                    if (map[kStr] === undefined) {\n                        map[kStr] = [k, v];\n                        return;\n                    }\n                    const oldVal = hex.encode(vC.encode(map[kStr][1]));\n                    const newVal = hex.encode(vC.encode(v));\n                    if (oldVal !== newVal)\n                        throw new Error(`keyMap(${key}): same key=${kStr} oldVal=${oldVal} newVal=${newVal}`);\n                };\n                for (const [k, v] of oldKV) {\n                    const kStr = hex.encode(kC.encode(k));\n                    add(kStr, k, v);\n                }\n                for (const [k, v] of newKV) {\n                    const kStr = hex.encode(kC.encode(k));\n                    // undefined removes previous value\n                    if (v === undefined) {\n                        if (cannotChange)\n                            throw new Error(`Cannot remove signed field=${key}/${k}`);\n                        delete map[kStr];\n                    }\n                    else\n                        add(kStr, k, v);\n                }\n                res[key] = Object.values(map);\n            }\n        }\n        else if (typeof res[k] === 'string') {\n            res[k] = vC.decode(hex.decode(res[k]));\n        }\n        else if (cannotChange && k in val && cur && cur[k] !== undefined) {\n            if (!P.equalBytes(vC.encode(val[k]), vC.encode(cur[k])))\n                throw new Error(`Cannot change signed field=${k}`);\n        }\n    }\n    // Remove unknown keys\n    for (const k in res)\n        if (!psbtEnum[k])\n            delete res[k];\n    return res;\n}\nexport const RawPSBTV0 = P.validate(_RawPSBTV0, validatePSBT);\nexport const RawPSBTV2 = P.validate(_RawPSBTV2, validatePSBT);\n// (TxHash, Idx)\nconst TxHashIdx = P.struct({ txid: P.bytes(32, true), index: P.U32LE });\nconst OutPK = {\n    encode(from) {\n        if (from.length !== 2 ||\n            !isBytes(from[0]) ||\n            !isValidPubkey(from[0], PubT.ecdsa) ||\n            from[1] !== 'CHECKSIG')\n            return;\n        return { type: 'pk', pubkey: from[0] };\n    },\n    decode: (to) => (to.type === 'pk' ? [to.pubkey, 'CHECKSIG'] : undefined),\n};\n// @ts-ignore\nexport const p2pk = (pubkey, network = NETWORK) => {\n    // network is unused\n    if (!isValidPubkey(pubkey, PubT.ecdsa))\n        throw new Error('P2PK: invalid publicKey');\n    return {\n        type: 'pk',\n        script: OutScript.encode({ type: 'pk', pubkey }),\n    };\n};\nconst OutPKH = {\n    encode(from) {\n        if (from.length !== 5 || from[0] !== 'DUP' || from[1] !== 'HASH160' || !isBytes(from[2]))\n            return;\n        if (from[3] !== 'EQUALVERIFY' || from[4] !== 'CHECKSIG')\n            return;\n        return { type: 'pkh', hash: from[2] };\n    },\n    decode: (to) => to.type === 'pkh' ? ['DUP', 'HASH160', to.hash, 'EQUALVERIFY', 'CHECKSIG'] : undefined,\n};\nexport const p2pkh = (publicKey, network = NETWORK) => {\n    if (!isValidPubkey(publicKey, PubT.ecdsa))\n        throw new Error('P2PKH: invalid publicKey');\n    const hash = hash160(publicKey);\n    return {\n        type: 'pkh',\n        script: OutScript.encode({ type: 'pkh', hash }),\n        address: Address(network).encode({ type: 'pkh', hash }),\n    };\n};\nconst OutSH = {\n    encode(from) {\n        if (from.length !== 3 || from[0] !== 'HASH160' || !isBytes(from[1]) || from[2] !== 'EQUAL')\n            return;\n        return { type: 'sh', hash: from[1] };\n    },\n    decode: (to) => to.type === 'sh' ? ['HASH160', to.hash, 'EQUAL'] : undefined,\n};\nexport const p2sh = (child, network = NETWORK) => {\n    // It is already tested inside noble-hashes and checkScript\n    const cs = child.script;\n    if (!isBytes(cs))\n        throw new Error(`Wrong script: ${typeof child.script}, expected Uint8Array`);\n    const hash = hash160(cs);\n    const script = OutScript.encode({ type: 'sh', hash });\n    checkScript(script, cs, child.witnessScript);\n    const res = {\n        type: 'sh',\n        redeemScript: cs,\n        script: OutScript.encode({ type: 'sh', hash }),\n        address: Address(network).encode({ type: 'sh', hash }),\n    };\n    if (child.witnessScript)\n        res.witnessScript = child.witnessScript;\n    return res;\n};\nconst OutWSH = {\n    encode(from) {\n        if (from.length !== 2 || from[0] !== 0 || !isBytes(from[1]))\n            return;\n        if (from[1].length !== 32)\n            return;\n        return { type: 'wsh', hash: from[1] };\n    },\n    decode: (to) => (to.type === 'wsh' ? [0, to.hash] : undefined),\n};\nexport const p2wsh = (child, network = NETWORK) => {\n    const cs = child.script;\n    if (!isBytes(cs))\n        throw new Error(`Wrong script: ${typeof cs}, expected Uint8Array`);\n    const hash = sha256(cs);\n    const script = OutScript.encode({ type: 'wsh', hash });\n    checkScript(script, undefined, cs);\n    return {\n        type: 'wsh',\n        witnessScript: cs,\n        script: OutScript.encode({ type: 'wsh', hash }),\n        address: Address(network).encode({ type: 'wsh', hash }),\n    };\n};\nconst OutWPKH = {\n    encode(from) {\n        if (from.length !== 2 || from[0] !== 0 || !isBytes(from[1]))\n            return;\n        if (from[1].length !== 20)\n            return;\n        return { type: 'wpkh', hash: from[1] };\n    },\n    decode: (to) => (to.type === 'wpkh' ? [0, to.hash] : undefined),\n};\nexport const p2wpkh = (publicKey, network = NETWORK) => {\n    if (!isValidPubkey(publicKey, PubT.ecdsa))\n        throw new Error('P2WPKH: invalid publicKey');\n    if (publicKey.length === 65)\n        throw new Error('P2WPKH: uncompressed public key');\n    const hash = hash160(publicKey);\n    return {\n        type: 'wpkh',\n        script: OutScript.encode({ type: 'wpkh', hash }),\n        address: Address(network).encode({ type: 'wpkh', hash }),\n    };\n};\nconst OutMS = {\n    encode(from) {\n        const last = from.length - 1;\n        if (from[last] !== 'CHECKMULTISIG')\n            return;\n        const m = from[0];\n        const n = from[last - 1];\n        if (typeof m !== 'number' || typeof n !== 'number')\n            return;\n        const pubkeys = from.slice(1, -2);\n        if (n !== pubkeys.length)\n            return;\n        for (const pub of pubkeys)\n            if (!isBytes(pub))\n                return;\n        return { type: 'ms', m, pubkeys: pubkeys }; // we don't need n, since it is the same as pubkeys\n    },\n    // checkmultisig(n, ..pubkeys, m)\n    decode: (to) => to.type === 'ms' ? [to.m, ...to.pubkeys, to.pubkeys.length, 'CHECKMULTISIG'] : undefined,\n};\nexport const p2ms = (m, pubkeys, allowSamePubkeys = false) => {\n    if (!allowSamePubkeys)\n        uniqPubkey(pubkeys);\n    return { type: 'ms', script: OutScript.encode({ type: 'ms', pubkeys, m }) };\n};\nconst OutTR = {\n    encode(from) {\n        if (from.length !== 2 || from[0] !== 1 || !isBytes(from[1]))\n            return;\n        return { type: 'tr', pubkey: from[1] };\n    },\n    decode: (to) => (to.type === 'tr' ? [1, to.pubkey] : undefined),\n};\n// Helper for generating binary tree from list, with weights\nexport function taprootListToTree(taprootList) {\n    // Clone input in order to not corrupt it\n    const lst = Array.from(taprootList);\n    // We have at least 2 elements => can create branch\n    while (lst.length >= 2) {\n        // Sort: elements with smallest weight are in the end of queue\n        lst.sort((a, b) => (b.weight || 1) - (a.weight || 1));\n        const b = lst.pop();\n        const a = lst.pop();\n        const weight = (a?.weight || 1) + (b?.weight || 1);\n        lst.push({\n            weight,\n            // Unwrap children array\n            // TODO: Very hard to remove any here\n            childs: [a?.childs || a, b?.childs || b],\n        });\n    }\n    // At this point there is always 1 element in lst\n    const last = lst[0];\n    return (last?.childs || last);\n}\nfunction checkTaprootScript(script, internalPubKey, allowUnknownOutputs = false) {\n    const out = OutScript.decode(script);\n    if (out.type === 'unknown' && allowUnknownOutputs)\n        return;\n    if (!['tr_ns', 'tr_ms'].includes(out.type))\n        throw new Error(`P2TR: invalid leaf script=${out.type}`);\n    const outms = out;\n    if (!allowUnknownOutputs && outms.pubkeys) {\n        for (const p of outms.pubkeys) {\n            if (P.equalBytes(p, TAPROOT_UNSPENDABLE_KEY))\n                throw new Error('Unspendable taproot key in leaf script');\n            // It's likely a mistake at this point:\n            // 1. p2tr(A, p2tr_ns(2, [A, B])) == p2tr(A, p2tr_pk(B)) (A or B key)\n            // but will take more space and fees.\n            // 2. For multi-sig p2tr(A, p2tr_ns(2, [A, B, C])) it's probably a security issue:\n            // User creates 2 of 3 multisig of keys [A, B, C],\n            // but key A always can spend whole output without signatures from other keys.\n            // p2tr(A, p2tr_ns(2, [B, C, D])) is ok: A or (B and C) or (B and D) or (C and D)\n            if (P.equalBytes(p, internalPubKey)) {\n                throw new Error('Using P2TR with leaf script with same key as internal key is not supported');\n            }\n        }\n    }\n}\nfunction taprootHashTree(tree, internalPubKey, allowUnknownOutputs = false) {\n    if (!tree)\n        throw new Error('taprootHashTree: empty tree');\n    if (Array.isArray(tree) && tree.length === 1)\n        tree = tree[0];\n    // Terminal node (leaf)\n    if (!Array.isArray(tree)) {\n        const { leafVersion: version, script: leafScript } = tree;\n        // Earliest tree walk where we can validate tapScripts\n        if (tree.tapLeafScript || (tree.tapMerkleRoot && !P.equalBytes(tree.tapMerkleRoot, P.EMPTY)))\n            throw new Error('P2TR: tapRoot leafScript cannot have tree');\n        const script = typeof leafScript === 'string' ? hex.decode(leafScript) : leafScript;\n        if (!isBytes(script))\n            throw new Error(`checkScript: wrong script type=${script}`);\n        checkTaprootScript(script, internalPubKey, allowUnknownOutputs);\n        return {\n            type: 'leaf',\n            version,\n            script,\n            hash: tapLeafHash(script, version),\n        };\n    }\n    // If tree / branch is not binary tree, convert it\n    if (tree.length !== 2)\n        tree = taprootListToTree(tree);\n    if (tree.length !== 2)\n        throw new Error('hashTree: non binary tree!');\n    // branch\n    // Both nodes should exist\n    const left = taprootHashTree(tree[0], internalPubKey, allowUnknownOutputs);\n    const right = taprootHashTree(tree[1], internalPubKey, allowUnknownOutputs);\n    // We cannot swap left/right here, since it will change structure of tree\n    let [lH, rH] = [left.hash, right.hash];\n    if (_cmpBytes(rH, lH) === -1)\n        [lH, rH] = [rH, lH];\n    return { type: 'branch', left, right, hash: schnorr.utils.taggedHash('TapBranch', lH, rH) };\n}\nfunction taprootAddPath(tree, path = []) {\n    if (!tree)\n        throw new Error(`taprootAddPath: empty tree`);\n    if (tree.type === 'leaf')\n        return { ...tree, path };\n    if (tree.type !== 'branch')\n        throw new Error(`taprootAddPath: wrong type=${tree}`);\n    return {\n        ...tree,\n        path,\n        // Left element has right hash in path and otherwise\n        left: taprootAddPath(tree.left, [tree.right.hash, ...path]),\n        right: taprootAddPath(tree.right, [tree.left.hash, ...path]),\n    };\n}\nfunction taprootWalkTree(tree) {\n    if (!tree)\n        throw new Error(`taprootAddPath: empty tree`);\n    if (tree.type === 'leaf')\n        return [tree];\n    if (tree.type !== 'branch')\n        throw new Error(`taprootWalkTree: wrong type=${tree}`);\n    return [...taprootWalkTree(tree.left), ...taprootWalkTree(tree.right)];\n}\n// Another stupid decision, where lack of standard affects security.\n// Multisig needs to be generated with some key.\n// We are using approach from BIP 341/bitcoinjs-lib: SHA256(uncompressedDER(SECP256K1_GENERATOR_POINT))\n// It is possible to switch SECP256K1_GENERATOR_POINT with some random point;\n// but it's too complex to prove.\n// Also used by bitcoin-core and bitcoinjs-lib\nexport const TAPROOT_UNSPENDABLE_KEY = sha256(ProjPoint.BASE.toRawBytes(false));\n// Works as key OR tree.\n// If we only have tree, need to add unspendable key, otherwise\n// complex multisig wallet can be spent by owner of key only. See TAPROOT_UNSPENDABLE_KEY\nexport function p2tr(internalPubKey, tree, network = NETWORK, allowUnknownOutputs = false) {\n    // Unspendable\n    if (!internalPubKey && !tree)\n        throw new Error('p2tr: should have pubKey or scriptTree (or both)');\n    const pubKey = typeof internalPubKey === 'string'\n        ? hex.decode(internalPubKey)\n        : internalPubKey || TAPROOT_UNSPENDABLE_KEY;\n    if (!isValidPubkey(pubKey, PubT.schnorr))\n        throw new Error('p2tr: non-schnorr pubkey');\n    let hashedTree = tree\n        ? taprootAddPath(taprootHashTree(tree, pubKey, allowUnknownOutputs))\n        : undefined;\n    const tapMerkleRoot = hashedTree ? hashedTree.hash : undefined;\n    const [tweakedPubkey, parity] = taprootTweakPubkey(pubKey, tapMerkleRoot || P.EMPTY);\n    let leaves;\n    if (hashedTree) {\n        leaves = taprootWalkTree(hashedTree).map((l) => ({\n            ...l,\n            controlBlock: TaprootControlBlock.encode({\n                version: (l.version || TAP_LEAF_VERSION) + parity,\n                internalKey: pubKey,\n                merklePath: l.path,\n            }),\n        }));\n    }\n    let tapLeafScript;\n    if (leaves) {\n        tapLeafScript = leaves.map((l) => [\n            TaprootControlBlock.decode(l.controlBlock),\n            concat(l.script, new Uint8Array([l.version || TAP_LEAF_VERSION])),\n        ]);\n    }\n    const res = {\n        type: 'tr',\n        script: OutScript.encode({ type: 'tr', pubkey: tweakedPubkey }),\n        address: Address(network).encode({ type: 'tr', pubkey: tweakedPubkey }),\n        // For tests\n        tweakedPubkey,\n        // PSBT stuff\n        tapInternalKey: pubKey,\n    };\n    // Just in case someone would want to select a specific script\n    if (leaves)\n        res.leaves = leaves;\n    if (tapLeafScript)\n        res.tapLeafScript = tapLeafScript;\n    if (tapMerkleRoot)\n        res.tapMerkleRoot = tapMerkleRoot;\n    return res;\n}\nconst OutTRNS = {\n    encode(from) {\n        const last = from.length - 1;\n        if (from[last] !== 'CHECKSIG')\n            return;\n        const pubkeys = [];\n        // On error return, since it can be different script\n        for (let i = 0; i < last; i++) {\n            const elm = from[i];\n            if (i & 1) {\n                if (elm !== 'CHECKSIGVERIFY' || i === last - 1)\n                    return;\n                continue;\n            }\n            if (!isBytes(elm))\n                return;\n            pubkeys.push(elm);\n        }\n        return { type: 'tr_ns', pubkeys };\n    },\n    decode: (to) => {\n        if (to.type !== 'tr_ns')\n            return;\n        const out = [];\n        for (let i = 0; i < to.pubkeys.length - 1; i++)\n            out.push(to.pubkeys[i], 'CHECKSIGVERIFY');\n        out.push(to.pubkeys[to.pubkeys.length - 1], 'CHECKSIG');\n        return out;\n    },\n};\n// Returns all combinations of size M from lst\nexport function combinations(m, list) {\n    const res = [];\n    if (!Array.isArray(list))\n        throw new Error('combinations: lst arg should be array');\n    const n = list.length;\n    if (m > n)\n        throw new Error('combinations: m > lst.length, no combinations possible');\n    /*\n    Basically works as M nested loops like:\n    for (;idx[0]<lst.length;idx[0]++) for (idx[1]=idx[0]+1;idx[1]<lst.length;idx[1]++)\n    but since we cannot create nested loops dynamically, we unroll it to a single loop\n    */\n    const idx = Array.from({ length: m }, (_, i) => i);\n    const last = idx.length - 1;\n    main: for (;;) {\n        res.push(idx.map((i) => list[i]));\n        idx[last] += 1;\n        let i = last;\n        // Propagate increment\n        // idx[i] cannot be bigger than n-m+i, otherwise last elements in right part will overflow\n        for (; i >= 0 && idx[i] > n - m + i; i--) {\n            idx[i] = 0;\n            // Overflow in idx[0], break\n            if (i === 0)\n                break main;\n            idx[i - 1] += 1;\n        }\n        // Propagate: idx[i+1] = idx[idx]+1\n        for (i += 1; i < idx.length; i++)\n            idx[i] = idx[i - 1] + 1;\n    }\n    return res;\n}\n/**\n * M-of-N multi-leaf wallet via p2tr_ns. If m == n, single script is emitted.\n * Takes O(n^2) if m != n. 99-of-100 is ok, 5-of-100 is not.\n * `2-of-[A,B,C] => [A,B] | [A,C] | [B,C]`\n */\nexport const p2tr_ns = (m, pubkeys, allowSamePubkeys = false) => {\n    if (!allowSamePubkeys)\n        uniqPubkey(pubkeys);\n    return combinations(m, pubkeys).map((i) => ({\n        type: 'tr_ns',\n        script: OutScript.encode({ type: 'tr_ns', pubkeys: i }),\n    }));\n};\n// Taproot public key (case of p2tr_ns)\nexport const p2tr_pk = (pubkey) => p2tr_ns(1, [pubkey], undefined)[0];\nconst OutTRMS = {\n    encode(from) {\n        const last = from.length - 1;\n        if (from[last] !== 'NUMEQUAL' || from[1] !== 'CHECKSIG')\n            return;\n        const pubkeys = [];\n        const m = OpToNum(from[last - 1]);\n        if (typeof m !== 'number')\n            return;\n        for (let i = 0; i < last - 1; i++) {\n            const elm = from[i];\n            if (i & 1) {\n                if (elm !== (i === 1 ? 'CHECKSIG' : 'CHECKSIGADD'))\n                    throw new Error('OutScript.encode/tr_ms: wrong element');\n                continue;\n            }\n            if (!isBytes(elm))\n                throw new Error('OutScript.encode/tr_ms: wrong key element');\n            pubkeys.push(elm);\n        }\n        return { type: 'tr_ms', pubkeys, m };\n    },\n    decode: (to) => {\n        if (to.type !== 'tr_ms')\n            return;\n        const out = [to.pubkeys[0], 'CHECKSIG'];\n        for (let i = 1; i < to.pubkeys.length; i++)\n            out.push(to.pubkeys[i], 'CHECKSIGADD');\n        out.push(to.m, 'NUMEQUAL');\n        return out;\n    },\n};\nexport function p2tr_ms(m, pubkeys, allowSamePubkeys = false) {\n    if (!allowSamePubkeys)\n        uniqPubkey(pubkeys);\n    return {\n        type: 'tr_ms',\n        script: OutScript.encode({ type: 'tr_ms', pubkeys, m }),\n    };\n}\nconst OutUnknown = {\n    encode(from) {\n        return { type: 'unknown', script: Script.encode(from) };\n    },\n    decode: (to) => to.type === 'unknown' ? Script.decode(to.script) : undefined,\n};\n// /Payments\nconst OutScripts = [\n    OutPK,\n    OutPKH,\n    OutSH,\n    OutWSH,\n    OutWPKH,\n    OutMS,\n    OutTR,\n    OutTRNS,\n    OutTRMS,\n    OutUnknown,\n];\n// TODO: we can support user supplied output scripts now\n// - addOutScript\n// - removeOutScript\n// - We can do that as log we modify array in-place\n// - Actually is very hard, since there is sign/finalize logic\nconst _OutScript = P.apply(Script, P.coders.match(OutScripts));\n// We can validate this once, because of packed & coders\nexport const OutScript = P.validate(_OutScript, (i) => {\n    if (i.type === 'pk' && !isValidPubkey(i.pubkey, PubT.ecdsa))\n        throw new Error('OutScript/pk: wrong key');\n    if ((i.type === 'pkh' || i.type === 'sh' || i.type === 'wpkh') &&\n        (!isBytes(i.hash) || i.hash.length !== 20))\n        throw new Error(`OutScript/${i.type}: wrong hash`);\n    if (i.type === 'wsh' && (!isBytes(i.hash) || i.hash.length !== 32))\n        throw new Error(`OutScript/wsh: wrong hash`);\n    if (i.type === 'tr' && (!isBytes(i.pubkey) || !isValidPubkey(i.pubkey, PubT.schnorr)))\n        throw new Error('OutScript/tr: wrong taproot public key');\n    if (i.type === 'ms' || i.type === 'tr_ns' || i.type === 'tr_ms')\n        if (!Array.isArray(i.pubkeys))\n            throw new Error('OutScript/multisig: wrong pubkeys array');\n    if (i.type === 'ms') {\n        const n = i.pubkeys.length;\n        for (const p of i.pubkeys)\n            if (!isValidPubkey(p, PubT.ecdsa))\n                throw new Error('OutScript/multisig: wrong pubkey');\n        if (i.m <= 0 || n > 16 || i.m > n)\n            throw new Error('OutScript/multisig: invalid params');\n    }\n    if (i.type === 'tr_ns' || i.type === 'tr_ms') {\n        for (const p of i.pubkeys)\n            if (!isValidPubkey(p, PubT.schnorr))\n                throw new Error(`OutScript/${i.type}: wrong pubkey`);\n    }\n    if (i.type === 'tr_ms') {\n        const n = i.pubkeys.length;\n        if (i.m <= 0 || n > 999 || i.m > n)\n            throw new Error('OutScript/tr_ms: invalid params');\n    }\n    return i;\n});\n// Address\nfunction validateWitness(version, data) {\n    if (data.length < 2 || data.length > 40)\n        throw new Error('Witness: invalid length');\n    if (version > 16)\n        throw new Error('Witness: invalid version');\n    if (version === 0 && !(data.length === 20 || data.length === 32))\n        throw new Error('Witness: invalid length for version');\n}\nexport function programToWitness(version, data, network = NETWORK) {\n    validateWitness(version, data);\n    const coder = version === 0 ? bech32 : bech32m;\n    return coder.encode(network.bech32, [version].concat(coder.toWords(data)));\n}\nfunction formatKey(hashed, prefix) {\n    return base58check.encode(concat(Uint8Array.from(prefix), hashed));\n}\nexport function WIF(network = NETWORK) {\n    return {\n        encode(privKey) {\n            const compressed = concat(privKey, new Uint8Array([0x01]));\n            return formatKey(compressed.subarray(0, 33), [network.wif]);\n        },\n        decode(wif) {\n            let parsed = base58check.decode(wif);\n            if (parsed[0] !== network.wif)\n                throw new Error('Wrong WIF prefix');\n            parsed = parsed.subarray(1);\n            // Check what it is. Compressed flag?\n            if (parsed.length !== 33)\n                throw new Error('Wrong WIF length');\n            if (parsed[32] !== 0x01)\n                throw new Error('Wrong WIF postfix');\n            return parsed.subarray(0, -1);\n        },\n    };\n}\n// Returns OutType, which can be used to create outscript\nexport function Address(network = NETWORK) {\n    return {\n        encode(from) {\n            const { type } = from;\n            if (type === 'wpkh')\n                return programToWitness(0, from.hash, network);\n            else if (type === 'wsh')\n                return programToWitness(0, from.hash, network);\n            else if (type === 'tr')\n                return programToWitness(1, from.pubkey, network);\n            else if (type === 'pkh')\n                return formatKey(from.hash, [network.pubKeyHash]);\n            else if (type === 'sh')\n                return formatKey(from.hash, [network.scriptHash]);\n            throw new Error(`Unknown address type=${type}`);\n        },\n        decode(address) {\n            if (address.length < 14 || address.length > 74)\n                throw new Error('Invalid address length');\n            // Bech32\n            if (network.bech32 && address.toLowerCase().startsWith(network.bech32)) {\n                let res;\n                try {\n                    res = bech32.decode(address);\n                    if (res.words[0] !== 0)\n                        throw new Error(`bech32: wrong version=${res.words[0]}`);\n                }\n                catch (_) {\n                    // Starting from version 1 it is decoded as bech32m\n                    res = bech32m.decode(address);\n                    if (res.words[0] === 0)\n                        throw new Error(`bech32m: wrong version=${res.words[0]}`);\n                }\n                if (res.prefix !== network.bech32)\n                    throw new Error(`wrong bech32 prefix=${res.prefix}`);\n                const [version, ...program] = res.words;\n                const data = bech32.fromWords(program);\n                validateWitness(version, data);\n                if (version === 0 && data.length === 32)\n                    return { type: 'wsh', hash: data };\n                else if (version === 0 && data.length === 20)\n                    return { type: 'wpkh', hash: data };\n                else if (version === 1 && data.length === 32)\n                    return { type: 'tr', pubkey: data };\n                else\n                    throw new Error('Unknown witness program');\n            }\n            const data = base58check.decode(address);\n            if (data.length !== 21)\n                throw new Error('Invalid base58 address');\n            // Pay To Public Key Hash\n            if (data[0] === network.pubKeyHash) {\n                return { type: 'pkh', hash: data.slice(1) };\n            }\n            else if (data[0] === network.scriptHash) {\n                return {\n                    type: 'sh',\n                    hash: data.slice(1),\n                };\n            }\n            throw new Error(`Invalid address prefix=${data[0]}`);\n        },\n    };\n}\n// /Address\n/**\n * Internal, exported only for backwards-compat. Use `SigHash` instead.\n * @deprecated\n */\nexport var SignatureHash;\n(function (SignatureHash) {\n    SignatureHash[SignatureHash[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    SignatureHash[SignatureHash[\"ALL\"] = 1] = \"ALL\";\n    SignatureHash[SignatureHash[\"NONE\"] = 2] = \"NONE\";\n    SignatureHash[SignatureHash[\"SINGLE\"] = 3] = \"SINGLE\";\n    SignatureHash[SignatureHash[\"ANYONECANPAY\"] = 128] = \"ANYONECANPAY\";\n})(SignatureHash || (SignatureHash = {}));\nexport var SigHash;\n(function (SigHash) {\n    SigHash[SigHash[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    SigHash[SigHash[\"ALL\"] = 1] = \"ALL\";\n    SigHash[SigHash[\"NONE\"] = 2] = \"NONE\";\n    SigHash[SigHash[\"SINGLE\"] = 3] = \"SINGLE\";\n    SigHash[SigHash[\"DEFAULT_ANYONECANPAY\"] = 128] = \"DEFAULT_ANYONECANPAY\";\n    SigHash[SigHash[\"ALL_ANYONECANPAY\"] = 129] = \"ALL_ANYONECANPAY\";\n    SigHash[SigHash[\"NONE_ANYONECANPAY\"] = 130] = \"NONE_ANYONECANPAY\";\n    SigHash[SigHash[\"SINGLE_ANYONECANPAY\"] = 131] = \"SINGLE_ANYONECANPAY\";\n})(SigHash || (SigHash = {}));\nfunction validateSigHash(s) {\n    if (typeof s !== 'number' || typeof SigHash[s] !== 'string')\n        throw new Error(`Invalid SigHash=${s}`);\n    return s;\n}\nfunction unpackSighash(hashType) {\n    const masked = hashType & 0b0011111;\n    return {\n        isAny: !!(hashType & SignatureHash.ANYONECANPAY),\n        isNone: masked === SignatureHash.NONE,\n        isSingle: masked === SignatureHash.SINGLE,\n    };\n}\nexport const _sortPubkeys = (pubkeys) => Array.from(pubkeys).sort(_cmpBytes);\n// Force check index/txid/sequence\nfunction inputBeforeSign(i) {\n    if (i.txid === undefined || i.index === undefined)\n        throw new Error('Transaction/input: txid and index required');\n    return {\n        txid: i.txid,\n        index: i.index,\n        sequence: def(i.sequence, DEFAULT_SEQUENCE),\n        finalScriptSig: def(i.finalScriptSig, P.EMPTY),\n    };\n}\nfunction cleanFinalInput(i) {\n    for (const _k in i) {\n        const k = _k;\n        if (!PSBTInputFinalKeys.includes(k))\n            delete i[k];\n    }\n}\n// Force check amount/script\nfunction outputBeforeSign(i) {\n    if (i.script === undefined || i.amount === undefined)\n        throw new Error('Transaction/output: script and amount required');\n    return { script: i.script, amount: i.amount };\n}\nexport const TAP_LEAF_VERSION = 0xc0;\nexport const tapLeafHash = (script, version = TAP_LEAF_VERSION) => schnorr.utils.taggedHash('TapLeaf', new Uint8Array([version]), VarBytes.encode(script));\nfunction getTaprootKeys(privKey, pubKey, internalKey, merkleRoot = P.EMPTY) {\n    if (P.equalBytes(internalKey, pubKey)) {\n        privKey = taprootTweakPrivKey(privKey, merkleRoot);\n        pubKey = schnorr.getPublicKey(privKey);\n    }\n    return { privKey, pubKey };\n}\nconst toStr = {}.toString;\nfunction validateOpts(opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error(`Wrong object type for transaction options: ${opts}`);\n    const _opts = {\n        ...opts,\n        // Defaults\n        version: def(opts.version, DEFAULT_VERSION),\n        lockTime: def(opts.lockTime, 0),\n        PSBTVersion: def(opts.PSBTVersion, 0),\n    };\n    if (typeof _opts.allowUnknowInput !== 'undefined')\n        opts.allowUnknownInputs = _opts.allowUnknowInput;\n    if (typeof _opts.allowUnknowOutput !== 'undefined')\n        opts.allowUnknownOutputs = _opts.allowUnknowOutput;\n    // 0 and -1 happens in tests\n    if (![-1, 0, 1, 2].includes(_opts.version))\n        throw new Error(`Unknown version: ${_opts.version}`);\n    if (typeof _opts.lockTime !== 'number')\n        throw new Error('Transaction lock time should be number');\n    P.U32LE.encode(_opts.lockTime); // Additional range checks that lockTime\n    // There is no PSBT v1, and any new version will probably have fields which we don't know how to parse, which\n    // can lead to constructing broken transactions\n    if (_opts.PSBTVersion !== 0 && _opts.PSBTVersion !== 2)\n        throw new Error(`Unknown PSBT version ${_opts.PSBTVersion}`);\n    // Flags\n    for (const k of [\n        'allowUnknownOutputs',\n        'allowUnknownInputs',\n        'disableScriptCheck',\n        'bip174jsCompat',\n        'allowLegacyWitnessUtxo',\n        'lowR',\n    ]) {\n        const v = _opts[k];\n        if (v === undefined)\n            continue; // optional\n        if (typeof v !== 'boolean')\n            throw new Error(`Transation options wrong type: ${k}=${v} (${typeof v})`);\n    }\n    return Object.freeze(_opts);\n}\nexport class Transaction {\n    constructor(opts = {}) {\n        this.global = {};\n        this.inputs = []; // use getInput()\n        this.outputs = []; // use getOutput()\n        const _opts = (this.opts = validateOpts(opts));\n        // Merge with global structure of PSBTv2\n        if (_opts.lockTime !== DEFAULT_LOCKTIME)\n            this.global.fallbackLocktime = _opts.lockTime;\n        this.global.txVersion = _opts.version;\n    }\n    // Import\n    static fromRaw(raw, opts = {}) {\n        const parsed = RawTx.decode(raw);\n        const tx = new Transaction({ ...opts, version: parsed.version, lockTime: parsed.lockTime });\n        for (const o of parsed.outputs)\n            tx.addOutput(o);\n        tx.outputs = parsed.outputs;\n        tx.inputs = parsed.inputs;\n        if (parsed.witnesses) {\n            for (let i = 0; i < parsed.witnesses.length; i++)\n                tx.inputs[i].finalScriptWitness = parsed.witnesses[i];\n        }\n        return tx;\n    }\n    // PSBT\n    static fromPSBT(psbt, opts = {}) {\n        let parsed;\n        try {\n            parsed = RawPSBTV0.decode(psbt);\n        }\n        catch (e0) {\n            try {\n                parsed = RawPSBTV2.decode(psbt);\n            }\n            catch (e2) {\n                // Throw error for v0 parsing, since it popular, otherwise it would be shadowed by v2 error\n                throw e0;\n            }\n        }\n        const PSBTVersion = parsed.global.version || 0;\n        if (PSBTVersion !== 0 && PSBTVersion !== 2)\n            throw new Error(`Wrong PSBT version=${PSBTVersion}`);\n        const unsigned = parsed.global.unsignedTx;\n        const version = PSBTVersion === 0 ? unsigned?.version : parsed.global.txVersion;\n        const lockTime = PSBTVersion === 0 ? unsigned?.lockTime : parsed.global.fallbackLocktime;\n        const tx = new Transaction({ ...opts, version, lockTime, PSBTVersion });\n        // We need slice here, because otherwise\n        const inputCount = PSBTVersion === 0 ? unsigned?.inputs.length : parsed.global.inputCount;\n        tx.inputs = parsed.inputs.slice(0, inputCount).map((i, j) => ({\n            finalScriptSig: P.EMPTY,\n            ...parsed.global.unsignedTx?.inputs[j],\n            ...i,\n        }));\n        const outputCount = PSBTVersion === 0 ? unsigned?.outputs.length : parsed.global.outputCount;\n        tx.outputs = parsed.outputs.slice(0, outputCount).map((i, j) => ({\n            ...i,\n            ...parsed.global.unsignedTx?.outputs[j],\n        }));\n        tx.global = { ...parsed.global, txVersion: version }; // just in case proprietary/unknown fields\n        if (lockTime !== DEFAULT_LOCKTIME)\n            tx.global.fallbackLocktime = lockTime;\n        return tx;\n    }\n    toPSBT(PSBTVersion = this.opts.PSBTVersion) {\n        if (PSBTVersion !== 0 && PSBTVersion !== 2)\n            throw new Error(`Wrong PSBT version=${PSBTVersion}`);\n        const inputs = this.inputs.map((i) => cleanPSBTFields(PSBTVersion, PSBTInput, i));\n        for (const inp of inputs) {\n            // Don't serialize empty fields\n            if (inp.partialSig && !inp.partialSig.length)\n                delete inp.partialSig;\n            if (inp.finalScriptSig && !inp.finalScriptSig.length)\n                delete inp.finalScriptSig;\n            if (inp.finalScriptWitness && !inp.finalScriptWitness.length)\n                delete inp.finalScriptWitness;\n        }\n        const outputs = this.outputs.map((i) => cleanPSBTFields(PSBTVersion, PSBTOutput, i));\n        const global = { ...this.global };\n        if (PSBTVersion === 0) {\n            global.unsignedTx = RawTx.decode(this.unsignedTx);\n            delete global.fallbackLocktime;\n            delete global.txVersion;\n        }\n        else {\n            global.version = PSBTVersion;\n            global.txVersion = this.version;\n            global.inputCount = this.inputs.length;\n            global.outputCount = this.outputs.length;\n            if (global.fallbackLocktime && global.fallbackLocktime === DEFAULT_LOCKTIME)\n                delete global.fallbackLocktime;\n        }\n        if (this.opts.bip174jsCompat) {\n            if (!inputs.length)\n                inputs.push({});\n            if (!outputs.length)\n                outputs.push({});\n        }\n        return (PSBTVersion === 0 ? RawPSBTV0 : RawPSBTV2).encode({\n            global,\n            inputs,\n            outputs,\n        });\n    }\n    // BIP370 lockTime (https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki#determining-lock-time)\n    get lockTime() {\n        let height = DEFAULT_LOCKTIME;\n        let heightCnt = 0;\n        let time = DEFAULT_LOCKTIME;\n        let timeCnt = 0;\n        for (const i of this.inputs) {\n            if (i.requiredHeightLocktime) {\n                height = Math.max(height, i.requiredHeightLocktime);\n                heightCnt++;\n            }\n            if (i.requiredTimeLocktime) {\n                time = Math.max(time, i.requiredTimeLocktime);\n                timeCnt++;\n            }\n        }\n        if (heightCnt && heightCnt >= timeCnt)\n            return height;\n        if (time !== DEFAULT_LOCKTIME)\n            return time;\n        return this.global.fallbackLocktime || DEFAULT_LOCKTIME;\n    }\n    get version() {\n        // Should be not possible\n        if (this.global.txVersion === undefined)\n            throw new Error('No global.txVersion');\n        return this.global.txVersion;\n    }\n    inputStatus(idx) {\n        this.checkInputIdx(idx);\n        const input = this.inputs[idx];\n        // Finalized\n        if (input.finalScriptSig && input.finalScriptSig.length)\n            return 'finalized';\n        if (input.finalScriptWitness && input.finalScriptWitness.length)\n            return 'finalized';\n        // Signed taproot\n        if (input.tapKeySig)\n            return 'signed';\n        if (input.tapScriptSig && input.tapScriptSig.length)\n            return 'signed';\n        // Signed\n        if (input.partialSig && input.partialSig.length)\n            return 'signed';\n        return 'unsigned';\n    }\n    // Cannot replace unpackSighash, tests rely on very generic implemenetation with signing inputs outside of range\n    // We will lose some vectors -> smaller test coverage of preimages (very important!)\n    inputSighash(idx) {\n        this.checkInputIdx(idx);\n        const sighash = this.inputType(this.inputs[idx]).sighash;\n        // ALL or DEFAULT -- everything signed\n        // NONE           -- all inputs + no outputs\n        // SINGLE         -- all inputs + output with same index\n        // ALL + ANYONE   -- specific input + all outputs\n        // NONE + ANYONE  -- specific input + no outputs\n        // SINGLE         -- specific inputs + output with same index\n        const sigOutputs = sighash === SignatureHash.DEFAULT ? SignatureHash.ALL : sighash & 0b11;\n        const sigInputs = sighash & SignatureHash.ANYONECANPAY;\n        return { sigInputs, sigOutputs };\n    }\n    // Very nice for debug purposes, but slow. If there is too much inputs/outputs to add, will be quadratic.\n    // Some cache will be nice, but there chance to have bugs with cache invalidation\n    signStatus() {\n        // if addInput or addOutput is not possible, then all inputs or outputs are signed\n        let addInput = true, addOutput = true;\n        let inputs = [], outputs = [];\n        for (let idx = 0; idx < this.inputs.length; idx++) {\n            const status = this.inputStatus(idx);\n            // Unsigned input doesn't affect anything\n            if (status === 'unsigned')\n                continue;\n            const { sigInputs, sigOutputs } = this.inputSighash(idx);\n            // Input type\n            if (sigInputs === SignatureHash.ANYONECANPAY)\n                inputs.push(idx);\n            else\n                addInput = false;\n            // Output type\n            if (sigOutputs === SignatureHash.ALL)\n                addOutput = false;\n            else if (sigOutputs === SignatureHash.SINGLE)\n                outputs.push(idx);\n            else if (sigOutputs === SignatureHash.NONE) {\n                // Doesn't affect any outputs at all\n            }\n            else\n                throw new Error(`Wrong signature hash output type: ${sigOutputs}`);\n        }\n        return { addInput, addOutput, inputs, outputs };\n    }\n    get isFinal() {\n        for (let idx = 0; idx < this.inputs.length; idx++)\n            if (this.inputStatus(idx) !== 'finalized')\n                return false;\n        return true;\n    }\n    // Info utils\n    get hasWitnesses() {\n        let out = false;\n        for (const i of this.inputs)\n            if (i.finalScriptWitness && i.finalScriptWitness.length)\n                out = true;\n        return out;\n    }\n    // https://en.bitcoin.it/wiki/Weight_units\n    get weight() {\n        if (!this.isFinal)\n            throw new Error('Transaction is not finalized');\n        // TODO: Can we find out how much witnesses/script will be used before signing?\n        let out = 32;\n        const outputs = this.outputs.map(outputBeforeSign);\n        if (this.hasWitnesses)\n            out += 2;\n        out += 4 * CompactSizeLen.encode(this.inputs.length).length;\n        out += 4 * CompactSizeLen.encode(this.outputs.length).length;\n        for (const i of this.inputs)\n            out += 160 + 4 * VarBytes.encode(i.finalScriptSig || P.EMPTY).length;\n        for (const o of outputs)\n            out += 32 + 4 * VarBytes.encode(o.script).length;\n        if (this.hasWitnesses) {\n            for (const i of this.inputs)\n                if (i.finalScriptWitness)\n                    out += RawWitness.encode(i.finalScriptWitness).length;\n        }\n        return out;\n    }\n    get vsize() {\n        return Math.ceil(this.weight / 4);\n    }\n    toBytes(withScriptSig = false, withWitness = false) {\n        return RawTx.encode({\n            version: this.version,\n            lockTime: this.lockTime,\n            inputs: this.inputs.map(inputBeforeSign).map((i) => ({\n                ...i,\n                finalScriptSig: (withScriptSig && i.finalScriptSig) || P.EMPTY,\n            })),\n            outputs: this.outputs.map(outputBeforeSign),\n            witnesses: this.inputs.map((i) => i.finalScriptWitness || []),\n            segwitFlag: withWitness && this.hasWitnesses,\n        });\n    }\n    get unsignedTx() {\n        return this.toBytes(false, false);\n    }\n    get hex() {\n        return hex.encode(this.toBytes(true, this.hasWitnesses));\n    }\n    get hash() {\n        if (!this.isFinal)\n            throw new Error('Transaction is not finalized');\n        return hex.encode(sha256x2(this.toBytes(true)));\n    }\n    get id() {\n        if (!this.isFinal)\n            throw new Error('Transaction is not finalized');\n        return hex.encode(sha256x2(this.toBytes(true)).reverse());\n    }\n    // Input stuff\n    checkInputIdx(idx) {\n        if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.inputs.length)\n            throw new Error(`Wrong input index=${idx}`);\n    }\n    getInput(idx) {\n        this.checkInputIdx(idx);\n        return cloneDeep(this.inputs[idx]);\n    }\n    get inputsLength() {\n        return this.inputs.length;\n    }\n    // Modification\n    normalizeInput(i, cur, allowedFields) {\n        let { nonWitnessUtxo, txid } = i;\n        // String support for common fields. We usually prefer Uint8Array to avoid errors (like hex looking string accidentally passed),\n        // however in case of nonWitnessUtxo it is better to expect string, since constructing this complex object will be difficult for user\n        if (typeof nonWitnessUtxo === 'string')\n            nonWitnessUtxo = hex.decode(nonWitnessUtxo);\n        if (isBytes(nonWitnessUtxo))\n            nonWitnessUtxo = RawTx.decode(nonWitnessUtxo);\n        if (nonWitnessUtxo === undefined)\n            nonWitnessUtxo = cur?.nonWitnessUtxo;\n        if (typeof txid === 'string')\n            txid = hex.decode(txid);\n        if (txid === undefined)\n            txid = cur?.txid;\n        let res = { ...cur, ...i, nonWitnessUtxo, txid };\n        if (res.nonWitnessUtxo === undefined)\n            delete res.nonWitnessUtxo;\n        if (res.sequence === undefined)\n            res.sequence = DEFAULT_SEQUENCE;\n        if (res.tapMerkleRoot === null)\n            delete res.tapMerkleRoot;\n        res = mergeKeyMap(PSBTInput, res, cur, allowedFields);\n        PSBTInputCoder.encode(res); // Validates that everything is correct at this point\n        let prevOut;\n        if (res.nonWitnessUtxo && res.index !== undefined)\n            prevOut = res.nonWitnessUtxo.outputs[res.index];\n        else if (res.witnessUtxo)\n            prevOut = res.witnessUtxo;\n        if (prevOut && !this.opts.disableScriptCheck)\n            checkScript(prevOut && prevOut.script, res.redeemScript, res.witnessScript);\n        return res;\n    }\n    addInput(input, _ignoreSignStatus = false) {\n        if (!_ignoreSignStatus && !this.signStatus().addInput)\n            throw new Error('Tx has signed inputs, cannot add new one');\n        this.inputs.push(this.normalizeInput(input));\n        return this.inputs.length - 1;\n    }\n    updateInput(idx, input, _ignoreSignStatus = false) {\n        this.checkInputIdx(idx);\n        let allowedFields = undefined;\n        if (!_ignoreSignStatus) {\n            const status = this.signStatus();\n            if (!status.addInput || status.inputs.includes(idx))\n                allowedFields = PSBTInputUnsignedKeys;\n        }\n        this.inputs[idx] = this.normalizeInput(input, this.inputs[idx], allowedFields);\n    }\n    // Output stuff\n    checkOutputIdx(idx) {\n        if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.outputs.length)\n            throw new Error(`Wrong output index=${idx}`);\n    }\n    getOutput(idx) {\n        this.checkOutputIdx(idx);\n        return cloneDeep(this.outputs[idx]);\n    }\n    get outputsLength() {\n        return this.outputs.length;\n    }\n    normalizeOutput(o, cur, allowedFields) {\n        let { amount, script } = o;\n        if (amount === undefined)\n            amount = cur?.amount;\n        if (typeof amount !== 'bigint')\n            throw new Error('amount must be bigint sats');\n        if (typeof script === 'string')\n            script = hex.decode(script);\n        if (script === undefined)\n            script = cur?.script;\n        let res = { ...cur, ...o, amount, script };\n        if (res.amount === undefined)\n            delete res.amount;\n        res = mergeKeyMap(PSBTOutput, res, cur, allowedFields);\n        PSBTOutputCoder.encode(res);\n        if (res.script &&\n            !this.opts.allowUnknownOutputs &&\n            OutScript.decode(res.script).type === 'unknown') {\n            throw new Error('Transaction/output: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownScript=true, if you sure');\n        }\n        if (!this.opts.disableScriptCheck)\n            checkScript(res.script, res.redeemScript, res.witnessScript);\n        return res;\n    }\n    addOutput(o, _ignoreSignStatus = false) {\n        if (!_ignoreSignStatus && !this.signStatus().addOutput)\n            throw new Error('Tx has signed outputs, cannot add new one');\n        this.outputs.push(this.normalizeOutput(o));\n        return this.outputs.length - 1;\n    }\n    updateOutput(idx, output, _ignoreSignStatus = false) {\n        this.checkOutputIdx(idx);\n        let allowedFields = undefined;\n        if (!_ignoreSignStatus) {\n            const status = this.signStatus();\n            if (!status.addOutput || status.outputs.includes(idx))\n                allowedFields = PSBTOutputUnsignedKeys;\n        }\n        this.outputs[idx] = this.normalizeOutput(output, this.outputs[idx], allowedFields);\n    }\n    addOutputAddress(address, amount, network = NETWORK) {\n        return this.addOutput({ script: OutScript.encode(Address(network).decode(address)), amount });\n    }\n    // Utils\n    get fee() {\n        let res = 0n;\n        for (const i of this.inputs) {\n            const prevOut = this.prevOut(i);\n            if (!prevOut)\n                throw new Error('Empty input amount');\n            res += prevOut.amount;\n        }\n        const outputs = this.outputs.map(outputBeforeSign);\n        for (const o of outputs)\n            res -= o.amount;\n        return res;\n    }\n    // Signing\n    // Based on https://github.com/bitcoin/bitcoin/blob/5871b5b5ab57a0caf9b7514eb162c491c83281d5/test/functional/test_framework/script.py#L624\n    // There is optimization opportunity to re-use hashes for multiple inputs for witness v0/v1,\n    // but we are trying to be less complicated for audit purpose for now.\n    preimageLegacy(idx, prevOutScript, hashType) {\n        const { isAny, isNone, isSingle } = unpackSighash(hashType);\n        if (idx < 0 || !Number.isSafeInteger(idx))\n            throw new Error(`Invalid input idx=${idx}`);\n        if ((isSingle && idx >= this.outputs.length) || idx >= this.inputs.length)\n            return P.U256BE.encode(1n);\n        prevOutScript = Script.encode(Script.decode(prevOutScript).filter((i) => i !== 'CODESEPARATOR'));\n        let inputs = this.inputs\n            .map(inputBeforeSign)\n            .map((input, inputIdx) => ({\n            ...input,\n            finalScriptSig: inputIdx === idx ? prevOutScript : P.EMPTY,\n        }));\n        if (isAny)\n            inputs = [inputs[idx]];\n        else if (isNone || isSingle) {\n            inputs = inputs.map((input, inputIdx) => ({\n                ...input,\n                sequence: inputIdx === idx ? input.sequence : 0,\n            }));\n        }\n        let outputs = this.outputs.map(outputBeforeSign);\n        if (isNone)\n            outputs = [];\n        else if (isSingle) {\n            outputs = outputs.slice(0, idx).fill(EMPTY_OUTPUT).concat([outputs[idx]]);\n        }\n        const tmpTx = RawTx.encode({\n            lockTime: this.lockTime,\n            version: this.version,\n            segwitFlag: false,\n            inputs,\n            outputs,\n        });\n        return sha256x2(tmpTx, P.I32LE.encode(hashType));\n    }\n    preimageWitnessV0(idx, prevOutScript, hashType, amount) {\n        const { isAny, isNone, isSingle } = unpackSighash(hashType);\n        let inputHash = EMPTY32;\n        let sequenceHash = EMPTY32;\n        let outputHash = EMPTY32;\n        const inputs = this.inputs.map(inputBeforeSign);\n        const outputs = this.outputs.map(outputBeforeSign);\n        if (!isAny)\n            inputHash = sha256x2(...inputs.map(TxHashIdx.encode));\n        if (!isAny && !isSingle && !isNone)\n            sequenceHash = sha256x2(...inputs.map((i) => P.U32LE.encode(i.sequence)));\n        if (!isSingle && !isNone) {\n            outputHash = sha256x2(...outputs.map(RawOutput.encode));\n        }\n        else if (isSingle && idx < outputs.length)\n            outputHash = sha256x2(RawOutput.encode(outputs[idx]));\n        const input = inputs[idx];\n        return sha256x2(P.I32LE.encode(this.version), inputHash, sequenceHash, P.bytes(32, true).encode(input.txid), P.U32LE.encode(input.index), VarBytes.encode(prevOutScript), P.U64LE.encode(amount), P.U32LE.encode(input.sequence), outputHash, P.U32LE.encode(this.lockTime), P.U32LE.encode(hashType));\n    }\n    preimageWitnessV1(idx, prevOutScript, hashType, amount, codeSeparator = -1, leafScript, leafVer = 0xc0, annex) {\n        if (!Array.isArray(amount) || this.inputs.length !== amount.length)\n            throw new Error(`Invalid amounts array=${amount}`);\n        if (!Array.isArray(prevOutScript) || this.inputs.length !== prevOutScript.length)\n            throw new Error(`Invalid prevOutScript array=${prevOutScript}`);\n        const out = [\n            P.U8.encode(0),\n            P.U8.encode(hashType),\n            P.I32LE.encode(this.version),\n            P.U32LE.encode(this.lockTime),\n        ];\n        const outType = hashType === SignatureHash.DEFAULT ? SignatureHash.ALL : hashType & 0b11;\n        const inType = hashType & SignatureHash.ANYONECANPAY;\n        const inputs = this.inputs.map(inputBeforeSign);\n        const outputs = this.outputs.map(outputBeforeSign);\n        if (inType !== SignatureHash.ANYONECANPAY) {\n            out.push(...[\n                inputs.map(TxHashIdx.encode),\n                amount.map(P.U64LE.encode),\n                prevOutScript.map(VarBytes.encode),\n                inputs.map((i) => P.U32LE.encode(i.sequence)),\n            ].map((i) => sha256(concat(...i))));\n        }\n        if (outType === SignatureHash.ALL) {\n            out.push(sha256(concat(...outputs.map(RawOutput.encode))));\n        }\n        const spendType = (annex ? 1 : 0) | (leafScript ? 2 : 0);\n        out.push(new Uint8Array([spendType]));\n        if (inType === SignatureHash.ANYONECANPAY) {\n            const inp = inputs[idx];\n            out.push(TxHashIdx.encode(inp), P.U64LE.encode(amount[idx]), VarBytes.encode(prevOutScript[idx]), P.U32LE.encode(inp.sequence));\n        }\n        else\n            out.push(P.U32LE.encode(idx));\n        if (spendType & 1)\n            out.push(sha256(VarBytes.encode(annex || P.EMPTY)));\n        if (outType === SignatureHash.SINGLE)\n            out.push(idx < outputs.length ? sha256(RawOutput.encode(outputs[idx])) : EMPTY32);\n        if (leafScript)\n            out.push(tapLeafHash(leafScript, leafVer), P.U8.encode(0), P.I32LE.encode(codeSeparator));\n        return schnorr.utils.taggedHash('TapSighash', ...out);\n    }\n    // Utils for sign/finalize\n    // Used pretty often, should be fast\n    prevOut(input) {\n        if (input.nonWitnessUtxo) {\n            if (input.index === undefined)\n                throw new Error('Unknown input index');\n            return input.nonWitnessUtxo.outputs[input.index];\n        }\n        else if (input.witnessUtxo)\n            return input.witnessUtxo;\n        else\n            throw new Error('Cannot find previous output info');\n    }\n    inputType(input) {\n        let txType = 'legacy';\n        let defaultSighash = SignatureHash.ALL;\n        const prevOut = this.prevOut(input);\n        const first = OutScript.decode(prevOut.script);\n        let type = first.type;\n        let cur = first;\n        const stack = [first];\n        if (first.type === 'tr') {\n            defaultSighash = SignatureHash.DEFAULT;\n            return {\n                txType: 'taproot',\n                type: 'tr',\n                last: first,\n                lastScript: prevOut.script,\n                defaultSighash,\n                sighash: input.sighashType || defaultSighash,\n            };\n        }\n        else {\n            if (first.type === 'wpkh' || first.type === 'wsh')\n                txType = 'segwit';\n            if (first.type === 'sh') {\n                if (!input.redeemScript)\n                    throw new Error('inputType: sh without redeemScript');\n                let child = OutScript.decode(input.redeemScript);\n                if (child.type === 'wpkh' || child.type === 'wsh')\n                    txType = 'segwit';\n                stack.push(child);\n                cur = child;\n                type += `-${child.type}`;\n            }\n            // wsh can be inside sh\n            if (cur.type === 'wsh') {\n                if (!input.witnessScript)\n                    throw new Error('inputType: wsh without witnessScript');\n                let child = OutScript.decode(input.witnessScript);\n                if (child.type === 'wsh')\n                    txType = 'segwit';\n                stack.push(child);\n                cur = child;\n                type += `-${child.type}`;\n            }\n            const last = stack[stack.length - 1];\n            if (last.type === 'sh' || last.type === 'wsh')\n                throw new Error('inputType: sh/wsh cannot be terminal type');\n            const lastScript = OutScript.encode(last);\n            const res = {\n                type,\n                txType,\n                last,\n                lastScript,\n                defaultSighash,\n                sighash: input.sighashType || defaultSighash,\n            };\n            if (txType === 'legacy' && !this.opts.allowLegacyWitnessUtxo && !input.nonWitnessUtxo) {\n                throw new Error(`Transaction/sign: legacy input without nonWitnessUtxo, can result in attack that forces paying higher fees. Pass allowLegacyWitnessUtxo=true, if you sure`);\n            }\n            return res;\n        }\n    }\n    // Signer can be privateKey OR instance of bip32 HD stuff\n    signIdx(privateKey, idx, allowedSighash, _auxRand) {\n        this.checkInputIdx(idx);\n        const input = this.inputs[idx];\n        const inputType = this.inputType(input);\n        // Handle BIP32 HDKey\n        if (!isBytes(privateKey)) {\n            if (!input.bip32Derivation || !input.bip32Derivation.length)\n                throw new Error('bip32Derivation: empty');\n            const signers = input.bip32Derivation\n                .filter((i) => i[1].fingerprint == privateKey.fingerprint)\n                .map(([pubKey, { path }]) => {\n                let s = privateKey;\n                for (const i of path)\n                    s = s.deriveChild(i);\n                if (!P.equalBytes(s.publicKey, pubKey))\n                    throw new Error('bip32Derivation: wrong pubKey');\n                if (!s.privateKey)\n                    throw new Error('bip32Derivation: no privateKey');\n                return s;\n            });\n            if (!signers.length)\n                throw new Error(`bip32Derivation: no items with fingerprint=${privateKey.fingerprint}`);\n            let signed = false;\n            for (const s of signers)\n                if (this.signIdx(s.privateKey, idx))\n                    signed = true;\n            return signed;\n        }\n        // Sighash checks\n        // Just for compat with bitcoinjs-lib, so users won't face unexpected behaviour.\n        if (!allowedSighash)\n            allowedSighash = [inputType.defaultSighash];\n        else\n            allowedSighash.forEach(validateSigHash);\n        const sighash = inputType.sighash;\n        if (!allowedSighash.includes(sighash)) {\n            throw new Error(`Input with not allowed sigHash=${sighash}. Allowed: ${allowedSighash.join(', ')}`);\n        }\n        // It is possible to sign these inputs for legacy/segwit v0 (but no taproot!),\n        // however this was because of bug in bitcoin-core, which remains here because of consensus.\n        // If this is absolutely neccessary for your case, please open issue.\n        // We disable it to avoid complicated workflow where SINGLE will block adding new outputs\n        const { sigOutputs } = this.inputSighash(idx);\n        if (sigOutputs === SignatureHash.SINGLE && idx >= this.outputs.length) {\n            throw new Error(`Input with sighash SINGLE, but there is no output with corresponding index=${idx}`);\n        }\n        // Actual signing\n        // Taproot\n        const prevOut = this.prevOut(input);\n        if (inputType.txType === 'taproot') {\n            if (input.tapBip32Derivation)\n                throw new Error('tapBip32Derivation unsupported');\n            const prevOuts = this.inputs.map(this.prevOut);\n            const prevOutScript = prevOuts.map((i) => i.script);\n            const amount = prevOuts.map((i) => i.amount);\n            let signed = false;\n            let schnorrPub = schnorr.getPublicKey(privateKey);\n            let merkleRoot = input.tapMerkleRoot || P.EMPTY;\n            if (input.tapInternalKey) {\n                // internal + tweak = tweaked key\n                // if internal key == current public key, we need to tweak private key,\n                // otherwise sign as is. bitcoinjs implementation always wants tweaked\n                // priv key to be provided\n                const { pubKey, privKey } = getTaprootKeys(privateKey, schnorrPub, input.tapInternalKey, merkleRoot);\n                const [taprootPubKey, _] = taprootTweakPubkey(input.tapInternalKey, merkleRoot);\n                if (P.equalBytes(taprootPubKey, pubKey)) {\n                    const hash = this.preimageWitnessV1(idx, prevOutScript, sighash, amount);\n                    const sig = concat(schnorr.sign(hash, privKey, _auxRand), sighash !== SignatureHash.DEFAULT ? new Uint8Array([sighash]) : P.EMPTY);\n                    this.updateInput(idx, { tapKeySig: sig }, true);\n                    signed = true;\n                }\n            }\n            if (input.tapLeafScript) {\n                input.tapScriptSig = input.tapScriptSig || [];\n                for (const [_, _script] of input.tapLeafScript) {\n                    const script = _script.subarray(0, -1);\n                    const scriptDecoded = Script.decode(script);\n                    const ver = _script[_script.length - 1];\n                    const hash = tapLeafHash(script, ver);\n                    // NOTE: no need to tweak internal key here, since we don't support nested p2tr\n                    const pos = scriptDecoded.findIndex((i) => isBytes(i) && P.equalBytes(i, schnorrPub));\n                    // Skip if there is no public key in tapLeafScript\n                    if (pos === -1)\n                        continue;\n                    const msg = this.preimageWitnessV1(idx, prevOutScript, sighash, amount, undefined, script, ver);\n                    const sig = concat(schnorr.sign(msg, privateKey, _auxRand), sighash !== SignatureHash.DEFAULT ? new Uint8Array([sighash]) : P.EMPTY);\n                    this.updateInput(idx, { tapScriptSig: [[{ pubKey: schnorrPub, leafHash: hash }, sig]] }, true);\n                    signed = true;\n                }\n            }\n            if (!signed)\n                throw new Error('No taproot scripts signed');\n            return true;\n        }\n        else {\n            // only compressed keys are supported for now\n            const pubKey = _pubECDSA(privateKey);\n            // TODO: replace with explicit checks\n            // Check if script has public key or its has inside\n            let hasPubkey = false;\n            const pubKeyHash = hash160(pubKey);\n            for (const i of Script.decode(inputType.lastScript)) {\n                if (isBytes(i) && (P.equalBytes(i, pubKey) || P.equalBytes(i, pubKeyHash)))\n                    hasPubkey = true;\n            }\n            if (!hasPubkey)\n                throw new Error(`Input script doesn't have pubKey: ${inputType.lastScript}`);\n            let hash;\n            if (inputType.txType === 'legacy') {\n                hash = this.preimageLegacy(idx, inputType.lastScript, sighash);\n            }\n            else if (inputType.txType === 'segwit') {\n                let script = inputType.lastScript;\n                // If wpkh OR sh-wpkh, wsh-wpkh is impossible, so looks ok\n                if (inputType.last.type === 'wpkh')\n                    script = OutScript.encode({ type: 'pkh', hash: inputType.last.hash });\n                hash = this.preimageWitnessV0(idx, script, sighash, prevOut.amount);\n            }\n            else\n                throw new Error(`Transaction/sign: unknown tx type: ${inputType.txType}`);\n            const sig = signECDSA(hash, privateKey, this.opts.lowR);\n            this.updateInput(idx, {\n                partialSig: [[pubKey, concat(sig, new Uint8Array([sighash]))]],\n            }, true);\n        }\n        return true;\n    }\n    // This is bad API. Will work if user creates and signs tx, but if\n    // there is some complex workflow with exchanging PSBT and signing them,\n    // then it is better to validate which output user signs. How could a better API look like?\n    // Example: user adds input, sends to another party, then signs received input (mixer etc),\n    // another user can add different input for same key and user will sign it.\n    // Even worse: another user can add bip32 derivation, and spend money from different address.\n    // Better api: signIdx\n    sign(privateKey, allowedSighash, _auxRand) {\n        let num = 0;\n        for (let i = 0; i < this.inputs.length; i++) {\n            try {\n                if (this.signIdx(privateKey, i, allowedSighash, _auxRand))\n                    num++;\n            }\n            catch (e) { }\n        }\n        if (!num)\n            throw new Error('No inputs signed');\n        return num;\n    }\n    finalizeIdx(idx) {\n        this.checkInputIdx(idx);\n        if (this.fee < 0n)\n            throw new Error('Outputs spends more than inputs amount');\n        const input = this.inputs[idx];\n        const inputType = this.inputType(input);\n        // Taproot finalize\n        if (inputType.txType === 'taproot') {\n            if (input.tapKeySig)\n                input.finalScriptWitness = [input.tapKeySig];\n            else if (input.tapLeafScript && input.tapScriptSig) {\n                // Sort leafs by control block length.\n                const leafs = input.tapLeafScript.sort((a, b) => TaprootControlBlock.encode(a[0]).length - TaprootControlBlock.encode(b[0]).length);\n                for (const [cb, _script] of leafs) {\n                    // Last byte is version\n                    const script = _script.slice(0, -1);\n                    const ver = _script[_script.length - 1];\n                    const outScript = OutScript.decode(script);\n                    const hash = tapLeafHash(script, ver);\n                    const scriptSig = input.tapScriptSig.filter((i) => P.equalBytes(i[0].leafHash, hash));\n                    let signatures = [];\n                    if (outScript.type === 'tr_ms') {\n                        const m = outScript.m;\n                        const pubkeys = outScript.pubkeys;\n                        let added = 0;\n                        for (const pub of pubkeys) {\n                            const sigIdx = scriptSig.findIndex((i) => P.equalBytes(i[0].pubKey, pub));\n                            // Should have exact amount of signatures (more -- will fail)\n                            if (added === m || sigIdx === -1) {\n                                signatures.push(P.EMPTY);\n                                continue;\n                            }\n                            signatures.push(scriptSig[sigIdx][1]);\n                            added++;\n                        }\n                        // Should be exact same as m\n                        if (added !== m)\n                            continue;\n                    }\n                    else if (outScript.type === 'tr_ns') {\n                        for (const pub of outScript.pubkeys) {\n                            const sigIdx = scriptSig.findIndex((i) => P.equalBytes(i[0].pubKey, pub));\n                            if (sigIdx === -1)\n                                continue;\n                            signatures.push(scriptSig[sigIdx][1]);\n                        }\n                        if (signatures.length !== outScript.pubkeys.length)\n                            continue;\n                    }\n                    else if (outScript.type === 'unknown' && this.opts.allowUnknownInputs) {\n                        // Trying our best to sign what we can\n                        const scriptDecoded = Script.decode(script);\n                        signatures = scriptSig\n                            .map(([{ pubKey }, signature]) => {\n                            const pos = scriptDecoded.findIndex((i) => isBytes(i) && P.equalBytes(i, pubKey));\n                            if (pos === -1)\n                                throw new Error('finalize/taproot: cannot find position of pubkey in script');\n                            return { signature, pos };\n                        })\n                            // Reverse order (because witness is stack and we take last element first from it)\n                            .sort((a, b) => a.pos - b.pos)\n                            .map((i) => i.signature);\n                        if (!signatures.length)\n                            continue;\n                    }\n                    else\n                        throw new Error('Finalize: Unknown tapLeafScript');\n                    // Witness is stack, so last element will be used first\n                    input.finalScriptWitness = signatures\n                        .reverse()\n                        .concat([script, TaprootControlBlock.encode(cb)]);\n                    break;\n                }\n                if (!input.finalScriptWitness)\n                    throw new Error('finalize/taproot: empty witness');\n            }\n            else\n                throw new Error('finalize/taproot: unknown input');\n            input.finalScriptSig = P.EMPTY;\n            cleanFinalInput(input);\n            return;\n        }\n        if (!input.partialSig || !input.partialSig.length)\n            throw new Error('Not enough partial sign');\n        let inputScript = P.EMPTY;\n        let witness = [];\n        // TODO: move input scripts closer to payments/output scripts\n        // Multisig\n        if (inputType.last.type === 'ms') {\n            const m = inputType.last.m;\n            const pubkeys = inputType.last.pubkeys;\n            let signatures = [];\n            // partial: [pubkey, sign]\n            for (const pub of pubkeys) {\n                const sign = input.partialSig.find((s) => P.equalBytes(pub, s[0]));\n                if (!sign)\n                    continue;\n                signatures.push(sign[1]);\n            }\n            signatures = signatures.slice(0, m);\n            if (signatures.length !== m) {\n                throw new Error(`Multisig: wrong signatures count, m=${m} n=${pubkeys.length} signatures=${signatures.length}`);\n            }\n            inputScript = Script.encode([0, ...signatures]);\n        }\n        else if (inputType.last.type === 'pk') {\n            inputScript = Script.encode([input.partialSig[0][1]]);\n        }\n        else if (inputType.last.type === 'pkh') {\n            inputScript = Script.encode([input.partialSig[0][1], input.partialSig[0][0]]);\n        }\n        else if (inputType.last.type === 'wpkh') {\n            inputScript = P.EMPTY;\n            witness = [input.partialSig[0][1], input.partialSig[0][0]];\n        }\n        else if (inputType.last.type === 'unknown' && !this.opts.allowUnknownInputs)\n            throw new Error('Unknown inputs not allowed');\n        // Create final scripts (generic part)\n        let finalScriptSig, finalScriptWitness;\n        if (inputType.type.includes('wsh-')) {\n            // P2WSH\n            if (inputScript.length && inputType.lastScript.length) {\n                witness = Script.decode(inputScript).map((i) => {\n                    if (i === 0)\n                        return P.EMPTY;\n                    if (isBytes(i))\n                        return i;\n                    throw new Error(`Wrong witness op=${i}`);\n                });\n            }\n            witness = witness.concat(inputType.lastScript);\n        }\n        if (inputType.txType === 'segwit')\n            finalScriptWitness = witness;\n        if (inputType.type.startsWith('sh-wsh-')) {\n            finalScriptSig = Script.encode([Script.encode([0, sha256(inputType.lastScript)])]);\n        }\n        else if (inputType.type.startsWith('sh-')) {\n            finalScriptSig = Script.encode([...Script.decode(inputScript), inputType.lastScript]);\n        }\n        else if (inputType.type.startsWith('wsh-')) {\n        }\n        else if (inputType.txType !== 'segwit')\n            finalScriptSig = inputScript;\n        if (!finalScriptSig && !finalScriptWitness)\n            throw new Error('Unknown error finalizing input');\n        if (finalScriptSig)\n            input.finalScriptSig = finalScriptSig;\n        if (finalScriptWitness)\n            input.finalScriptWitness = finalScriptWitness;\n        cleanFinalInput(input);\n    }\n    finalize() {\n        for (let i = 0; i < this.inputs.length; i++)\n            this.finalizeIdx(i);\n    }\n    extract() {\n        if (!this.isFinal)\n            throw new Error('Transaction has unfinalized inputs');\n        if (!this.outputs.length)\n            throw new Error('Transaction has no outputs');\n        if (this.fee < 0n)\n            throw new Error('Outputs spends more than inputs amount');\n        return this.toBytes(true, true);\n    }\n    combine(other) {\n        for (const k of ['PSBTVersion', 'version', 'lockTime']) {\n            if (this.opts[k] !== other.opts[k]) {\n                throw new Error(`Transaction/combine: different ${k} this=${this.opts[k]} other=${other.opts[k]}`);\n            }\n        }\n        for (const k of ['inputs', 'outputs']) {\n            if (this[k].length !== other[k].length) {\n                throw new Error(`Transaction/combine: different ${k} length this=${this[k].length} other=${other[k].length}`);\n            }\n        }\n        const thisUnsigned = this.global.unsignedTx ? RawTx.encode(this.global.unsignedTx) : P.EMPTY;\n        const otherUnsigned = other.global.unsignedTx ? RawTx.encode(other.global.unsignedTx) : P.EMPTY;\n        if (!P.equalBytes(thisUnsigned, otherUnsigned))\n            throw new Error(`Transaction/combine: different unsigned tx`);\n        this.global = mergeKeyMap(PSBTGlobal, this.global, other.global);\n        for (let i = 0; i < this.inputs.length; i++)\n            this.updateInput(i, other.inputs[i], true);\n        for (let i = 0; i < this.outputs.length; i++)\n            this.updateOutput(i, other.outputs[i], true);\n        return this;\n    }\n    clone() {\n        // deepClone probably faster, but this enforces that encoding is valid\n        return Transaction.fromPSBT(this.toPSBT(2), this.opts);\n    }\n}\n// User facing API?\n// Simple pubkey address, without complex scripts\nexport function getAddress(type, privKey, network = NETWORK) {\n    if (type === 'tr') {\n        return p2tr(schnorr.getPublicKey(privKey), undefined, network).address;\n    }\n    const pubKey = _pubECDSA(privKey);\n    if (type === 'pkh')\n        return p2pkh(pubKey, network).address;\n    if (type === 'wpkh')\n        return p2wpkh(pubKey, network).address;\n    throw new Error(`getAddress: unknown type=${type}`);\n}\nexport function multisig(m, pubkeys, sorted = false, witness = false) {\n    const ms = p2ms(m, sorted ? _sortPubkeys(pubkeys) : pubkeys);\n    return witness ? p2wsh(ms) : p2sh(ms);\n}\nexport function sortedMultisig(m, pubkeys, witness = false) {\n    return multisig(m, pubkeys, true, witness);\n}\n// Copy-pasted from bip32 derive, maybe do something like 'bip32.parsePath'?\nconst HARDENED_OFFSET = 0x80000000;\nexport function bip32Path(path) {\n    const out = [];\n    if (!/^[mM]'?/.test(path))\n        throw new Error('Path must start with \"m\" or \"M\"');\n    if (/^[mM]'?$/.test(path))\n        return out;\n    const parts = path.replace(/^[mM]'?\\//, '').split('/');\n    for (const c of parts) {\n        const m = /^(\\d+)('?)$/.exec(c);\n        if (!m || m.length !== 3)\n            throw new Error(`Invalid child index: ${c}`);\n        let idx = +m[1];\n        if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET)\n            throw new Error('Invalid index');\n        // hardened key\n        if (m[2] === \"'\")\n            idx += HARDENED_OFFSET;\n        out.push(idx);\n    }\n    return out;\n}\nexport function PSBTCombine(psbts) {\n    if (!psbts || !Array.isArray(psbts) || !psbts.length)\n        throw new Error('PSBTCombine: wrong PSBT list');\n    const tx = Transaction.fromPSBT(psbts[0]);\n    for (let i = 1; i < psbts.length; i++)\n        tx.combine(Transaction.fromPSBT(psbts[i]));\n    return tx.toPSBT();\n}\n//# sourceMappingURL=index.js.map","import { Logger } from './logger';\nexport const BLOCKSTACK_HANDLER = 'blockstack';\nexport function nextYear() {\n    return new Date(new Date().setFullYear(new Date().getFullYear() + 1));\n}\nexport function nextMonth() {\n    return new Date(new Date().setMonth(new Date().getMonth() + 1));\n}\nexport function nextHour() {\n    return new Date(new Date().setHours(new Date().getHours() + 1));\n}\nexport function megabytesToBytes(megabytes) {\n    if (!Number.isFinite(megabytes)) {\n        return 0;\n    }\n    return Math.floor(megabytes * 1024 * 1024);\n}\nexport function getAesCbcOutputLength(inputByteLength) {\n    const cipherTextLength = (Math.floor(inputByteLength / 16) + 1) * 16;\n    return cipherTextLength;\n}\nexport function getBase64OutputLength(inputByteLength) {\n    const encodedLength = Math.ceil(inputByteLength / 3) * 4;\n    return encodedLength;\n}\nexport function updateQueryStringParameter(uri, key, value) {\n    const re = new RegExp(`([?&])${key}=.*?(&|$)`, 'i');\n    const separator = uri.indexOf('?') !== -1 ? '&' : '?';\n    if (uri.match(re)) {\n        return uri.replace(re, `$1${key}=${value}$2`);\n    }\n    else {\n        return `${uri}${separator}${key}=${value}`;\n    }\n}\nexport function isLaterVersion(v1, v2) {\n    if (v1 === undefined || v1 === '') {\n        v1 = '0.0.0';\n    }\n    if (v2 === undefined || v1 === '') {\n        v2 = '0.0.0';\n    }\n    const v1tuple = v1.split('.').map(x => parseInt(x, 10));\n    const v2tuple = v2.split('.').map(x => parseInt(x, 10));\n    for (let index = 0; index < v2.length; index++) {\n        if (index >= v1.length) {\n            v2tuple.push(0);\n        }\n        if (v1tuple[index] < v2tuple[index]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function makeUUID4() {\n    let d = new Date().getTime();\n    if (typeof performance !== 'undefined' && typeof performance.now === 'function') {\n        d += performance.now();\n    }\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n        const r = (d + Math.random() * 16) % 16 | 0;\n        d = Math.floor(d / 16);\n        return (c === 'x' ? r : (r & 0x3) | 0x8).toString(16);\n    });\n}\nexport function isSameOriginAbsoluteUrl(uri1, uri2) {\n    try {\n        const parsedUri1 = new URL(uri1);\n        const parsedUri2 = new URL(uri2);\n        const port1 = parseInt(parsedUri1.port || '0', 10) | 0 || (parsedUri1.protocol === 'https:' ? 443 : 80);\n        const port2 = parseInt(parsedUri2.port || '0', 10) | 0 || (parsedUri2.protocol === 'https:' ? 443 : 80);\n        const match = {\n            scheme: parsedUri1.protocol === parsedUri2.protocol,\n            hostname: parsedUri1.hostname === parsedUri2.hostname,\n            port: port1 === port2,\n            absolute: (uri1.includes('http://') || uri1.includes('https://')) &&\n                (uri2.includes('http://') || uri2.includes('https://')),\n        };\n        return match.scheme && match.hostname && match.port && match.absolute;\n    }\n    catch (error) {\n        console.log(error);\n        console.log('Parsing error in same URL origin check');\n        return false;\n    }\n}\nexport function getGlobalScope() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('Unexpected runtime environment - no supported global scope (`window`, `self`, `global`) available');\n}\nfunction getAPIUsageErrorMessage(scopeObject, apiName, usageDesc) {\n    if (usageDesc) {\n        return `Use of '${usageDesc}' requires \\`${apiName}\\` which is unavailable on the '${scopeObject}' object within the currently executing environment.`;\n    }\n    else {\n        return `\\`${apiName}\\` is unavailable on the '${scopeObject}' object within the currently executing environment.`;\n    }\n}\nexport function getGlobalObject(name, { throwIfUnavailable, usageDesc, returnEmptyObject } = {}) {\n    let globalScope = undefined;\n    try {\n        globalScope = getGlobalScope();\n        if (globalScope) {\n            const obj = globalScope[name];\n            if (obj) {\n                return obj;\n            }\n        }\n    }\n    catch (error) {\n        Logger.error(`Error getting object '${name}' from global scope '${globalScope}': ${error}`);\n    }\n    if (throwIfUnavailable) {\n        const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n        Logger.error(errMsg);\n        throw new Error(errMsg);\n    }\n    if (returnEmptyObject) {\n        return {};\n    }\n    return undefined;\n}\nexport function getGlobalObjects(names, { throwIfUnavailable, usageDesc, returnEmptyObject } = {}) {\n    let globalScope;\n    try {\n        globalScope = getGlobalScope();\n    }\n    catch (error) {\n        Logger.error(`Error getting global scope: ${error}`);\n        if (throwIfUnavailable) {\n            const errMsg = getAPIUsageErrorMessage(globalScope, names[0].toString(), usageDesc);\n            Logger.error(errMsg);\n            throw errMsg;\n        }\n        else if (returnEmptyObject) {\n            globalScope = {};\n        }\n    }\n    const result = {};\n    for (let i = 0; i < names.length; i++) {\n        const name = names[i];\n        try {\n            if (globalScope) {\n                const obj = globalScope[name];\n                if (obj) {\n                    result[name] = obj;\n                }\n                else if (throwIfUnavailable) {\n                    const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n                    Logger.error(errMsg);\n                    throw new Error(errMsg);\n                }\n                else if (returnEmptyObject) {\n                    result[name] = {};\n                }\n            }\n        }\n        catch (error) {\n            if (throwIfUnavailable) {\n                const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n                Logger.error(errMsg);\n                throw new Error(errMsg);\n            }\n        }\n    }\n    return result;\n}\nexport function intToBytes(value, signed, byteLength) {\n    return bigIntToBytes(intToBigInt(value, signed), byteLength);\n}\nexport function intToBigInt(value, signed) {\n    let parsedValue = value;\n    if (typeof parsedValue === 'number') {\n        if (!Number.isInteger(parsedValue)) {\n            throw new RangeError(`Invalid value. Values of type 'number' must be an integer.`);\n        }\n        if (parsedValue > Number.MAX_SAFE_INTEGER) {\n            throw new RangeError(`Invalid value. Values of type 'number' must be less than or equal to ${Number.MAX_SAFE_INTEGER}. For larger values, try using a BigInt instead.`);\n        }\n        return BigInt(parsedValue);\n    }\n    if (typeof parsedValue === 'string') {\n        if (parsedValue.toLowerCase().startsWith('0x')) {\n            let hex = parsedValue.slice(2);\n            hex = hex.padStart(hex.length + (hex.length % 2), '0');\n            parsedValue = hexToBytes(hex);\n        }\n        else {\n            try {\n                return BigInt(parsedValue);\n            }\n            catch (error) {\n                if (error instanceof SyntaxError) {\n                    throw new RangeError(`Invalid value. String integer '${parsedValue}' is not finite.`);\n                }\n            }\n        }\n    }\n    if (typeof parsedValue === 'bigint') {\n        return parsedValue;\n    }\n    if (parsedValue instanceof Uint8Array) {\n        if (signed) {\n            const bn = fromTwos(BigInt(`0x${bytesToHex(parsedValue)}`), BigInt(parsedValue.byteLength * 8));\n            return BigInt(bn.toString());\n        }\n        else {\n            return BigInt(`0x${bytesToHex(parsedValue)}`);\n        }\n    }\n    if (parsedValue != null &&\n        typeof parsedValue === 'object' &&\n        parsedValue.constructor.name === 'BN') {\n        return BigInt(parsedValue.toString());\n    }\n    throw new TypeError(`Invalid value type. Must be a number, bigint, integer-string, hex-string, or Uint8Array.`);\n}\nexport function with0x(value) {\n    return value.startsWith('0x') ? value : `0x${value}`;\n}\nexport function hexToBigInt(hex) {\n    if (typeof hex !== 'string')\n        throw new TypeError(`hexToBigInt: expected string, got ${typeof hex}`);\n    return BigInt(`0x${hex}`);\n}\nexport function intToHex(integer, lengthBytes = 8) {\n    const value = typeof integer === 'bigint' ? integer : intToBigInt(integer, false);\n    return value.toString(16).padStart(lengthBytes * 2, '0');\n}\nexport function hexToInt(hex) {\n    return parseInt(hex, 16);\n}\nexport function bigIntToBytes(value, length = 16) {\n    const hex = intToHex(value, length);\n    return hexToBytes(hex);\n}\nexport function toTwos(value, width) {\n    if (value < -(BigInt(1) << (width - BigInt(1))) ||\n        (BigInt(1) << (width - BigInt(1))) - BigInt(1) < value) {\n        throw `Unable to represent integer in width: ${width}`;\n    }\n    if (value >= BigInt(0)) {\n        return BigInt(value);\n    }\n    return value + (BigInt(1) << width);\n}\nfunction nthBit(value, n) {\n    return value & (BigInt(1) << n);\n}\nexport function fromTwos(value, width) {\n    if (nthBit(value, width - BigInt(1))) {\n        return value - (BigInt(1) << width);\n    }\n    return value;\n}\nconst hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\nexport function bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n    let hex = '';\n    for (const u of uint8a) {\n        hex += hexes[u];\n    }\n    return hex;\n}\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError(`hexToBytes: expected string, got ${typeof hex}`);\n    }\n    const paddedHex = hex.length % 2 ? `0${hex}` : hex;\n    const array = new Uint8Array(paddedHex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = paddedHex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nexport function utf8ToBytes(str) {\n    return new TextEncoder().encode(str);\n}\nexport function bytesToUtf8(arr) {\n    return new TextDecoder().decode(arr);\n}\nexport function asciiToBytes(str) {\n    const byteArray = [];\n    for (let i = 0; i < str.length; i++) {\n        byteArray.push(str.charCodeAt(i) & 0xff);\n    }\n    return new Uint8Array(byteArray);\n}\nexport function bytesToAscii(arr) {\n    return String.fromCharCode.apply(null, arr);\n}\nfunction isNotOctet(octet) {\n    return !Number.isInteger(octet) || octet < 0 || octet > 255;\n}\nexport function octetsToBytes(numbers) {\n    if (numbers.some(isNotOctet))\n        throw new Error('Some values are invalid bytes.');\n    return new Uint8Array(numbers);\n}\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        return utf8ToBytes(data);\n    if (data instanceof Uint8Array)\n        return data;\n    throw new TypeError(`Expected input type is (Uint8Array | string) but got (${typeof data})`);\n}\nexport function concatBytes(...arrays) {\n    if (!arrays.every(a => a instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nexport function concatArray(elements) {\n    return concatBytes(...elements.map(e => {\n        if (typeof e === 'number')\n            return octetsToBytes([e]);\n        if (e instanceof Array)\n            return octetsToBytes(e);\n        return e;\n    }));\n}\nexport function isInstance(object, type) {\n    return object instanceof type || object?.constructor?.name?.toLowerCase() === type.name;\n}\n//# sourceMappingURL=utils.js.map","export function equals(a, b) {\n    if (a.byteLength !== b.byteLength)\n        return false;\n    for (let i = 0; i < a.byteLength; i++) {\n        if (a[i] !== b[i])\n            return false;\n    }\n    return true;\n}\nexport function alloc(length, value) {\n    const a = new Uint8Array(length);\n    for (let i = 0; i < length; i++) {\n        a[i] = value;\n    }\n    return a;\n}\nexport function readUInt16BE(source, offset) {\n    return ((source[offset + 0] << 8) | source[offset + 1]) >>> 0;\n}\nexport function writeUInt16BE(source, value, offset) {\n    source[offset + 0] = value >>> 8;\n    source[offset + 1] = value >>> 0;\n}\nexport function readUInt8(source, offset) {\n    return source[offset];\n}\nexport function writeUInt8(destination, value, offset) {\n    destination[offset] = value;\n}\nexport function readUInt16LE(source, offset) {\n    return ((source[offset + 0] << 0) >>> 0) | ((source[offset + 1] << 8) >>> 0);\n}\nexport function writeUInt16LE(destination, value, offset) {\n    destination[offset + 0] = value & 255;\n    value >>>= 8;\n    destination[offset + 1] = value & 255;\n}\nexport function readUInt32BE(source, offset) {\n    return (source[offset] * 2 ** 24 +\n        source[offset + 1] * 2 ** 16 +\n        source[offset + 2] * 2 ** 8 +\n        source[offset + 3]);\n}\nexport function writeUInt32BE(destination, value, offset) {\n    destination[offset + 3] = value;\n    value >>>= 8;\n    destination[offset + 2] = value;\n    value >>>= 8;\n    destination[offset + 1] = value;\n    value >>>= 8;\n    destination[offset] = value;\n}\nexport function readUInt32LE(source, offset) {\n    return (((source[offset + 0] << 0) >>> 0) |\n        ((source[offset + 1] << 8) >>> 0) |\n        ((source[offset + 2] << 16) >>> 0) |\n        ((source[offset + 3] << 24) >>> 0));\n}\nexport function writeUInt32LE(destination, value, offset) {\n    destination[offset + 0] = value & 255;\n    value >>>= 8;\n    destination[offset + 1] = value & 255;\n    value >>>= 8;\n    destination[offset + 2] = value & 255;\n    value >>>= 8;\n    destination[offset + 3] = value & 255;\n}\n//# sourceMappingURL=buffer.js.map","var ChainID;\n(function (ChainID) {\n    ChainID[ChainID[\"Testnet\"] = 2147483648] = \"Testnet\";\n    ChainID[ChainID[\"Mainnet\"] = 1] = \"Mainnet\";\n})(ChainID || (ChainID = {}));\nconst DEFAULT_CHAIN_ID = ChainID.Mainnet;\nconst MAX_STRING_LENGTH_BYTES = 128;\nconst CLARITY_INT_SIZE = 128;\nconst CLARITY_INT_BYTE_SIZE = 16;\nconst COINBASE_LENGTH_BYTES = 32;\nconst RECOVERABLE_ECDSA_SIG_LENGTH_BYTES = 65;\nconst COMPRESSED_PUBKEY_LENGTH_BYTES = 32;\nconst UNCOMPRESSED_PUBKEY_LENGTH_BYTES = 64;\nconst MEMO_MAX_LENGTH_BYTES = 34;\nconst DEFAULT_CORE_NODE_API_URL = 'https://stacks-node-api.mainnet.stacks.co';\nvar StacksMessageType;\n(function (StacksMessageType) {\n    StacksMessageType[StacksMessageType[\"Address\"] = 0] = \"Address\";\n    StacksMessageType[StacksMessageType[\"Principal\"] = 1] = \"Principal\";\n    StacksMessageType[StacksMessageType[\"LengthPrefixedString\"] = 2] = \"LengthPrefixedString\";\n    StacksMessageType[StacksMessageType[\"MemoString\"] = 3] = \"MemoString\";\n    StacksMessageType[StacksMessageType[\"AssetInfo\"] = 4] = \"AssetInfo\";\n    StacksMessageType[StacksMessageType[\"PostCondition\"] = 5] = \"PostCondition\";\n    StacksMessageType[StacksMessageType[\"PublicKey\"] = 6] = \"PublicKey\";\n    StacksMessageType[StacksMessageType[\"LengthPrefixedList\"] = 7] = \"LengthPrefixedList\";\n    StacksMessageType[StacksMessageType[\"Payload\"] = 8] = \"Payload\";\n    StacksMessageType[StacksMessageType[\"MessageSignature\"] = 9] = \"MessageSignature\";\n    StacksMessageType[StacksMessageType[\"StructuredDataSignature\"] = 10] = \"StructuredDataSignature\";\n    StacksMessageType[StacksMessageType[\"TransactionAuthField\"] = 11] = \"TransactionAuthField\";\n})(StacksMessageType || (StacksMessageType = {}));\nexport function whenMessageType(messageType) {\n    return (messageTypeMap) => messageTypeMap[messageType];\n}\nvar PayloadType;\n(function (PayloadType) {\n    PayloadType[PayloadType[\"TokenTransfer\"] = 0] = \"TokenTransfer\";\n    PayloadType[PayloadType[\"SmartContract\"] = 1] = \"SmartContract\";\n    PayloadType[PayloadType[\"VersionedSmartContract\"] = 6] = \"VersionedSmartContract\";\n    PayloadType[PayloadType[\"ContractCall\"] = 2] = \"ContractCall\";\n    PayloadType[PayloadType[\"PoisonMicroblock\"] = 3] = \"PoisonMicroblock\";\n    PayloadType[PayloadType[\"Coinbase\"] = 4] = \"Coinbase\";\n    PayloadType[PayloadType[\"CoinbaseToAltRecipient\"] = 5] = \"CoinbaseToAltRecipient\";\n})(PayloadType || (PayloadType = {}));\nvar ClarityVersion;\n(function (ClarityVersion) {\n    ClarityVersion[ClarityVersion[\"Clarity1\"] = 1] = \"Clarity1\";\n    ClarityVersion[ClarityVersion[\"Clarity2\"] = 2] = \"Clarity2\";\n})(ClarityVersion || (ClarityVersion = {}));\nvar AnchorMode;\n(function (AnchorMode) {\n    AnchorMode[AnchorMode[\"OnChainOnly\"] = 1] = \"OnChainOnly\";\n    AnchorMode[AnchorMode[\"OffChainOnly\"] = 2] = \"OffChainOnly\";\n    AnchorMode[AnchorMode[\"Any\"] = 3] = \"Any\";\n})(AnchorMode || (AnchorMode = {}));\nconst AnchorModeNames = ['onChainOnly', 'offChainOnly', 'any'];\nconst AnchorModeMap = {\n    [AnchorModeNames[0]]: AnchorMode.OnChainOnly,\n    [AnchorModeNames[1]]: AnchorMode.OffChainOnly,\n    [AnchorModeNames[2]]: AnchorMode.Any,\n    [AnchorMode.OnChainOnly]: AnchorMode.OnChainOnly,\n    [AnchorMode.OffChainOnly]: AnchorMode.OffChainOnly,\n    [AnchorMode.Any]: AnchorMode.Any,\n};\nfunction anchorModeFromNameOrValue(mode) {\n    if (mode in AnchorModeMap) {\n        return AnchorModeMap[mode];\n    }\n    throw new Error(`Invalid anchor mode \"${mode}\", must be one of: ${AnchorModeNames.join(', ')}`);\n}\nvar TransactionVersion;\n(function (TransactionVersion) {\n    TransactionVersion[TransactionVersion[\"Mainnet\"] = 0] = \"Mainnet\";\n    TransactionVersion[TransactionVersion[\"Testnet\"] = 128] = \"Testnet\";\n})(TransactionVersion || (TransactionVersion = {}));\nconst DEFAULT_TRANSACTION_VERSION = TransactionVersion.Mainnet;\nvar PostConditionMode;\n(function (PostConditionMode) {\n    PostConditionMode[PostConditionMode[\"Allow\"] = 1] = \"Allow\";\n    PostConditionMode[PostConditionMode[\"Deny\"] = 2] = \"Deny\";\n})(PostConditionMode || (PostConditionMode = {}));\nvar PostConditionType;\n(function (PostConditionType) {\n    PostConditionType[PostConditionType[\"STX\"] = 0] = \"STX\";\n    PostConditionType[PostConditionType[\"Fungible\"] = 1] = \"Fungible\";\n    PostConditionType[PostConditionType[\"NonFungible\"] = 2] = \"NonFungible\";\n})(PostConditionType || (PostConditionType = {}));\nvar AuthType;\n(function (AuthType) {\n    AuthType[AuthType[\"Standard\"] = 4] = \"Standard\";\n    AuthType[AuthType[\"Sponsored\"] = 5] = \"Sponsored\";\n})(AuthType || (AuthType = {}));\nvar AddressHashMode;\n(function (AddressHashMode) {\n    AddressHashMode[AddressHashMode[\"SerializeP2PKH\"] = 0] = \"SerializeP2PKH\";\n    AddressHashMode[AddressHashMode[\"SerializeP2SH\"] = 1] = \"SerializeP2SH\";\n    AddressHashMode[AddressHashMode[\"SerializeP2WPKH\"] = 2] = \"SerializeP2WPKH\";\n    AddressHashMode[AddressHashMode[\"SerializeP2WSH\"] = 3] = \"SerializeP2WSH\";\n})(AddressHashMode || (AddressHashMode = {}));\nvar AddressVersion;\n(function (AddressVersion) {\n    AddressVersion[AddressVersion[\"MainnetSingleSig\"] = 22] = \"MainnetSingleSig\";\n    AddressVersion[AddressVersion[\"MainnetMultiSig\"] = 20] = \"MainnetMultiSig\";\n    AddressVersion[AddressVersion[\"TestnetSingleSig\"] = 26] = \"TestnetSingleSig\";\n    AddressVersion[AddressVersion[\"TestnetMultiSig\"] = 21] = \"TestnetMultiSig\";\n})(AddressVersion || (AddressVersion = {}));\nvar PubKeyEncoding;\n(function (PubKeyEncoding) {\n    PubKeyEncoding[PubKeyEncoding[\"Compressed\"] = 0] = \"Compressed\";\n    PubKeyEncoding[PubKeyEncoding[\"Uncompressed\"] = 1] = \"Uncompressed\";\n})(PubKeyEncoding || (PubKeyEncoding = {}));\nvar FungibleConditionCode;\n(function (FungibleConditionCode) {\n    FungibleConditionCode[FungibleConditionCode[\"Equal\"] = 1] = \"Equal\";\n    FungibleConditionCode[FungibleConditionCode[\"Greater\"] = 2] = \"Greater\";\n    FungibleConditionCode[FungibleConditionCode[\"GreaterEqual\"] = 3] = \"GreaterEqual\";\n    FungibleConditionCode[FungibleConditionCode[\"Less\"] = 4] = \"Less\";\n    FungibleConditionCode[FungibleConditionCode[\"LessEqual\"] = 5] = \"LessEqual\";\n})(FungibleConditionCode || (FungibleConditionCode = {}));\nvar NonFungibleConditionCode;\n(function (NonFungibleConditionCode) {\n    NonFungibleConditionCode[NonFungibleConditionCode[\"Sends\"] = 16] = \"Sends\";\n    NonFungibleConditionCode[NonFungibleConditionCode[\"DoesNotSend\"] = 17] = \"DoesNotSend\";\n})(NonFungibleConditionCode || (NonFungibleConditionCode = {}));\nvar PostConditionPrincipalID;\n(function (PostConditionPrincipalID) {\n    PostConditionPrincipalID[PostConditionPrincipalID[\"Origin\"] = 1] = \"Origin\";\n    PostConditionPrincipalID[PostConditionPrincipalID[\"Standard\"] = 2] = \"Standard\";\n    PostConditionPrincipalID[PostConditionPrincipalID[\"Contract\"] = 3] = \"Contract\";\n})(PostConditionPrincipalID || (PostConditionPrincipalID = {}));\nvar AssetType;\n(function (AssetType) {\n    AssetType[AssetType[\"STX\"] = 0] = \"STX\";\n    AssetType[AssetType[\"Fungible\"] = 1] = \"Fungible\";\n    AssetType[AssetType[\"NonFungible\"] = 2] = \"NonFungible\";\n})(AssetType || (AssetType = {}));\nvar TxRejectedReason;\n(function (TxRejectedReason) {\n    TxRejectedReason[\"Serialization\"] = \"Serialization\";\n    TxRejectedReason[\"Deserialization\"] = \"Deserialization\";\n    TxRejectedReason[\"SignatureValidation\"] = \"SignatureValidation\";\n    TxRejectedReason[\"FeeTooLow\"] = \"FeeTooLow\";\n    TxRejectedReason[\"BadNonce\"] = \"BadNonce\";\n    TxRejectedReason[\"NotEnoughFunds\"] = \"NotEnoughFunds\";\n    TxRejectedReason[\"NoSuchContract\"] = \"NoSuchContract\";\n    TxRejectedReason[\"NoSuchPublicFunction\"] = \"NoSuchPublicFunction\";\n    TxRejectedReason[\"BadFunctionArgument\"] = \"BadFunctionArgument\";\n    TxRejectedReason[\"ContractAlreadyExists\"] = \"ContractAlreadyExists\";\n    TxRejectedReason[\"PoisonMicroblocksDoNotConflict\"] = \"PoisonMicroblocksDoNotConflict\";\n    TxRejectedReason[\"PoisonMicroblockHasUnknownPubKeyHash\"] = \"PoisonMicroblockHasUnknownPubKeyHash\";\n    TxRejectedReason[\"PoisonMicroblockIsInvalid\"] = \"PoisonMicroblockIsInvalid\";\n    TxRejectedReason[\"BadAddressVersionByte\"] = \"BadAddressVersionByte\";\n    TxRejectedReason[\"NoCoinbaseViaMempool\"] = \"NoCoinbaseViaMempool\";\n    TxRejectedReason[\"ServerFailureNoSuchChainTip\"] = \"ServerFailureNoSuchChainTip\";\n    TxRejectedReason[\"ServerFailureDatabase\"] = \"ServerFailureDatabase\";\n    TxRejectedReason[\"ServerFailureOther\"] = \"ServerFailureOther\";\n})(TxRejectedReason || (TxRejectedReason = {}));\nexport { MAX_STRING_LENGTH_BYTES, CLARITY_INT_SIZE, CLARITY_INT_BYTE_SIZE, COINBASE_LENGTH_BYTES as COINBASE_BYTES_LENGTH, DEFAULT_CHAIN_ID, DEFAULT_TRANSACTION_VERSION, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, COMPRESSED_PUBKEY_LENGTH_BYTES, UNCOMPRESSED_PUBKEY_LENGTH_BYTES, MEMO_MAX_LENGTH_BYTES, DEFAULT_CORE_NODE_API_URL, ChainID, StacksMessageType, PayloadType, ClarityVersion, AnchorMode, AnchorModeNames, anchorModeFromNameOrValue, TransactionVersion, PostConditionMode, PostConditionType, PostConditionPrincipalID, AuthType, AddressHashMode, AddressVersion, PubKeyEncoding, FungibleConditionCode, NonFungibleConditionCode, AssetType, TxRejectedReason, };\n//# sourceMappingURL=constants.js.map","export function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nexport function bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nexport function bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new TypeError('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nexport function hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nexport function exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nexport function output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output,\n};\nexport default assert;\n","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// The import here is via the package name. This is to ensure\n// that exports mapping/resolution does fall into place.\nimport { crypto } from '@noble/hashes/crypto';\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.\n// So, just to be sure not to corrupt anything.\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))\n */\nexport function bytesToHex(uint8a) {\n    // pre-caching improves the speed 6x\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('deadbeef')\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise\n// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string') {\n        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n    }\n    return new TextEncoder().encode(str);\n}\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!(data instanceof Uint8Array))\n        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n    return data;\n}\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\nexport function concatBytes(...arrays) {\n    if (!arrays.every((a) => a instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n        throw new TypeError('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashConstructor) {\n    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();\n    const tmp = hashConstructor();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashConstructor();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto.web) {\n        return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    }\n    else if (crypto.node) {\n        return new Uint8Array(crypto.node.randomBytes(bytesLength).buffer);\n    }\n    else {\n        throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n}\n","export const crypto = {\n    node: undefined,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\n","import assert from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nexport class SHA2 extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        assert.exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        assert.exists(this);\n        assert.output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n","import { SHA2 } from './_sha2.js';\nimport { wrapConstructor } from './utils.js';\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\nconst Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = Uint8Array.from({ length: 16 }, (_, i) => i);\nconst Pi = Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++)\n    for (let j of [idxL, idxR])\n        j.push(j[i].map((k) => Rho[k]));\nconst shifts = [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\nconst shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst Kl = new Uint32Array([0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]);\nconst Kr = new Uint32Array([0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));\n// It's called f() in spec.\nfunction f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    else if (group === 1)\n        return (x & y) | (~x & z);\n    else if (group === 2)\n        return (x | ~y) ^ z;\n    else if (group === 3)\n        return (x & z) | (y & ~z);\n    else\n        return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst BUF = new Uint32Array(16);\nexport class RIPEMD160 extends SHA2 {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        BUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a hash function from 1990s.\n * @param message - msg that would be hashed\n */\nexport const ripemd160 = wrapConstructor(() => new RIPEMD160());\n","import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = wrapConstructor(() => new SHA256());\nexport const sha224 = wrapConstructor(() => new SHA224());\n","const U32_MASK64 = BigInt(2 ** 32 - 1);\nconst _32n = BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nexport function fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nexport function split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nexport const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (h, l) => l;\nconst rotr32L = (h, l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\n// Removing \"export\" has 5% perf penalty -_-\nexport function add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n","import { SHA2 } from './_sha2.js';\nimport u64 from './_u64.js';\nimport { wrapConstructor } from './utils.js';\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n)));\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = new Uint32Array(80);\nconst SHA512_W_L = new Uint32Array(80);\nexport class SHA512 extends SHA2 {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nexport const sha512 = wrapConstructor(() => new SHA512());\nexport const sha512_224 = wrapConstructor(() => new SHA512_224());\nexport const sha512_256 = wrapConstructor(() => new SHA512_256());\nexport const sha384 = wrapConstructor(() => new SHA384());\n","/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst CURVE = Object.freeze({\n    a: _0n,\n    b: BigInt(7),\n    P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n    h: _1n,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n});\nconst divNearest = (a, b) => (a + b / _2n) / b;\nconst endo = {\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n    splitScalar(k) {\n        const { n } = CURVE;\n        const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n        const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n        const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n        const b2 = a1;\n        const POW_2_128 = BigInt('0x100000000000000000000000000000000');\n        const c1 = divNearest(b2 * k, n);\n        const c2 = divNearest(-b1 * k, n);\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\n        const k1neg = k1 > POW_2_128;\n        const k2neg = k2 > POW_2_128;\n        if (k1neg)\n            k1 = n - k1;\n        if (k2neg)\n            k2 = n - k2;\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\n            throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n        }\n        return { k1neg, k1, k2neg, k2 };\n    },\n};\nconst fieldLen = 32;\nconst groupLen = 32;\nconst hashLen = 32;\nconst compressedLen = fieldLen + 1;\nconst uncompressedLen = 2 * fieldLen + 1;\nexport { CURVE };\nfunction weierstrass(x) {\n    const { a, b } = CURVE;\n    const x2 = mod(x * x);\n    const x3 = mod(x2 * x);\n    return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass ShaError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nfunction assertJacPoint(other) {\n    if (!(other instanceof JacobianPoint))\n        throw new TypeError('JacobianPoint expected');\n}\nclass JacobianPoint {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\n        }\n        if (p.equals(Point.ZERO))\n            return JacobianPoint.ZERO;\n        return new JacobianPoint(p.x, p.y, _1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        return U1 === U2 && S1 === S2;\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(B * B);\n        const x1b = X1 + B;\n        const D = mod(_2n * (mod(x1b * x1b) - A - C));\n        const E = mod(_3n * A);\n        const F = mod(E * E);\n        const X3 = mod(F - _2n * D);\n        const Y3 = mod(E * (D - X3) - _8n * C);\n        const Z3 = mod(_2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        if (X2 === _0n || Y2 === _0n)\n            return this;\n        if (X1 === _0n || Y1 === _0n)\n            return other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === _0n) {\n            if (r === _0n) {\n                return this.double();\n            }\n            else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H * H);\n        const HHH = mod(H * HH);\n        const V = mod(U1 * HH);\n        const X3 = mod(r * r - HHH - _2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        const P0 = JacobianPoint.ZERO;\n        if (typeof scalar === 'bigint' && scalar === _0n)\n            return P0;\n        let n = normalizeScalar(scalar);\n        if (n === _1n)\n            return this;\n        if (!USE_ENDOMORPHISM) {\n            let p = P0;\n            let d = this;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        }\n        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n        let k1p = P0;\n        let k2p = P0;\n        let d = this;\n        while (k1 > _0n || k2 > _0n) {\n            if (k1 & _1n)\n                k1p = k1p.add(d);\n            if (k2 & _1n)\n                k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= _1n;\n            k2 >>= _1n;\n        }\n        if (k1neg)\n            k1p = k1p.negate();\n        if (k2neg)\n            k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.BASE;\n        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            const offset1 = offset;\n            const offset2 = offset + Math.abs(wbits) - 1;\n            const cond1 = window % 2 !== 0;\n            const cond2 = wbits < 0;\n            if (wbits === 0) {\n                f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n            }\n            else {\n                p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n            }\n        }\n        return { p, f };\n    }\n    multiply(scalar, affinePoint) {\n        let n = normalizeScalar(scalar);\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);\n            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);\n            k1p = constTimeNegate(k1neg, k1p);\n            k2p = constTimeNegate(k2neg, k2p);\n            k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n            point = k1p.add(k2p);\n            fake = f1p.add(f2p);\n        }\n        else {\n            const { p, f } = this.wNAF(n, affinePoint);\n            point = p;\n            fake = f;\n        }\n        return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n    toAffine(invZ) {\n        const { x, y, z } = this;\n        const is0 = this.equals(JacobianPoint.ZERO);\n        if (invZ == null)\n            invZ = is0 ? _8n : invert(z);\n        const iz1 = invZ;\n        const iz2 = mod(iz1 * iz1);\n        const iz3 = mod(iz2 * iz1);\n        const ax = mod(x * iz2);\n        const ay = mod(y * iz3);\n        const zz = mod(z * iz1);\n        if (is0)\n            return Point.ZERO;\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nconst pointPrecomputes = new WeakMap();\nexport class Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    hasEvenY() {\n        return this.y % _2n === _0n;\n    }\n    static fromCompressedHex(bytes) {\n        const isShort = bytes.length === 32;\n        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n        if (!isValidFieldElement(x))\n            throw new Error('Point is not on curve');\n        const y2 = weierstrass(x);\n        let y = sqrtMod(y2);\n        const isYOdd = (y & _1n) === _1n;\n        if (isShort) {\n            if (isYOdd)\n                y = mod(-y);\n        }\n        else {\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\n            if (isFirstByteOdd !== isYOdd)\n                y = mod(-y);\n        }\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        const x = bytesToNumber(bytes.subarray(1, fieldLen + 1));\n        const y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        const len = bytes.length;\n        const header = bytes[0];\n        if (len === fieldLen)\n            return this.fromCompressedHex(bytes);\n        if (len === compressedLen && (header === 0x02 || header === 0x03)) {\n            return this.fromCompressedHex(bytes);\n        }\n        if (len === uncompressedLen && header === 0x04)\n            return this.fromUncompressedHex(bytes);\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        const { r, s } = normalizeSignature(signature);\n        if (![0, 1, 2, 3].includes(recovery))\n            throw new Error('Cannot recover: invalid recovery bit');\n        const h = truncateHash(ensureBytes(msgHash));\n        const { n } = CURVE;\n        const radj = recovery === 2 || recovery === 3 ? r + n : r;\n        const rinv = invert(radj, n);\n        const u1 = mod(-h * rinv, n);\n        const u2 = mod(s * rinv, n);\n        const prefix = recovery & 1 ? '03' : '02';\n        const R = Point.fromHex(prefix + numTo32bStr(radj));\n        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n        if (!Q)\n            throw new Error('Cannot recover signature: point at infinify');\n        Q.assertValidity();\n        return Q;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = numTo32bStr(this.x);\n        if (isCompressed) {\n            const prefix = this.hasEvenY() ? '02' : '03';\n            return `${prefix}${x}`;\n        }\n        else {\n            return `04${x}${numTo32bStr(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const msg = 'Point is not on elliptic curve';\n        const { x, y } = this;\n        if (!isValidFieldElement(x) || !isValidFieldElement(y))\n            throw new Error(msg);\n        const left = mod(y * y);\n        const right = weierstrass(x);\n        if (mod(left - right) !== _0n)\n            throw new Error(msg);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n    multiplyAndAddUnsafe(Q, a, b) {\n        const P = JacobianPoint.fromAffine(this);\n        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n        const sum = aP.add(bQ);\n        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n    if (data.length < 2 || data[0] !== 0x02) {\n        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n    }\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) {\n        throw new Error(`Invalid signature integer: wrong length`);\n    }\n    if (res[0] === 0x00 && res[1] <= 0x7f) {\n        throw new Error('Invalid signature integer: trailing length');\n    }\n    return { data: bytesToNumber(res), left: data.subarray(len + 2) };\n}\nfunction parseDERSignature(data) {\n    if (data.length < 2 || data[0] != 0x30) {\n        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n    }\n    if (data[1] !== data.length - 2) {\n        throw new Error('Invalid signature: incorrect length');\n    }\n    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));\n    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);\n    if (rBytesLeft.length) {\n        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n    }\n    return { r, s };\n}\nexport class Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromCompact(hex) {\n        const arr = hex instanceof Uint8Array;\n        const name = 'Signature.fromCompact';\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`${name}: Expected string or Uint8Array`);\n        const str = arr ? bytesToHex(hex) : hex;\n        if (str.length !== 128)\n            throw new Error(`${name}: Expected 64-byte hex`);\n        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n    static fromDER(hex) {\n        const arr = hex instanceof Uint8Array;\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));\n        return new Signature(r, s);\n    }\n    static fromHex(hex) {\n        return this.fromDER(hex);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isWithinCurveOrder(r))\n            throw new Error('Invalid Signature: r must be 0 < r < n');\n        if (!isWithinCurveOrder(s))\n            throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n    hasHighS() {\n        const HALF = CURVE.n >> _1n;\n        return this.s > HALF;\n    }\n    normalizeS() {\n        return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;\n    }\n    toDERRawBytes() {\n        return hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n        const sHex = sliceDER(numberToHexUnpadded(this.s));\n        const rHex = sliceDER(numberToHexUnpadded(this.r));\n        const sHexL = sHex.length / 2;\n        const rHexL = rHex.length / 2;\n        const sLen = numberToHexUnpadded(sHexL);\n        const rLen = numberToHexUnpadded(rHexL);\n        const length = numberToHexUnpadded(rHexL + sHexL + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n    toRawBytes() {\n        return this.toDERRawBytes();\n    }\n    toHex() {\n        return this.toDERHex();\n    }\n    toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n}\nfunction concatBytes(...arrays) {\n    if (!arrays.every((b) => b instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nfunction numTo32bStr(num) {\n    if (typeof num !== 'bigint')\n        throw new Error('Expected bigint');\n    if (!(_0n <= num && num < POW_2_256))\n        throw new Error('Expected number 0 <= n < 2^256');\n    return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n    const b = hexToBytes(numTo32bStr(num));\n    if (b.length !== 32)\n        throw new Error('Error: expected 32 bytes');\n    return b;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)\n        return BigInt(num);\n    if (typeof num === 'bigint' && isWithinCurveOrder(num))\n        return num;\n    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction sqrtMod(x) {\n    const { P } = CURVE;\n    const _6n = BigInt(6);\n    const _11n = BigInt(11);\n    const _22n = BigInt(22);\n    const _23n = BigInt(23);\n    const _44n = BigInt(44);\n    const _88n = BigInt(88);\n    const b2 = (x * x * x) % P;\n    const b3 = (b2 * b2 * x) % P;\n    const b6 = (pow2(b3, _3n) * b3) % P;\n    const b9 = (pow2(b6, _3n) * b3) % P;\n    const b11 = (pow2(b9, _2n) * b2) % P;\n    const b22 = (pow2(b11, _11n) * b11) % P;\n    const b44 = (pow2(b22, _22n) * b22) % P;\n    const b88 = (pow2(b44, _44n) * b44) % P;\n    const b176 = (pow2(b88, _88n) * b88) % P;\n    const b220 = (pow2(b176, _44n) * b44) % P;\n    const b223 = (pow2(b220, _3n) * b3) % P;\n    const t1 = (pow2(b223, _23n) * b22) % P;\n    const t2 = (pow2(t1, _6n) * b2) % P;\n    const rt = pow2(t2, _2n);\n    const xc = (rt * rt) % P;\n    if (xc !== x)\n        throw new Error('Cannot find square root');\n    return rt;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const scratch = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = mod(acc * scratch[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return scratch;\n}\nfunction bits2int_2(bytes) {\n    const delta = bytes.length * 8 - groupLen * 8;\n    const num = bytesToNumber(bytes);\n    return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction truncateHash(hash, truncateOnly = false) {\n    const h = bits2int_2(hash);\n    if (truncateOnly)\n        return h;\n    const { n } = CURVE;\n    return h >= n ? h - n : h;\n}\nlet _sha256Sync;\nlet _hmacSha256Sync;\nclass HmacDrbg {\n    constructor(hashLen, qByteLen) {\n        this.hashLen = hashLen;\n        this.qByteLen = qByteLen;\n        if (typeof hashLen !== 'number' || hashLen < 2)\n            throw new Error('hashLen must be a number');\n        if (typeof qByteLen !== 'number' || qByteLen < 2)\n            throw new Error('qByteLen must be a number');\n        this.v = new Uint8Array(hashLen).fill(1);\n        this.k = new Uint8Array(hashLen).fill(0);\n        this.counter = 0;\n    }\n    hmac(...values) {\n        return utils.hmacSha256(this.k, ...values);\n    }\n    hmacSync(...values) {\n        return _hmacSha256Sync(this.k, ...values);\n    }\n    checkSync() {\n        if (typeof _hmacSha256Sync !== 'function')\n            throw new ShaError('hmacSha256Sync needs to be set');\n    }\n    incr() {\n        if (this.counter >= 1000)\n            throw new Error('Tried 1,000 k values for sign(), all were invalid');\n        this.counter += 1;\n    }\n    async reseed(seed = new Uint8Array()) {\n        this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);\n        this.v = await this.hmac(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);\n        this.v = await this.hmac(this.v);\n    }\n    reseedSync(seed = new Uint8Array()) {\n        this.checkSync();\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n        this.v = this.hmacSync(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n        this.v = this.hmacSync(this.v);\n    }\n    async generate() {\n        this.incr();\n        let len = 0;\n        const out = [];\n        while (len < this.qByteLen) {\n            this.v = await this.hmac(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n    generateSync() {\n        this.checkSync();\n        this.incr();\n        let len = 0;\n        const out = [];\n        while (len < this.qByteLen) {\n            this.v = this.hmacSync(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n}\nfunction isWithinCurveOrder(num) {\n    return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n    return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d, lowS = true) {\n    const { n } = CURVE;\n    const k = truncateHash(kBytes, true);\n    if (!isWithinCurveOrder(k))\n        return;\n    const kinv = invert(k, n);\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, n);\n    if (r === _0n)\n        return;\n    const s = mod(kinv * mod(m + d * r, n), n);\n    if (s === _0n)\n        return;\n    let sig = new Signature(r, s);\n    let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n    if (lowS && sig.hasHighS()) {\n        sig = sig.normalizeS();\n        recovery ^= 1;\n    }\n    return { sig, recovery };\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n        num = BigInt(key);\n    }\n    else if (typeof key === 'string') {\n        if (key.length !== 2 * groupLen)\n            throw new Error('Expected 32 bytes of private key');\n        num = hexToNumber(key);\n    }\n    else if (key instanceof Uint8Array) {\n        if (key.length !== groupLen)\n            throw new Error('Expected 32 bytes of private key');\n        num = bytesToNumber(key);\n    }\n    else {\n        throw new TypeError('Expected valid private key');\n    }\n    if (!isWithinCurveOrder(num))\n        throw new Error('Expected private key: 0 < key < n');\n    return num;\n}\nfunction normalizePublicKey(publicKey) {\n    if (publicKey instanceof Point) {\n        publicKey.assertValidity();\n        return publicKey;\n    }\n    else {\n        return Point.fromHex(publicKey);\n    }\n}\nfunction normalizeSignature(signature) {\n    if (signature instanceof Signature) {\n        signature.assertValidity();\n        return signature;\n    }\n    try {\n        return Signature.fromDER(signature);\n    }\n    catch (error) {\n        return Signature.fromCompact(signature);\n    }\n}\nexport function getPublicKey(privateKey, isCompressed = false) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexport function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {\n    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nfunction isProbPub(item) {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr)\n        return len === compressedLen || len === uncompressedLen;\n    if (str)\n        return len === compressedLen * 2 || len === uncompressedLen * 2;\n    if (item instanceof Point)\n        return true;\n    return false;\n}\nexport function getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isProbPub(privateA))\n        throw new TypeError('getSharedSecret: first arg must be private key');\n    if (!isProbPub(publicB))\n        throw new TypeError('getSharedSecret: second arg must be public key');\n    const b = normalizePublicKey(publicB);\n    b.assertValidity();\n    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nfunction bits2int(bytes) {\n    const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;\n    return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n    const z1 = bits2int(bytes);\n    const z2 = mod(z1, CURVE.n);\n    return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n    return numTo32b(num);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n    if (msgHash == null)\n        throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n    const h1 = ensureBytes(msgHash);\n    const d = normalizePrivateKey(privateKey);\n    const seedArgs = [int2octets(d), bits2octets(h1)];\n    if (extraEntropy != null) {\n        if (extraEntropy === true)\n            extraEntropy = utils.randomBytes(fieldLen);\n        const e = ensureBytes(extraEntropy);\n        if (e.length !== fieldLen)\n            throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);\n        seedArgs.push(e);\n    }\n    const seed = concatBytes(...seedArgs);\n    const m = bits2int(h1);\n    return { seed, m, d };\n}\nfunction finalizeSig(recSig, opts) {\n    const { sig, recovery } = recSig;\n    const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);\n    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n    return recovered ? [hashed, recovery] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    await drbg.reseed(seed);\n    let sig;\n    while (!(sig = kmdToSig(await drbg.generate(), m, d, opts.canonical)))\n        await drbg.reseed();\n    return finalizeSig(sig, opts);\n}\nfunction signSync(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    drbg.reseedSync(seed);\n    let sig;\n    while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical)))\n        drbg.reseedSync();\n    return finalizeSig(sig, opts);\n}\nexport { sign, signSync };\nconst vopts = { strict: true };\nexport function verify(signature, msgHash, publicKey, opts = vopts) {\n    let sig;\n    try {\n        sig = normalizeSignature(signature);\n        msgHash = ensureBytes(msgHash);\n    }\n    catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    if (opts.strict && sig.hasHighS())\n        return false;\n    const h = truncateHash(msgHash);\n    let P;\n    try {\n        P = normalizePublicKey(publicKey);\n    }\n    catch (error) {\n        return false;\n    }\n    const { n } = CURVE;\n    const sinv = invert(s, n);\n    const u1 = mod(h * sinv, n);\n    const u2 = mod(r * sinv, n);\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n    if (!R)\n        return false;\n    const v = mod(R.x, n);\n    return v === r;\n}\nfunction schnorrChallengeFinalize(ch) {\n    return mod(bytesToNumber(ch), CURVE.n);\n}\nclass SchnorrSignature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        if (bytes.length !== 64)\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        const r = bytesToNumber(bytes.subarray(0, 32));\n        const s = bytesToNumber(bytes.subarray(32, 64));\n        return new SchnorrSignature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))\n            throw new Error('Invalid signature');\n    }\n    toHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    return Point.fromPrivateKey(privateKey).toRawX();\n}\nclass InternalSchnorrSignature {\n    constructor(message, privateKey, auxRand = utils.randomBytes()) {\n        if (message == null)\n            throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n        this.m = ensureBytes(message);\n        const { x, scalar } = this.getScalar(normalizePrivateKey(privateKey));\n        this.px = x;\n        this.d = scalar;\n        this.rand = ensureBytes(auxRand);\n        if (this.rand.length !== 32)\n            throw new TypeError('sign: Expected 32 bytes of aux randomness');\n    }\n    getScalar(priv) {\n        const point = Point.fromPrivateKey(priv);\n        const scalar = point.hasEvenY() ? priv : CURVE.n - priv;\n        return { point, scalar, x: point.toRawX() };\n    }\n    initNonce(d, t0h) {\n        return numTo32b(d ^ bytesToNumber(t0h));\n    }\n    finalizeNonce(k0h) {\n        const k0 = mod(bytesToNumber(k0h), CURVE.n);\n        if (k0 === _0n)\n            throw new Error('sign: Creation of signature failed. k is zero');\n        const { point: R, x: rx, scalar: k } = this.getScalar(k0);\n        return { R, rx, k };\n    }\n    finalizeSig(R, k, e, d) {\n        return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n    }\n    error() {\n        throw new Error('sign: Invalid signature produced');\n    }\n    async calc() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHash;\n        const t = this.initNonce(d, await tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!(await schnorrVerify(sig, m, px)))\n            this.error();\n        return sig;\n    }\n    calcSync() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHashSync;\n        const t = this.initNonce(d, tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!schnorrVerifySync(sig, m, px))\n            this.error();\n        return sig;\n    }\n}\nasync function schnorrSign(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calc();\n}\nfunction schnorrSignSync(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n    const raw = signature instanceof SchnorrSignature;\n    const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n    if (raw)\n        sig.assertValidity();\n    return {\n        ...sig,\n        m: ensureBytes(message),\n        P: normalizePublicKey(publicKey),\n    };\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n    if (!R || !R.hasEvenY() || R.x !== r)\n        return false;\n    return true;\n}\nasync function schnorrVerify(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(await utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        return false;\n    }\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        if (error instanceof ShaError)\n            throw error;\n        return false;\n    }\n}\nexport const schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    signSync: schnorrSignSync,\n    verifySync: schnorrVerifySync,\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nconst TAGS = {\n    challenge: 'BIP0340/challenge',\n    aux: 'BIP0340/aux',\n    nonce: 'BIP0340/nonce',\n};\nconst TAGGED_HASH_PREFIXES = {};\nexport const utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    mod,\n    invert,\n    isValidPrivateKey(privateKey) {\n        try {\n            normalizePrivateKey(privateKey);\n            return true;\n        }\n        catch (error) {\n            return false;\n        }\n    },\n    _bigintTo32Bytes: numTo32b,\n    _normalizePrivateKey: normalizePrivateKey,\n    hashToPrivateKey: (hash) => {\n        hash = ensureBytes(hash);\n        const minLen = groupLen + 8;\n        if (hash.length < minLen || hash.length > 1024) {\n            throw new Error(`Expected valid bytes of private key as per FIPS 186`);\n        }\n        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n        return numTo32b(num);\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return Uint8Array.from(randomBytes(bytesLength));\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => utils.hashToPrivateKey(utils.randomBytes(groupLen + 8)),\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_3n);\n        return cached;\n    },\n    sha256: async (...messages) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHash } = crypto.node;\n            const hash = createHash('sha256');\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages) => {\n        if (crypto.web) {\n            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n            const message = concatBytes(...messages);\n            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHmac } = crypto.node;\n            const hash = createHmac('sha256', key);\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    sha256Sync: undefined,\n    hmacSha256Sync: undefined,\n    taggedHash: async (tag, ...messages) => {\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = await utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return utils.sha256(tagP, ...messages);\n    },\n    taggedHashSync: (tag, ...messages) => {\n        if (typeof _sha256Sync !== 'function')\n            throw new ShaError('sha256Sync is undefined, you need to set it');\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return _sha256Sync(tagP, ...messages);\n    },\n    _JacobianPoint: JacobianPoint,\n};\nObject.defineProperties(utils, {\n    sha256Sync: {\n        configurable: false,\n        get() {\n            return _sha256Sync;\n        },\n        set(val) {\n            if (!_sha256Sync)\n                _sha256Sync = val;\n        },\n    },\n    hmacSha256Sync: {\n        configurable: false,\n        get() {\n            return _hmacSha256Sync;\n        },\n        set(val) {\n            if (!_hmacSha256Sync)\n                _hmacSha256Sync = val;\n        },\n    },\n});\n","import { ripemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { sha512_256 } from '@noble/hashes/sha512';\nimport { utils } from '@noble/secp256k1';\nimport { bytesToHex, concatArray, concatBytes, utf8ToBytes, with0x } from '@stacks/common';\nimport { c32addressDecode } from 'c32check';\nimport lodashCloneDeep from 'lodash.clonedeep';\nimport { deserializeCV, serializeCV } from './clarity';\nexport { verify as verifySignature } from '@noble/secp256k1';\nexport const randomBytes = (bytesLength) => utils.randomBytes(bytesLength);\nexport const leftPadHex = (hexString) => hexString.length % 2 == 0 ? hexString : `0${hexString}`;\nexport const leftPadHexToLength = (hexString, length) => hexString.padStart(length, '0');\nexport const rightPadHexToLength = (hexString, length) => hexString.padEnd(length, '0');\nexport const exceedsMaxLengthBytes = (string, maxLengthBytes) => string ? utf8ToBytes(string).length > maxLengthBytes : false;\nexport function cloneDeep(obj) {\n    return lodashCloneDeep(obj);\n}\nexport function omit(obj, prop) {\n    const clone = cloneDeep(obj);\n    delete clone[prop];\n    return clone;\n}\nexport const txidFromData = (data) => {\n    return bytesToHex(sha512_256(data));\n};\nexport const hash160 = (input) => {\n    return ripemd160(sha256(input));\n};\nexport const hashP2PKH = (input) => {\n    return bytesToHex(hash160(input));\n};\nexport const hashP2WPKH = (input) => {\n    const keyHash = hash160(input);\n    const redeemScript = concatBytes(new Uint8Array([0]), new Uint8Array([keyHash.length]), keyHash);\n    const redeemScriptHash = hash160(redeemScript);\n    return bytesToHex(redeemScriptHash);\n};\nexport const hashP2SH = (numSigs, pubKeys) => {\n    if (numSigs > 15 || pubKeys.length > 15) {\n        throw Error('P2SH multisig address can only contain up to 15 public keys');\n    }\n    const bytesArray = [];\n    bytesArray.push(80 + numSigs);\n    pubKeys.forEach(pubKey => {\n        bytesArray.push(pubKey.length);\n        bytesArray.push(pubKey);\n    });\n    bytesArray.push(80 + pubKeys.length);\n    bytesArray.push(174);\n    const redeemScript = concatArray(bytesArray);\n    const redeemScriptHash = hash160(redeemScript);\n    return bytesToHex(redeemScriptHash);\n};\nexport const hashP2WSH = (numSigs, pubKeys) => {\n    if (numSigs > 15 || pubKeys.length > 15) {\n        throw Error('P2WSH multisig address can only contain up to 15 public keys');\n    }\n    const scriptArray = [];\n    scriptArray.push(80 + numSigs);\n    pubKeys.forEach(pubKey => {\n        scriptArray.push(pubKey.length);\n        scriptArray.push(pubKey);\n    });\n    scriptArray.push(80 + pubKeys.length);\n    scriptArray.push(174);\n    const script = concatArray(scriptArray);\n    const digest = sha256(script);\n    const bytesArray = [];\n    bytesArray.push(0);\n    bytesArray.push(digest.length);\n    bytesArray.push(digest);\n    const redeemScript = concatArray(bytesArray);\n    const redeemScriptHash = hash160(redeemScript);\n    return bytesToHex(redeemScriptHash);\n};\nexport function isClarityName(name) {\n    const regex = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;\n    return regex.test(name) && name.length < 128;\n}\nexport function cvToHex(cv) {\n    const serialized = serializeCV(cv);\n    return `0x${bytesToHex(serialized)}`;\n}\nexport function hexToCV(hex) {\n    return deserializeCV(hex);\n}\nexport const parseReadOnlyResponse = (response) => {\n    if (response.okay)\n        return hexToCV(response.result);\n    throw new Error(response.cause);\n};\nexport const validateStacksAddress = (stacksAddress) => {\n    try {\n        c32addressDecode(stacksAddress);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n};\nexport const validateTxId = (txid) => {\n    if (txid === 'success')\n        return true;\n    const value = with0x(txid).toLowerCase();\n    if (value.length !== 66)\n        return false;\n    return with0x(BigInt(value).toString(16).padStart(64, '0')) === value;\n};\n//# sourceMappingURL=utils.js.map","import { MAX_STRING_LENGTH_BYTES, PostConditionPrincipalID, StacksMessageType, } from './constants';\nimport { c32addressDecode } from 'c32check';\nimport { exceedsMaxLengthBytes } from './utils';\nexport function parseAssetInfoString(id) {\n    const [assetAddress, assetContractName, assetTokenName] = id.split(/\\.|::/);\n    const assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);\n    return assetInfo;\n}\nexport function createLPString(content, lengthPrefixBytes, maxLengthBytes) {\n    const prefixLength = lengthPrefixBytes || 1;\n    const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;\n    if (exceedsMaxLengthBytes(content, maxLength)) {\n        throw new Error(`String length exceeds maximum bytes ${maxLength}`);\n    }\n    return {\n        type: StacksMessageType.LengthPrefixedString,\n        content,\n        lengthPrefixBytes: prefixLength,\n        maxLengthBytes: maxLength,\n    };\n}\nexport function createAssetInfo(addressString, contractName, assetName) {\n    return {\n        type: StacksMessageType.AssetInfo,\n        address: createAddress(addressString),\n        contractName: createLPString(contractName),\n        assetName: createLPString(assetName),\n    };\n}\nexport function createAddress(c32AddressString) {\n    const addressData = c32addressDecode(c32AddressString);\n    return {\n        type: StacksMessageType.Address,\n        version: addressData[0],\n        hash160: addressData[1],\n    };\n}\nexport function parsePrincipalString(principalString) {\n    if (principalString.includes('.')) {\n        const [address, contractName] = principalString.split('.');\n        return createContractPrincipal(address, contractName);\n    }\n    else {\n        return createStandardPrincipal(principalString);\n    }\n}\nexport function createContractPrincipal(addressString, contractName) {\n    const addr = createAddress(addressString);\n    const name = createLPString(contractName);\n    return {\n        type: StacksMessageType.Principal,\n        prefix: PostConditionPrincipalID.Contract,\n        address: addr,\n        contractName: name,\n    };\n}\nexport function createStandardPrincipal(addressString) {\n    const addr = createAddress(addressString);\n    return {\n        type: StacksMessageType.Principal,\n        prefix: PostConditionPrincipalID.Standard,\n        address: addr,\n    };\n}\n//# sourceMappingURL=postcondition-types.js.map","import { bytesToHex, bytesToUtf8, concatArray, hexToBytes, hexToInt, intToBytes, intToHex, utf8ToBytes, } from '@stacks/common';\nimport { MEMO_MAX_LENGTH_BYTES, AddressHashMode, AddressVersion, StacksMessageType, PostConditionPrincipalID, PostConditionType, FungibleConditionCode, NonFungibleConditionCode, } from './constants';\nimport { serializePublicKey, deserializePublicKey, isCompressed } from './keys';\nimport { exceedsMaxLengthBytes, hashP2PKH, rightPadHexToLength, hashP2SH, hashP2WSH, hashP2WPKH, } from './utils';\nimport { createLPString, } from './postcondition-types';\nimport { deserializePayload, serializePayload } from './payload';\nimport { DeserializationError } from './errors';\nimport { deserializeTransactionAuthField, deserializeMessageSignature, serializeMessageSignature, serializeTransactionAuthField, } from './signature';\nimport { addressHashModeToVersion, addressFromVersionHash, } from './common';\nimport { deserializeCV, serializeCV } from './clarity';\nexport function serializeStacksMessage(message) {\n    switch (message.type) {\n        case StacksMessageType.Address:\n            return serializeAddress(message);\n        case StacksMessageType.Principal:\n            return serializePrincipal(message);\n        case StacksMessageType.LengthPrefixedString:\n            return serializeLPString(message);\n        case StacksMessageType.MemoString:\n            return serializeMemoString(message);\n        case StacksMessageType.AssetInfo:\n            return serializeAssetInfo(message);\n        case StacksMessageType.PostCondition:\n            return serializePostCondition(message);\n        case StacksMessageType.PublicKey:\n            return serializePublicKey(message);\n        case StacksMessageType.LengthPrefixedList:\n            return serializeLPList(message);\n        case StacksMessageType.Payload:\n            return serializePayload(message);\n        case StacksMessageType.TransactionAuthField:\n            return serializeTransactionAuthField(message);\n        case StacksMessageType.MessageSignature:\n            return serializeMessageSignature(message);\n    }\n}\nexport function deserializeStacksMessage(bytesReader, type, listType) {\n    switch (type) {\n        case StacksMessageType.Address:\n            return deserializeAddress(bytesReader);\n        case StacksMessageType.Principal:\n            return deserializePrincipal(bytesReader);\n        case StacksMessageType.LengthPrefixedString:\n            return deserializeLPString(bytesReader);\n        case StacksMessageType.MemoString:\n            return deserializeMemoString(bytesReader);\n        case StacksMessageType.AssetInfo:\n            return deserializeAssetInfo(bytesReader);\n        case StacksMessageType.PostCondition:\n            return deserializePostCondition(bytesReader);\n        case StacksMessageType.PublicKey:\n            return deserializePublicKey(bytesReader);\n        case StacksMessageType.Payload:\n            return deserializePayload(bytesReader);\n        case StacksMessageType.LengthPrefixedList:\n            if (!listType) {\n                throw new DeserializationError('No List Type specified');\n            }\n            return deserializeLPList(bytesReader, listType);\n        case StacksMessageType.MessageSignature:\n            return deserializeMessageSignature(bytesReader);\n        default:\n            throw new Error('Could not recognize StacksMessageType');\n    }\n}\nexport function createEmptyAddress() {\n    return {\n        type: StacksMessageType.Address,\n        version: AddressVersion.MainnetSingleSig,\n        hash160: '0'.repeat(40),\n    };\n}\nexport function addressFromHashMode(hashMode, txVersion, data) {\n    const version = addressHashModeToVersion(hashMode, txVersion);\n    return addressFromVersionHash(version, data);\n}\nexport function addressFromPublicKeys(version, hashMode, numSigs, publicKeys) {\n    if (publicKeys.length === 0) {\n        throw Error('Invalid number of public keys');\n    }\n    if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n        if (publicKeys.length !== 1 || numSigs !== 1) {\n            throw Error('Invalid number of public keys or signatures');\n        }\n    }\n    if (hashMode === AddressHashMode.SerializeP2WPKH || hashMode === AddressHashMode.SerializeP2WSH) {\n        for (let i = 0; i < publicKeys.length; i++) {\n            if (!isCompressed(publicKeys[i])) {\n                throw Error('Public keys must be compressed for segwit');\n            }\n        }\n    }\n    switch (hashMode) {\n        case AddressHashMode.SerializeP2PKH:\n            return addressFromVersionHash(version, hashP2PKH(publicKeys[0].data));\n        case AddressHashMode.SerializeP2WPKH:\n            return addressFromVersionHash(version, hashP2WPKH(publicKeys[0].data));\n        case AddressHashMode.SerializeP2SH:\n            return addressFromVersionHash(version, hashP2SH(numSigs, publicKeys.map(serializePublicKey)));\n        case AddressHashMode.SerializeP2WSH:\n            return addressFromVersionHash(version, hashP2WSH(numSigs, publicKeys.map(serializePublicKey)));\n    }\n}\nexport function serializeAddress(address) {\n    const bytesArray = [];\n    bytesArray.push(hexToBytes(intToHex(address.version, 1)));\n    bytesArray.push(hexToBytes(address.hash160));\n    return concatArray(bytesArray);\n}\nexport function deserializeAddress(bytesReader) {\n    const version = hexToInt(bytesToHex(bytesReader.readBytes(1)));\n    const data = bytesToHex(bytesReader.readBytes(20));\n    return { type: StacksMessageType.Address, version, hash160: data };\n}\nexport function serializePrincipal(principal) {\n    const bytesArray = [];\n    bytesArray.push(principal.prefix);\n    bytesArray.push(serializeAddress(principal.address));\n    if (principal.prefix === PostConditionPrincipalID.Contract) {\n        bytesArray.push(serializeLPString(principal.contractName));\n    }\n    return concatArray(bytesArray);\n}\nexport function deserializePrincipal(bytesReader) {\n    const prefix = bytesReader.readUInt8Enum(PostConditionPrincipalID, n => {\n        throw new DeserializationError(`Unexpected Principal payload type: ${n}`);\n    });\n    const address = deserializeAddress(bytesReader);\n    if (prefix === PostConditionPrincipalID.Standard) {\n        return { type: StacksMessageType.Principal, prefix, address };\n    }\n    const contractName = deserializeLPString(bytesReader);\n    return {\n        type: StacksMessageType.Principal,\n        prefix,\n        address,\n        contractName,\n    };\n}\nexport function serializeLPString(lps) {\n    const bytesArray = [];\n    const contentBytes = utf8ToBytes(lps.content);\n    const length = contentBytes.byteLength;\n    bytesArray.push(hexToBytes(intToHex(length, lps.lengthPrefixBytes)));\n    bytesArray.push(contentBytes);\n    return concatArray(bytesArray);\n}\nexport function deserializeLPString(bytesReader, prefixBytes, maxLength) {\n    prefixBytes = prefixBytes ? prefixBytes : 1;\n    const length = hexToInt(bytesToHex(bytesReader.readBytes(prefixBytes)));\n    const content = bytesToUtf8(bytesReader.readBytes(length));\n    return createLPString(content, prefixBytes, maxLength ?? 128);\n}\nexport function codeBodyString(content) {\n    return createLPString(content, 4, 100000);\n}\nexport function createMemoString(content) {\n    if (content && exceedsMaxLengthBytes(content, MEMO_MAX_LENGTH_BYTES)) {\n        throw new Error(`Memo exceeds maximum length of ${MEMO_MAX_LENGTH_BYTES} bytes`);\n    }\n    return { type: StacksMessageType.MemoString, content };\n}\nexport function serializeMemoString(memoString) {\n    const bytesArray = [];\n    const contentBytes = utf8ToBytes(memoString.content);\n    const paddedContent = rightPadHexToLength(bytesToHex(contentBytes), MEMO_MAX_LENGTH_BYTES * 2);\n    bytesArray.push(hexToBytes(paddedContent));\n    return concatArray(bytesArray);\n}\nexport function deserializeMemoString(bytesReader) {\n    const content = bytesToUtf8(bytesReader.readBytes(MEMO_MAX_LENGTH_BYTES));\n    return { type: StacksMessageType.MemoString, content };\n}\nexport function serializeAssetInfo(info) {\n    const bytesArray = [];\n    bytesArray.push(serializeAddress(info.address));\n    bytesArray.push(serializeLPString(info.contractName));\n    bytesArray.push(serializeLPString(info.assetName));\n    return concatArray(bytesArray);\n}\nexport function deserializeAssetInfo(bytesReader) {\n    return {\n        type: StacksMessageType.AssetInfo,\n        address: deserializeAddress(bytesReader),\n        contractName: deserializeLPString(bytesReader),\n        assetName: deserializeLPString(bytesReader),\n    };\n}\nexport function createLPList(values, lengthPrefixBytes) {\n    return {\n        type: StacksMessageType.LengthPrefixedList,\n        lengthPrefixBytes: lengthPrefixBytes || 4,\n        values,\n    };\n}\nexport function serializeLPList(lpList) {\n    const list = lpList.values;\n    const bytesArray = [];\n    bytesArray.push(hexToBytes(intToHex(list.length, lpList.lengthPrefixBytes)));\n    for (const l of list) {\n        bytesArray.push(serializeStacksMessage(l));\n    }\n    return concatArray(bytesArray);\n}\nexport function deserializeLPList(bytesReader, type, lengthPrefixBytes) {\n    const length = hexToInt(bytesToHex(bytesReader.readBytes(lengthPrefixBytes || 4)));\n    const l = [];\n    for (let index = 0; index < length; index++) {\n        switch (type) {\n            case StacksMessageType.Address:\n                l.push(deserializeAddress(bytesReader));\n                break;\n            case StacksMessageType.LengthPrefixedString:\n                l.push(deserializeLPString(bytesReader));\n                break;\n            case StacksMessageType.MemoString:\n                l.push(deserializeMemoString(bytesReader));\n                break;\n            case StacksMessageType.AssetInfo:\n                l.push(deserializeAssetInfo(bytesReader));\n                break;\n            case StacksMessageType.PostCondition:\n                l.push(deserializePostCondition(bytesReader));\n                break;\n            case StacksMessageType.PublicKey:\n                l.push(deserializePublicKey(bytesReader));\n                break;\n            case StacksMessageType.TransactionAuthField:\n                l.push(deserializeTransactionAuthField(bytesReader));\n                break;\n        }\n    }\n    return createLPList(l, lengthPrefixBytes);\n}\nexport function serializePostCondition(postCondition) {\n    const bytesArray = [];\n    bytesArray.push(postCondition.conditionType);\n    bytesArray.push(serializePrincipal(postCondition.principal));\n    if (postCondition.conditionType === PostConditionType.Fungible ||\n        postCondition.conditionType === PostConditionType.NonFungible) {\n        bytesArray.push(serializeAssetInfo(postCondition.assetInfo));\n    }\n    if (postCondition.conditionType === PostConditionType.NonFungible) {\n        bytesArray.push(serializeCV(postCondition.assetName));\n    }\n    bytesArray.push(postCondition.conditionCode);\n    if (postCondition.conditionType === PostConditionType.STX ||\n        postCondition.conditionType === PostConditionType.Fungible) {\n        bytesArray.push(intToBytes(postCondition.amount, false, 8));\n    }\n    return concatArray(bytesArray);\n}\nexport function deserializePostCondition(bytesReader) {\n    const postConditionType = bytesReader.readUInt8Enum(PostConditionType, n => {\n        throw new DeserializationError(`Could not read ${n} as PostConditionType`);\n    });\n    const principal = deserializePrincipal(bytesReader);\n    let conditionCode;\n    let assetInfo;\n    let amount;\n    switch (postConditionType) {\n        case PostConditionType.STX:\n            conditionCode = bytesReader.readUInt8Enum(FungibleConditionCode, n => {\n                throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n            });\n            amount = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);\n            return {\n                type: StacksMessageType.PostCondition,\n                conditionType: PostConditionType.STX,\n                principal,\n                conditionCode,\n                amount,\n            };\n        case PostConditionType.Fungible:\n            assetInfo = deserializeAssetInfo(bytesReader);\n            conditionCode = bytesReader.readUInt8Enum(FungibleConditionCode, n => {\n                throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n            });\n            amount = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);\n            return {\n                type: StacksMessageType.PostCondition,\n                conditionType: PostConditionType.Fungible,\n                principal,\n                conditionCode,\n                amount,\n                assetInfo,\n            };\n        case PostConditionType.NonFungible:\n            assetInfo = deserializeAssetInfo(bytesReader);\n            const assetName = deserializeCV(bytesReader);\n            conditionCode = bytesReader.readUInt8Enum(NonFungibleConditionCode, n => {\n                throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n            });\n            return {\n                type: StacksMessageType.PostCondition,\n                conditionType: PostConditionType.NonFungible,\n                principal,\n                conditionCode,\n                assetInfo,\n                assetName,\n            };\n    }\n}\n//# sourceMappingURL=types.js.map","export var ClarityType;\n(function (ClarityType) {\n    ClarityType[ClarityType[\"Int\"] = 0] = \"Int\";\n    ClarityType[ClarityType[\"UInt\"] = 1] = \"UInt\";\n    ClarityType[ClarityType[\"Buffer\"] = 2] = \"Buffer\";\n    ClarityType[ClarityType[\"BoolTrue\"] = 3] = \"BoolTrue\";\n    ClarityType[ClarityType[\"BoolFalse\"] = 4] = \"BoolFalse\";\n    ClarityType[ClarityType[\"PrincipalStandard\"] = 5] = \"PrincipalStandard\";\n    ClarityType[ClarityType[\"PrincipalContract\"] = 6] = \"PrincipalContract\";\n    ClarityType[ClarityType[\"ResponseOk\"] = 7] = \"ResponseOk\";\n    ClarityType[ClarityType[\"ResponseErr\"] = 8] = \"ResponseErr\";\n    ClarityType[ClarityType[\"OptionalNone\"] = 9] = \"OptionalNone\";\n    ClarityType[ClarityType[\"OptionalSome\"] = 10] = \"OptionalSome\";\n    ClarityType[ClarityType[\"List\"] = 11] = \"List\";\n    ClarityType[ClarityType[\"Tuple\"] = 12] = \"Tuple\";\n    ClarityType[ClarityType[\"StringASCII\"] = 13] = \"StringASCII\";\n    ClarityType[ClarityType[\"StringUTF8\"] = 14] = \"StringUTF8\";\n})(ClarityType || (ClarityType = {}));\n//# sourceMappingURL=constants.js.map","class TransactionError extends Error {\n    constructor(message) {\n        super(message);\n        this.message = message;\n        this.name = this.constructor.name;\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }\n}\nexport class SerializationError extends TransactionError {\n    constructor(message) {\n        super(message);\n    }\n}\nexport class DeserializationError extends TransactionError {\n    constructor(message) {\n        super(message);\n    }\n}\nexport class NoEstimateAvailableError extends TransactionError {\n    constructor(message) {\n        super(message);\n    }\n}\nexport class NotImplementedError extends TransactionError {\n    constructor(message) {\n        super(message);\n    }\n}\nexport class SigningError extends TransactionError {\n    constructor(message) {\n        super(message);\n    }\n}\nexport class VerificationError extends TransactionError {\n    constructor(message) {\n        super(message);\n    }\n}\n//# sourceMappingURL=errors.js.map","import { concatArray, concatBytes, bigIntToBytes, toTwos, writeUInt32BE, utf8ToBytes, asciiToBytes, } from '@stacks/common';\nimport { serializeAddress, serializeLPString } from '../types';\nimport { createLPString } from '../postcondition-types';\nimport { ClarityType } from './constants';\nimport { SerializationError } from '../errors';\nimport { CLARITY_INT_BYTE_SIZE, CLARITY_INT_SIZE } from '../constants';\nfunction bytesWithTypeID(typeId, bytes) {\n    return concatArray([typeId, bytes]);\n}\nfunction serializeBoolCV(value) {\n    return new Uint8Array([value.type]);\n}\nfunction serializeOptionalCV(cv) {\n    if (cv.type === ClarityType.OptionalNone) {\n        return new Uint8Array([cv.type]);\n    }\n    else {\n        return bytesWithTypeID(cv.type, serializeCV(cv.value));\n    }\n}\nfunction serializeBufferCV(cv) {\n    const length = new Uint8Array(4);\n    writeUInt32BE(length, cv.buffer.length, 0);\n    return bytesWithTypeID(cv.type, concatBytes(length, cv.buffer));\n}\nfunction serializeIntCV(cv) {\n    const bytes = bigIntToBytes(toTwos(cv.value, BigInt(CLARITY_INT_SIZE)), CLARITY_INT_BYTE_SIZE);\n    return bytesWithTypeID(cv.type, bytes);\n}\nfunction serializeUIntCV(cv) {\n    const bytes = bigIntToBytes(cv.value, CLARITY_INT_BYTE_SIZE);\n    return bytesWithTypeID(cv.type, bytes);\n}\nfunction serializeStandardPrincipalCV(cv) {\n    return bytesWithTypeID(cv.type, serializeAddress(cv.address));\n}\nfunction serializeContractPrincipalCV(cv) {\n    return bytesWithTypeID(cv.type, concatBytes(serializeAddress(cv.address), serializeLPString(cv.contractName)));\n}\nfunction serializeResponseCV(cv) {\n    return bytesWithTypeID(cv.type, serializeCV(cv.value));\n}\nfunction serializeListCV(cv) {\n    const bytesArray = [];\n    const length = new Uint8Array(4);\n    writeUInt32BE(length, cv.list.length, 0);\n    bytesArray.push(length);\n    for (const value of cv.list) {\n        const serializedValue = serializeCV(value);\n        bytesArray.push(serializedValue);\n    }\n    return bytesWithTypeID(cv.type, concatArray(bytesArray));\n}\nfunction serializeTupleCV(cv) {\n    const bytesArray = [];\n    const length = new Uint8Array(4);\n    writeUInt32BE(length, Object.keys(cv.data).length, 0);\n    bytesArray.push(length);\n    const lexicographicOrder = Object.keys(cv.data).sort((a, b) => a.localeCompare(b));\n    for (const key of lexicographicOrder) {\n        const nameWithLength = createLPString(key);\n        bytesArray.push(serializeLPString(nameWithLength));\n        const serializedValue = serializeCV(cv.data[key]);\n        bytesArray.push(serializedValue);\n    }\n    return bytesWithTypeID(cv.type, concatArray(bytesArray));\n}\nfunction serializeStringCV(cv, encoding) {\n    const bytesArray = [];\n    const str = encoding == 'ascii' ? asciiToBytes(cv.data) : utf8ToBytes(cv.data);\n    const len = new Uint8Array(4);\n    writeUInt32BE(len, str.length, 0);\n    bytesArray.push(len);\n    bytesArray.push(str);\n    return bytesWithTypeID(cv.type, concatArray(bytesArray));\n}\nfunction serializeStringAsciiCV(cv) {\n    return serializeStringCV(cv, 'ascii');\n}\nfunction serializeStringUtf8CV(cv) {\n    return serializeStringCV(cv, 'utf8');\n}\nexport function serializeCV(value) {\n    switch (value.type) {\n        case ClarityType.BoolTrue:\n        case ClarityType.BoolFalse:\n            return serializeBoolCV(value);\n        case ClarityType.OptionalNone:\n        case ClarityType.OptionalSome:\n            return serializeOptionalCV(value);\n        case ClarityType.Buffer:\n            return serializeBufferCV(value);\n        case ClarityType.UInt:\n            return serializeUIntCV(value);\n        case ClarityType.Int:\n            return serializeIntCV(value);\n        case ClarityType.PrincipalStandard:\n            return serializeStandardPrincipalCV(value);\n        case ClarityType.PrincipalContract:\n            return serializeContractPrincipalCV(value);\n        case ClarityType.ResponseOk:\n        case ClarityType.ResponseErr:\n            return serializeResponseCV(value);\n        case ClarityType.List:\n            return serializeListCV(value);\n        case ClarityType.Tuple:\n            return serializeTupleCV(value);\n        case ClarityType.StringASCII:\n            return serializeStringAsciiCV(value);\n        case ClarityType.StringUTF8:\n            return serializeStringUtf8CV(value);\n        default:\n            throw new SerializationError('Unable to serialize. Invalid Clarity Value.');\n    }\n}\n//# sourceMappingURL=serialize.js.map","import assert from './_assert.js';\nimport { Hash, toBytes } from './utils.js';\n// HMAC (RFC 2104)\nclass HMAC extends Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        assert.hash(hash);\n        const key = toBytes(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new TypeError('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        assert.exists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        assert.exists(this);\n        assert.bytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nexport const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n","import { hexToBytes } from './utils';\nexport function privateKeyToBytes(privateKey) {\n    const privateKeyBuffer = typeof privateKey === 'string' ? hexToBytes(privateKey) : privateKey;\n    if (privateKeyBuffer.length != 32 && privateKeyBuffer.length != 33) {\n        throw new Error(`Improperly formatted private-key. Private-key byte length should be 32 or 33. Length provided: ${privateKeyBuffer.length}`);\n    }\n    if (privateKeyBuffer.length == 33 && privateKeyBuffer[32] !== 1) {\n        throw new Error('Improperly formatted private-key. 33 bytes indicate compressed key, but the last byte must be == 01');\n    }\n    return privateKeyBuffer;\n}\n//# sourceMappingURL=keys.js.map","export var ChainID;\n(function (ChainID) {\n    ChainID[ChainID[\"Testnet\"] = 2147483648] = \"Testnet\";\n    ChainID[ChainID[\"Mainnet\"] = 1] = \"Mainnet\";\n})(ChainID || (ChainID = {}));\nexport var TransactionVersion;\n(function (TransactionVersion) {\n    TransactionVersion[TransactionVersion[\"Mainnet\"] = 0] = \"Mainnet\";\n    TransactionVersion[TransactionVersion[\"Testnet\"] = 128] = \"Testnet\";\n})(TransactionVersion || (TransactionVersion = {}));\nexport const PRIVATE_KEY_COMPRESSED_LENGTH = 33;\nexport const PRIVATE_KEY_UNCOMPRESSED_LENGTH = 32;\nexport const BLOCKSTACK_DEFAULT_GAIA_HUB_URL = 'https://hub.blockstack.org';\n//# sourceMappingURL=constants.js.map","import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { getPublicKey as nobleGetPublicKey, Point, Signature, signSync, utils, } from '@noble/secp256k1';\nimport { bytesToHex, concatArray, hexToBigInt, hexToBytes, intToHex, parseRecoverableSignatureVrs, privateKeyToBytes, PRIVATE_KEY_COMPRESSED_LENGTH, signatureRsvToVrs, signatureVrsToRsv, } from '@stacks/common';\nimport { c32address } from 'c32check';\nimport { addressFromVersionHash, addressHashModeToVersion, addressToString, createMessageSignature, } from './common';\nimport { AddressHashMode, COMPRESSED_PUBKEY_LENGTH_BYTES, PubKeyEncoding, StacksMessageType, TransactionVersion, UNCOMPRESSED_PUBKEY_LENGTH_BYTES, } from './constants';\nimport { hash160, hashP2PKH } from './utils';\nutils.hmacSha256Sync = (key, ...msgs) => {\n    const h = hmac.create(sha256, key);\n    msgs.forEach(msg => h.update(msg));\n    return h.digest();\n};\nexport function getAddressFromPrivateKey(privateKey, transactionVersion = TransactionVersion.Mainnet) {\n    const pubKey = pubKeyfromPrivKey(privateKey);\n    return getAddressFromPublicKey(pubKey.data, transactionVersion);\n}\nexport function getAddressFromPublicKey(publicKey, transactionVersion = TransactionVersion.Mainnet) {\n    publicKey = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);\n    const addrVer = addressHashModeToVersion(AddressHashMode.SerializeP2PKH, transactionVersion);\n    const addr = addressFromVersionHash(addrVer, hashP2PKH(hexToBytes(publicKey)));\n    const addrString = addressToString(addr);\n    return addrString;\n}\nexport function createStacksPublicKey(key) {\n    return {\n        type: StacksMessageType.PublicKey,\n        data: hexToBytes(key),\n    };\n}\nexport function publicKeyFromSignatureVrs(messageHash, messageSignature, pubKeyEncoding = PubKeyEncoding.Compressed) {\n    const parsedSignature = parseRecoverableSignatureVrs(messageSignature.data);\n    const signature = new Signature(hexToBigInt(parsedSignature.r), hexToBigInt(parsedSignature.s));\n    const point = Point.fromSignature(messageHash, signature, parsedSignature.recoveryId);\n    const compressed = pubKeyEncoding === PubKeyEncoding.Compressed;\n    return point.toHex(compressed);\n}\nexport function publicKeyFromSignatureRsv(messageHash, messageSignature, pubKeyEncoding = PubKeyEncoding.Compressed) {\n    return publicKeyFromSignatureVrs(messageHash, { ...messageSignature, data: signatureRsvToVrs(messageSignature.data) }, pubKeyEncoding);\n}\nexport function publicKeyFromBytes(data) {\n    return { type: StacksMessageType.PublicKey, data };\n}\nexport function isCompressed(key) {\n    return !bytesToHex(key.data).startsWith('04');\n}\nexport function publicKeyToString(key) {\n    return bytesToHex(key.data);\n}\nexport function serializePublicKey(key) {\n    return key.data.slice();\n}\nexport function pubKeyfromPrivKey(privateKey) {\n    const privKey = createStacksPrivateKey(privateKey);\n    const publicKey = nobleGetPublicKey(privKey.data.slice(0, 32), privKey.compressed);\n    return createStacksPublicKey(bytesToHex(publicKey));\n}\nexport function compressPublicKey(publicKey) {\n    const hex = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);\n    const compressed = Point.fromHex(hex).toHex(true);\n    return createStacksPublicKey(compressed);\n}\nexport function deserializePublicKey(bytesReader) {\n    const fieldId = bytesReader.readUInt8();\n    const keyLength = fieldId === 4 ? UNCOMPRESSED_PUBKEY_LENGTH_BYTES : COMPRESSED_PUBKEY_LENGTH_BYTES;\n    return publicKeyFromBytes(concatArray([fieldId, bytesReader.readBytes(keyLength)]));\n}\nexport function createStacksPrivateKey(key) {\n    const data = privateKeyToBytes(key);\n    const compressed = data.length == PRIVATE_KEY_COMPRESSED_LENGTH;\n    return { data, compressed };\n}\nexport function makeRandomPrivKey() {\n    return createStacksPrivateKey(utils.randomPrivateKey());\n}\nexport function signWithKey(privateKey, messageHash) {\n    const [rawSignature, recoveryId] = signSync(messageHash, privateKey.data.slice(0, 32), {\n        canonical: true,\n        recovered: true,\n    });\n    if (recoveryId == null) {\n        throw new Error('No signature recoveryId received');\n    }\n    const recoveryIdHex = intToHex(recoveryId, 1);\n    const recoverableSignatureString = recoveryIdHex + Signature.fromHex(rawSignature).toCompactHex();\n    return createMessageSignature(recoverableSignatureString);\n}\nexport function signMessageHashRsv({ messageHash, privateKey, }) {\n    const messageSignature = signWithKey(privateKey, messageHash);\n    return { ...messageSignature, data: signatureVrsToRsv(messageSignature.data) };\n}\nexport function getPublicKey(privateKey) {\n    return pubKeyfromPrivKey(privateKey.data);\n}\nexport function privateKeyToString(privateKey) {\n    return bytesToHex(privateKey.data);\n}\nexport function publicKeyToAddress(version, publicKey) {\n    return c32address(version, bytesToHex(hash160(publicKey.data)));\n}\n//# sourceMappingURL=keys.js.map","import { AddressHashMode, AddressVersion, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType, TransactionVersion, } from './constants';\nimport { c32address } from 'c32check';\nimport { hexToBytes } from '@stacks/common';\nexport function createMessageSignature(signature) {\n    const length = hexToBytes(signature).byteLength;\n    if (length != RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {\n        throw Error('Invalid signature');\n    }\n    return {\n        type: StacksMessageType.MessageSignature,\n        data: signature,\n    };\n}\nexport function addressHashModeToVersion(hashMode, txVersion) {\n    switch (hashMode) {\n        case AddressHashMode.SerializeP2PKH:\n            switch (txVersion) {\n                case TransactionVersion.Mainnet:\n                    return AddressVersion.MainnetSingleSig;\n                case TransactionVersion.Testnet:\n                    return AddressVersion.TestnetSingleSig;\n                default:\n                    throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);\n            }\n        case AddressHashMode.SerializeP2SH:\n        case AddressHashMode.SerializeP2WPKH:\n        case AddressHashMode.SerializeP2WSH:\n            switch (txVersion) {\n                case TransactionVersion.Mainnet:\n                    return AddressVersion.MainnetMultiSig;\n                case TransactionVersion.Testnet:\n                    return AddressVersion.TestnetMultiSig;\n                default:\n                    throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);\n            }\n        default:\n            throw new Error(`Unexpected hashMode ${JSON.stringify(hashMode)}`);\n    }\n}\nexport function addressFromVersionHash(version, hash) {\n    return { type: StacksMessageType.Address, version, hash160: hash };\n}\nexport function addressToString(address) {\n    return c32address(address.version, address.hash160);\n}\n//# sourceMappingURL=common.js.map","import { Logger } from './logger';\nexport const BLOCKSTACK_HANDLER = 'blockstack';\nexport function nextYear() {\n    return new Date(new Date().setFullYear(new Date().getFullYear() + 1));\n}\nexport function nextMonth() {\n    return new Date(new Date().setMonth(new Date().getMonth() + 1));\n}\nexport function nextHour() {\n    return new Date(new Date().setHours(new Date().getHours() + 1));\n}\nexport function megabytesToBytes(megabytes) {\n    if (!Number.isFinite(megabytes)) {\n        return 0;\n    }\n    return Math.floor(megabytes * 1024 * 1024);\n}\nexport function getAesCbcOutputLength(inputByteLength) {\n    const cipherTextLength = (Math.floor(inputByteLength / 16) + 1) * 16;\n    return cipherTextLength;\n}\nexport function getBase64OutputLength(inputByteLength) {\n    const encodedLength = Math.ceil(inputByteLength / 3) * 4;\n    return encodedLength;\n}\nexport function updateQueryStringParameter(uri, key, value) {\n    const re = new RegExp(`([?&])${key}=.*?(&|$)`, 'i');\n    const separator = uri.indexOf('?') !== -1 ? '&' : '?';\n    if (uri.match(re)) {\n        return uri.replace(re, `$1${key}=${value}$2`);\n    }\n    else {\n        return `${uri}${separator}${key}=${value}`;\n    }\n}\nexport function isLaterVersion(v1, v2) {\n    if (v1 === undefined || v1 === '') {\n        v1 = '0.0.0';\n    }\n    if (v2 === undefined || v1 === '') {\n        v2 = '0.0.0';\n    }\n    const v1tuple = v1.split('.').map(x => parseInt(x, 10));\n    const v2tuple = v2.split('.').map(x => parseInt(x, 10));\n    for (let index = 0; index < v2.length; index++) {\n        if (index >= v1.length) {\n            v2tuple.push(0);\n        }\n        if (v1tuple[index] < v2tuple[index]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function makeUUID4() {\n    let d = new Date().getTime();\n    if (typeof performance !== 'undefined' && typeof performance.now === 'function') {\n        d += performance.now();\n    }\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n        const r = (d + Math.random() * 16) % 16 | 0;\n        d = Math.floor(d / 16);\n        return (c === 'x' ? r : (r & 0x3) | 0x8).toString(16);\n    });\n}\nexport function isSameOriginAbsoluteUrl(uri1, uri2) {\n    try {\n        const parsedUri1 = new URL(uri1);\n        const parsedUri2 = new URL(uri2);\n        const port1 = parseInt(parsedUri1.port || '0', 10) | 0 || (parsedUri1.protocol === 'https:' ? 443 : 80);\n        const port2 = parseInt(parsedUri2.port || '0', 10) | 0 || (parsedUri2.protocol === 'https:' ? 443 : 80);\n        const match = {\n            scheme: parsedUri1.protocol === parsedUri2.protocol,\n            hostname: parsedUri1.hostname === parsedUri2.hostname,\n            port: port1 === port2,\n            absolute: (uri1.includes('http://') || uri1.includes('https://')) &&\n                (uri2.includes('http://') || uri2.includes('https://')),\n        };\n        return match.scheme && match.hostname && match.port && match.absolute;\n    }\n    catch (error) {\n        console.log(error);\n        console.log('Parsing error in same URL origin check');\n        return false;\n    }\n}\nexport function getGlobalScope() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('Unexpected runtime environment - no supported global scope (`window`, `self`, `global`) available');\n}\nfunction getAPIUsageErrorMessage(scopeObject, apiName, usageDesc) {\n    if (usageDesc) {\n        return `Use of '${usageDesc}' requires \\`${apiName}\\` which is unavailable on the '${scopeObject}' object within the currently executing environment.`;\n    }\n    else {\n        return `\\`${apiName}\\` is unavailable on the '${scopeObject}' object within the currently executing environment.`;\n    }\n}\nexport function getGlobalObject(name, { throwIfUnavailable, usageDesc, returnEmptyObject } = {}) {\n    let globalScope = undefined;\n    try {\n        globalScope = getGlobalScope();\n        if (globalScope) {\n            const obj = globalScope[name];\n            if (obj) {\n                return obj;\n            }\n        }\n    }\n    catch (error) {\n        Logger.error(`Error getting object '${name}' from global scope '${globalScope}': ${error}`);\n    }\n    if (throwIfUnavailable) {\n        const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n        Logger.error(errMsg);\n        throw new Error(errMsg);\n    }\n    if (returnEmptyObject) {\n        return {};\n    }\n    return undefined;\n}\nexport function getGlobalObjects(names, { throwIfUnavailable, usageDesc, returnEmptyObject } = {}) {\n    let globalScope;\n    try {\n        globalScope = getGlobalScope();\n    }\n    catch (error) {\n        Logger.error(`Error getting global scope: ${error}`);\n        if (throwIfUnavailable) {\n            const errMsg = getAPIUsageErrorMessage(globalScope, names[0].toString(), usageDesc);\n            Logger.error(errMsg);\n            throw errMsg;\n        }\n        else if (returnEmptyObject) {\n            globalScope = {};\n        }\n    }\n    const result = {};\n    for (let i = 0; i < names.length; i++) {\n        const name = names[i];\n        try {\n            if (globalScope) {\n                const obj = globalScope[name];\n                if (obj) {\n                    result[name] = obj;\n                }\n                else if (throwIfUnavailable) {\n                    const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n                    Logger.error(errMsg);\n                    throw new Error(errMsg);\n                }\n                else if (returnEmptyObject) {\n                    result[name] = {};\n                }\n            }\n        }\n        catch (error) {\n            if (throwIfUnavailable) {\n                const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n                Logger.error(errMsg);\n                throw new Error(errMsg);\n            }\n        }\n    }\n    return result;\n}\nexport function intToBytes(value, signed, byteLength) {\n    return bigIntToBytes(intToBigInt(value, signed), byteLength);\n}\nexport function intToBigInt(value, signed) {\n    let parsedValue = value;\n    if (typeof parsedValue === 'number') {\n        if (!Number.isInteger(parsedValue)) {\n            throw new RangeError(`Invalid value. Values of type 'number' must be an integer.`);\n        }\n        if (parsedValue > Number.MAX_SAFE_INTEGER) {\n            throw new RangeError(`Invalid value. Values of type 'number' must be less than or equal to ${Number.MAX_SAFE_INTEGER}. For larger values, try using a BigInt instead.`);\n        }\n        return BigInt(parsedValue);\n    }\n    if (typeof parsedValue === 'string') {\n        if (parsedValue.toLowerCase().startsWith('0x')) {\n            let hex = parsedValue.slice(2);\n            hex = hex.padStart(hex.length + (hex.length % 2), '0');\n            parsedValue = hexToBytes(hex);\n        }\n        else {\n            try {\n                return BigInt(parsedValue);\n            }\n            catch (error) {\n                if (error instanceof SyntaxError) {\n                    throw new RangeError(`Invalid value. String integer '${parsedValue}' is not finite.`);\n                }\n            }\n        }\n    }\n    if (typeof parsedValue === 'bigint') {\n        return parsedValue;\n    }\n    if (parsedValue instanceof Uint8Array) {\n        if (signed) {\n            const bn = fromTwos(BigInt(`0x${bytesToHex(parsedValue)}`), BigInt(parsedValue.byteLength * 8));\n            return BigInt(bn.toString());\n        }\n        else {\n            return BigInt(`0x${bytesToHex(parsedValue)}`);\n        }\n    }\n    if (parsedValue != null &&\n        typeof parsedValue === 'object' &&\n        parsedValue.constructor.name === 'BN') {\n        return BigInt(parsedValue.toString());\n    }\n    throw new TypeError(`Invalid value type. Must be a number, bigint, integer-string, hex-string, or Uint8Array.`);\n}\nexport function with0x(value) {\n    return value.startsWith('0x') ? value : `0x${value}`;\n}\nexport function hexToBigInt(hex) {\n    if (typeof hex !== 'string')\n        throw new TypeError(`hexToBigInt: expected string, got ${typeof hex}`);\n    return BigInt(`0x${hex}`);\n}\nexport function intToHex(integer, lengthBytes = 8) {\n    const value = typeof integer === 'bigint' ? integer : intToBigInt(integer, false);\n    return value.toString(16).padStart(lengthBytes * 2, '0');\n}\nexport function hexToInt(hex) {\n    return parseInt(hex, 16);\n}\nexport function bigIntToBytes(value, length = 16) {\n    const hex = intToHex(value, length);\n    return hexToBytes(hex);\n}\nexport function toTwos(value, width) {\n    if (value < -(BigInt(1) << (width - BigInt(1))) ||\n        (BigInt(1) << (width - BigInt(1))) - BigInt(1) < value) {\n        throw `Unable to represent integer in width: ${width}`;\n    }\n    if (value >= BigInt(0)) {\n        return BigInt(value);\n    }\n    return value + (BigInt(1) << width);\n}\nfunction nthBit(value, n) {\n    return value & (BigInt(1) << n);\n}\nexport function fromTwos(value, width) {\n    if (nthBit(value, width - BigInt(1))) {\n        return value - (BigInt(1) << width);\n    }\n    return value;\n}\nconst hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\nexport function bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n    let hex = '';\n    for (const u of uint8a) {\n        hex += hexes[u];\n    }\n    return hex;\n}\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError(`hexToBytes: expected string, got ${typeof hex}`);\n    }\n    const paddedHex = hex.length % 2 ? `0${hex}` : hex;\n    const array = new Uint8Array(paddedHex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = paddedHex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nexport function utf8ToBytes(str) {\n    return new TextEncoder().encode(str);\n}\nexport function bytesToUtf8(arr) {\n    return new TextDecoder().decode(arr);\n}\nexport function asciiToBytes(str) {\n    const byteArray = [];\n    for (let i = 0; i < str.length; i++) {\n        byteArray.push(str.charCodeAt(i) & 0xff);\n    }\n    return new Uint8Array(byteArray);\n}\nexport function bytesToAscii(arr) {\n    return String.fromCharCode.apply(null, arr);\n}\nfunction isNotOctet(octet) {\n    return !Number.isInteger(octet) || octet < 0 || octet > 255;\n}\nexport function octetsToBytes(numbers) {\n    if (numbers.some(isNotOctet))\n        throw new Error('Some values are invalid bytes.');\n    return new Uint8Array(numbers);\n}\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        return utf8ToBytes(data);\n    if (data instanceof Uint8Array)\n        return data;\n    throw new TypeError(`Expected input type is (Uint8Array | string) but got (${typeof data})`);\n}\nexport function concatBytes(...arrays) {\n    if (!arrays.every(a => a instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nexport function concatArray(elements) {\n    return concatBytes(...elements.map(e => {\n        if (typeof e === 'number')\n            return octetsToBytes([e]);\n        if (e instanceof Array)\n            return octetsToBytes(e);\n        return e;\n    }));\n}\nexport function isInstance(object, type) {\n    return object instanceof type || object?.constructor?.name?.toLowerCase() === type.name;\n}\n//# sourceMappingURL=utils.js.map","import { utf8ToBytes } from '@stacks/common';\nimport { addressToString } from '../../common';\nimport { createAddress, createLPString } from '../../postcondition-types';\nimport { ClarityType } from '../constants';\nfunction principalToString(principal) {\n    if (principal.type === ClarityType.PrincipalStandard) {\n        return addressToString(principal.address);\n    }\n    else if (principal.type === ClarityType.PrincipalContract) {\n        const address = addressToString(principal.address);\n        return `${address}.${principal.contractName.content}`;\n    }\n    else {\n        throw new Error(`Unexpected principal data: ${JSON.stringify(principal)}`);\n    }\n}\nfunction principalCV(principal) {\n    if (principal.includes('.')) {\n        const [address, contractName] = principal.split('.');\n        return contractPrincipalCV(address, contractName);\n    }\n    else {\n        return standardPrincipalCV(principal);\n    }\n}\nfunction standardPrincipalCV(addressString) {\n    const addr = createAddress(addressString);\n    return { type: ClarityType.PrincipalStandard, address: addr };\n}\nfunction standardPrincipalCVFromAddress(address) {\n    return { type: ClarityType.PrincipalStandard, address };\n}\nfunction contractPrincipalCV(addressString, contractName) {\n    const addr = createAddress(addressString);\n    const lengthPrefixedContractName = createLPString(contractName);\n    return contractPrincipalCVFromAddress(addr, lengthPrefixedContractName);\n}\nfunction contractPrincipalCVFromAddress(address, contractName) {\n    if (utf8ToBytes(contractName.content).byteLength >= 128) {\n        throw new Error('Contract name must be less than 128 bytes');\n    }\n    return { type: ClarityType.PrincipalContract, address, contractName };\n}\nfunction contractPrincipalCVFromStandard(sp, contractName) {\n    const lengthPrefixedContractName = createLPString(contractName);\n    return {\n        type: ClarityType.PrincipalContract,\n        address: sp.address,\n        contractName: lengthPrefixedContractName,\n    };\n}\nexport { principalCV, principalToString, standardPrincipalCV, standardPrincipalCVFromAddress, contractPrincipalCV, contractPrincipalCVFromAddress, contractPrincipalCVFromStandard, };\n//# sourceMappingURL=principalCV.js.map","import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { getPublicKey as nobleGetPublicKey, signSync, utils } from '@noble/secp256k1';\nimport { bytesToHex, concatBytes, hexToBytes, privateKeyToBytes, PRIVATE_KEY_COMPRESSED_LENGTH, readUInt8, } from '@stacks/common';\nimport base58 from 'bs58';\nimport { hashRipemd160 } from './hashRipemd160';\nimport { hashSha256Sync } from './sha2Hash';\nconst BITCOIN_PUBKEYHASH = 0x00;\nutils.hmacSha256Sync = (key, ...msgs) => {\n    const h = hmac.create(sha256, key);\n    msgs.forEach(msg => h.update(msg));\n    return h.digest();\n};\nexport function makeECPrivateKey() {\n    return bytesToHex(utils.randomPrivateKey());\n}\nexport function base58CheckDecode(btcAddress) {\n    const bytes = base58.decode(btcAddress);\n    const payload = bytes.slice(0, -4);\n    const checksum = bytes.slice(-4);\n    const newChecksum = sha256(sha256(payload));\n    if ((checksum[0] ^ newChecksum[0]) |\n        (checksum[1] ^ newChecksum[1]) |\n        (checksum[2] ^ newChecksum[2]) |\n        (checksum[3] ^ newChecksum[3])) {\n        throw new Error('Invalid checksum');\n    }\n    if (payload.length !== 21)\n        throw new TypeError('Invalid address length');\n    const version = readUInt8(payload, 0);\n    const hash = payload.slice(1);\n    return { version, hash };\n}\nexport function base58Encode(hash) {\n    const checksum = sha256(sha256(hash));\n    return base58.encode(concatBytes(hash, checksum).slice(0, hash.length + 4));\n}\nexport function base58CheckEncode(version, hash) {\n    return base58Encode(concatBytes(new Uint8Array([version]), hash.slice(0, 20)));\n}\nexport function publicKeyToBtcAddress(publicKey, version = BITCOIN_PUBKEYHASH) {\n    const publicKeyBytes = typeof publicKey === 'string' ? hexToBytes(publicKey) : publicKey;\n    const publicKeyHash160 = hashRipemd160(hashSha256Sync(publicKeyBytes));\n    return base58CheckEncode(version, publicKeyHash160);\n}\nexport function getPublicKeyFromPrivate(privateKey) {\n    const privateKeyBytes = privateKeyToBytes(privateKey);\n    return bytesToHex(nobleGetPublicKey(privateKeyBytes.slice(0, 32), true));\n}\nexport function ecSign(messageHash, hexPrivateKey) {\n    return signSync(messageHash, privateKeyToBytes(hexPrivateKey).slice(0, 32), {\n        der: false,\n    });\n}\nexport function isValidPrivateKey(privateKey) {\n    return utils.isValidPrivateKey(privateKeyToBytes(privateKey));\n}\nexport function compressPrivateKey(privateKey) {\n    const privateKeyBytes = privateKeyToBytes(privateKey);\n    return privateKeyBytes.length == PRIVATE_KEY_COMPRESSED_LENGTH\n        ? privateKeyBytes\n        : concatBytes(privateKeyBytes, new Uint8Array([1]));\n}\n//# sourceMappingURL=keys.js.map","import { intToBigInt } from '@stacks/common';\nimport { ClarityType } from '../constants';\nconst MAX_U128 = BigInt('0xffffffffffffffffffffffffffffffff');\nconst MIN_U128 = BigInt(0);\nconst MAX_I128 = BigInt('0x7fffffffffffffffffffffffffffffff');\nconst MIN_I128 = BigInt('-170141183460469231731687303715884105728');\nconst intCV = (value) => {\n    const bigInt = intToBigInt(value, true);\n    if (bigInt > MAX_I128) {\n        throw new RangeError(`Cannot construct clarity integer from value greater than ${MAX_I128}`);\n    }\n    else if (bigInt < MIN_I128) {\n        throw new RangeError(`Cannot construct clarity integer form value less than ${MIN_I128}`);\n    }\n    return { type: ClarityType.Int, value: bigInt };\n};\nconst uintCV = (value) => {\n    const bigInt = intToBigInt(value, false);\n    if (bigInt < MIN_U128) {\n        throw new RangeError('Cannot construct unsigned clarity integer from negative value');\n    }\n    else if (bigInt > MAX_U128) {\n        throw new RangeError(`Cannot construct unsigned clarity integer greater than ${MAX_U128}`);\n    }\n    return { type: ClarityType.UInt, value: bigInt };\n};\nexport { intCV, uintCV };\n//# sourceMappingURL=intCV.js.map","import { bytesToHex, readUInt16BE, readUInt32BE, readUInt8 } from '@stacks/common';\nfunction createEnumChecker(enumVariable) {\n    const enumValues = Object.values(enumVariable).filter(v => typeof v === 'number');\n    const enumValueSet = new Set(enumValues);\n    return (value) => enumValueSet.has(value);\n}\nconst enumCheckFunctions = new Map();\nexport function isEnum(enumVariable, value) {\n    const checker = enumCheckFunctions.get(enumVariable);\n    if (checker !== undefined) {\n        return checker(value);\n    }\n    const newChecker = createEnumChecker(enumVariable);\n    enumCheckFunctions.set(enumVariable, newChecker);\n    return isEnum(enumVariable, value);\n}\nexport class BytesReader {\n    constructor(arr) {\n        this.consumed = 0;\n        this.source = arr;\n    }\n    readBytes(length) {\n        const view = this.source.subarray(this.consumed, this.consumed + length);\n        this.consumed += length;\n        return view;\n    }\n    readUInt32BE() {\n        return readUInt32BE(this.readBytes(4), 0);\n    }\n    readUInt8() {\n        return readUInt8(this.readBytes(1), 0);\n    }\n    readUInt16BE() {\n        return readUInt16BE(this.readBytes(2), 0);\n    }\n    readBigUIntLE(length) {\n        const bytes = this.readBytes(length).slice().reverse();\n        const hex = bytesToHex(bytes);\n        return BigInt(`0x${hex}`);\n    }\n    readBigUIntBE(length) {\n        const bytes = this.readBytes(length);\n        const hex = bytesToHex(bytes);\n        return BigInt(`0x${hex}`);\n    }\n    get readOffset() {\n        return this.consumed;\n    }\n    set readOffset(val) {\n        this.consumed = val;\n    }\n    get internalBytes() {\n        return this.source;\n    }\n    readUInt8Enum(enumVariable, invalidEnumErrorFormatter) {\n        const num = this.readUInt8();\n        if (isEnum(enumVariable, num)) {\n            return num;\n        }\n        throw invalidEnumErrorFormatter(num);\n    }\n}\n//# sourceMappingURL=bytesReader.js.map","import { ClarityType } from '../constants';\nconst stringAsciiCV = (data) => {\n    return { type: ClarityType.StringASCII, data };\n};\nconst stringUtf8CV = (data) => {\n    return { type: ClarityType.StringUTF8, data };\n};\nconst stringCV = (data, encoding) => {\n    switch (encoding) {\n        case 'ascii':\n            return stringAsciiCV(data);\n        case 'utf8':\n            return stringUtf8CV(data);\n    }\n};\nexport { stringAsciiCV, stringUtf8CV, stringCV };\n//# sourceMappingURL=stringCV.js.map","import { asciiToBytes, hexToBytes, utf8ToBytes } from '@stacks/common';\nimport { boolCV, bufferCV, contractPrincipalCV, deserializeCV, intCV, listCV, noneCV, responseErrorCV, responseOkCV, serializeCV, someCV, standardPrincipalCV, stringAsciiCV, stringUtf8CV, tupleCV, uintCV, } from './clarity';\nexport const bool = boolCV;\nexport const int = intCV;\nexport const uint = uintCV;\nexport const contractPrincipal = contractPrincipalCV;\nexport const standardPrincipal = standardPrincipalCV;\nexport const list = listCV;\nexport const stringAscii = stringAsciiCV;\nexport const stringUtf8 = stringUtf8CV;\nexport const buffer = bufferCV;\nexport const bufferFromHex = (hex) => bufferCV(hexToBytes(hex));\nexport const bufferFromAscii = (ascii) => bufferCV(asciiToBytes(ascii));\nexport const bufferFromUtf8 = (utf8) => bufferCV(utf8ToBytes(utf8));\nexport const none = noneCV;\nexport const some = someCV;\nexport const ok = responseOkCV;\nexport const error = responseErrorCV;\nexport const tuple = tupleCV;\nexport const serialize = serializeCV;\nexport const deserialize = deserializeCV;\n//# sourceMappingURL=cl.js.map","import { ClarityType, intCV, uintCV, bufferCV, trueCV, falseCV, standardPrincipalCVFromAddress, contractPrincipalCVFromAddress, responseOkCV, responseErrorCV, noneCV, someCV, listCV, tupleCV, } from '.';\nimport { BytesReader as BytesReader } from '../bytesReader';\nimport { deserializeAddress, deserializeLPString } from '../types';\nimport { DeserializationError } from '../errors';\nimport { stringAsciiCV, stringUtf8CV } from './types/stringCV';\nimport { bytesToAscii, bytesToUtf8, hexToBytes } from '@stacks/common';\nexport default function deserializeCV(serializedClarityValue) {\n    let bytesReader;\n    if (typeof serializedClarityValue === 'string') {\n        const hasHexPrefix = serializedClarityValue.slice(0, 2).toLowerCase() === '0x';\n        bytesReader = new BytesReader(hexToBytes(hasHexPrefix ? serializedClarityValue.slice(2) : serializedClarityValue));\n    }\n    else if (serializedClarityValue instanceof Uint8Array) {\n        bytesReader = new BytesReader(serializedClarityValue);\n    }\n    else {\n        bytesReader = serializedClarityValue;\n    }\n    const type = bytesReader.readUInt8Enum(ClarityType, n => {\n        throw new DeserializationError(`Cannot recognize Clarity Type: ${n}`);\n    });\n    switch (type) {\n        case ClarityType.Int:\n            return intCV(bytesReader.readBytes(16));\n        case ClarityType.UInt:\n            return uintCV(bytesReader.readBytes(16));\n        case ClarityType.Buffer:\n            const bufferLength = bytesReader.readUInt32BE();\n            return bufferCV(bytesReader.readBytes(bufferLength));\n        case ClarityType.BoolTrue:\n            return trueCV();\n        case ClarityType.BoolFalse:\n            return falseCV();\n        case ClarityType.PrincipalStandard:\n            const sAddress = deserializeAddress(bytesReader);\n            return standardPrincipalCVFromAddress(sAddress);\n        case ClarityType.PrincipalContract:\n            const cAddress = deserializeAddress(bytesReader);\n            const contractName = deserializeLPString(bytesReader);\n            return contractPrincipalCVFromAddress(cAddress, contractName);\n        case ClarityType.ResponseOk:\n            return responseOkCV(deserializeCV(bytesReader));\n        case ClarityType.ResponseErr:\n            return responseErrorCV(deserializeCV(bytesReader));\n        case ClarityType.OptionalNone:\n            return noneCV();\n        case ClarityType.OptionalSome:\n            return someCV(deserializeCV(bytesReader));\n        case ClarityType.List:\n            const listLength = bytesReader.readUInt32BE();\n            const listContents = [];\n            for (let i = 0; i < listLength; i++) {\n                listContents.push(deserializeCV(bytesReader));\n            }\n            return listCV(listContents);\n        case ClarityType.Tuple:\n            const tupleLength = bytesReader.readUInt32BE();\n            const tupleContents = {};\n            for (let i = 0; i < tupleLength; i++) {\n                const clarityName = deserializeLPString(bytesReader).content;\n                if (clarityName === undefined) {\n                    throw new DeserializationError('\"content\" is undefined');\n                }\n                tupleContents[clarityName] = deserializeCV(bytesReader);\n            }\n            return tupleCV(tupleContents);\n        case ClarityType.StringASCII:\n            const asciiStrLen = bytesReader.readUInt32BE();\n            const asciiStr = bytesToAscii(bytesReader.readBytes(asciiStrLen));\n            return stringAsciiCV(asciiStr);\n        case ClarityType.StringUTF8:\n            const utf8StrLen = bytesReader.readUInt32BE();\n            const utf8Str = bytesToUtf8(bytesReader.readBytes(utf8StrLen));\n            return stringUtf8CV(utf8Str);\n        default:\n            throw new DeserializationError('Unable to deserialize Clarity Value from Uint8Array. Could not find valid Clarity Type.');\n    }\n}\n//# sourceMappingURL=deserialize.js.map","import { utf8ToBytes } from '@stacks/common';\nimport { ClarityType } from '../constants';\nconst bufferCV = (buffer) => {\n    if (buffer.length > 1000000) {\n        throw new Error('Cannot construct clarity buffer that is greater than 1MB');\n    }\n    return { type: ClarityType.Buffer, buffer };\n};\nconst bufferCVFromString = (str) => bufferCV(utf8ToBytes(str));\nexport { bufferCV, bufferCVFromString };\n//# sourceMappingURL=bufferCV.js.map","import { ClarityType } from '../constants';\nconst trueCV = () => ({ type: ClarityType.BoolTrue });\nconst falseCV = () => ({ type: ClarityType.BoolFalse });\nconst boolCV = (bool) => (bool ? trueCV() : falseCV());\nexport { boolCV, trueCV, falseCV };\n//# sourceMappingURL=booleanCV.js.map","import { ClarityType } from '../constants';\nfunction responseErrorCV(value) {\n    return { type: ClarityType.ResponseErr, value };\n}\nfunction responseOkCV(value) {\n    return { type: ClarityType.ResponseOk, value };\n}\nexport { responseErrorCV, responseOkCV };\n//# sourceMappingURL=responseCV.js.map","import { ClarityType } from '../constants';\nfunction noneCV() {\n    return { type: ClarityType.OptionalNone };\n}\nfunction someCV(value) {\n    return { type: ClarityType.OptionalSome, value };\n}\nfunction optionalCVOf(value) {\n    if (value) {\n        return someCV(value);\n    }\n    else {\n        return noneCV();\n    }\n}\nexport { noneCV, someCV, optionalCVOf };\n//# sourceMappingURL=optionalCV.js.map","import { ClarityType } from '../constants';\nfunction listCV(values) {\n    return { type: ClarityType.List, list: values };\n}\nexport { listCV };\n//# sourceMappingURL=listCV.js.map","import { ClarityType } from '../constants';\nimport { isClarityName } from '../../utils';\nfunction tupleCV(data) {\n    for (const key in data) {\n        if (!isClarityName(key)) {\n            throw new Error(`\"${key}\" is not a valid Clarity name`);\n        }\n    }\n    return { type: ClarityType.Tuple, data };\n}\nexport { tupleCV };\n//# sourceMappingURL=tupleCV.js.map","import * as btc from '@scure/btc-signer';\n\n// todo: auto-fetch or hardcode if final\n// or replace with testnet final address\nexport const SBTC_PEG_ADDRESS_TESTNET = '--TODO--';\nexport const SBTC_PEG_ADDRESS_DEVENV =\n  'bcrt1pte5zmd7qzj4hdu45lh9mmdm0nwq3z35pwnxmzkwld6y0a8g83nnqhj6vc0';\n\nexport const SBTC_FT_ADDRESS_TESTNET = 'ST3ACFZ2XKFPKAFD9YY92ZP0Y4QN6MTX3H20C27NY.asset';\nexport const SBTC_FT_ADDRESS_DEVENV = 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.asset';\n\nexport enum MagicBytes {\n  Mainnet = 'X2',\n  Testnet = 'T2',\n  Regtest = 'id',\n}\n\nexport enum OpCode {\n  PegIn = '3C',\n  PegOut = '3E',\n}\n\nexport type BitcoinNetwork = {\n  bech32: string;\n  pubKeyHash: number;\n  scriptHash: number;\n  wif: number;\n  bip32: {\n    public: number;\n    private: number;\n  };\n  bip84: {\n    coin: number;\n  };\n  magicBytes: string;\n};\n\nexport const MAINNET: BitcoinNetwork = {\n  ...btc.NETWORK,\n  bip32: {\n    public: 0x0488b21e,\n    private: 0x0488ade4,\n  },\n  bip84: {\n    coin: 0,\n  },\n  magicBytes: MagicBytes.Mainnet,\n};\n\nexport const TESTNET: BitcoinNetwork = {\n  ...btc.TEST_NETWORK,\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  bip84: {\n    coin: 1,\n  },\n  magicBytes: MagicBytes.Testnet,\n};\n\nexport const REGTEST: BitcoinNetwork = {\n  ...TESTNET,\n  bech32: 'bcrt',\n  magicBytes: MagicBytes.Regtest,\n};\n\n// Estimates based on https://bitcoinops.org/en/tools/calc-size/\nexport const OVERHEAD_TX = 4 + 1 + 1 + 4; // new btc.Transaction().vsize\n// const OVERHEAD_INPUT = 36 + 1 + 4 + 0.25;\n// const OVERHEAD_OUTPUT = 8 + 1;\n// const OVERHEAD_INPUT_P2PKH = 107;\nexport const VSIZE_INPUT_P2WPKH = 68;\n// const OVERHEAD_OUTPUT_P2PKH = 25;\n","import * as btc from '@scure/btc-signer';\nimport { hexToBytes, intToHex, utf8ToBytes } from '@stacks/common';\nimport { c32addressDecode } from 'c32check';\nimport * as P from 'micro-packed';\nimport { UtxoWithTx } from './api';\nimport { BitcoinNetwork, OVERHEAD_TX, VSIZE_INPUT_P2WPKH } from './constants';\n\nconst concat = P.concatBytes;\n\n// todo: move to transactions package\nexport function stacksAddressBytes(address: string): Uint8Array {\n  const [addr, contractName] = address.split('.');\n  const [version, hash] = c32addressDecode(addr);\n  const versionBytes = hexToBytes(version.toString(16));\n  const hashBytes = hexToBytes(hash);\n  const contractNameBytes = lengthPrefixedString(contractName, utf8ToBytes);\n\n  return concat(versionBytes, hashBytes, contractNameBytes);\n}\n\n// todo: move to transactions package\nexport function lengthPrefixedString(\n  something: string | null | undefined,\n  map: (something: string) => Uint8Array = utf8ToBytes,\n  maxByteLength: number = 40,\n  prefixByteLength: number = 1\n): Uint8Array {\n  if (!something) return new Uint8Array(0); // empty or nullish (optional)\n\n  const bytes = map(something);\n  if (maxByteLength >= 0 && bytes.byteLength > maxByteLength)\n    throw new RangeError(`Content byteLength exceeds maximum length of ${maxByteLength}`);\n\n  const prefixBytes = hexToBytes(intToHex(bytes.byteLength, prefixByteLength));\n  if (prefixBytes.byteLength > prefixByteLength)\n    throw new RangeError(`Prefix byteLength exceeds maximum length of ${prefixByteLength}`);\n\n  return concat(prefixBytes, bytes);\n}\n\nexport async function paymentInfo({\n  tx,\n  feeRate,\n  utxos,\n  utxoToSpendable,\n}: {\n  tx: btc.Transaction;\n  feeRate: number;\n  utxos: UtxoWithTx[];\n  utxoToSpendable: Partial<SpendableByScriptTypes>;\n}) {\n  const outputs = []; // can't enumerate directly\n  for (let i = 0; i < tx.outputsLength; i++) outputs.push(tx.getOutput(i));\n\n  return await utxoSelect({ feeRate, utxos, utxoToSpendable, outputs });\n}\n\n// == vsizing ==================================================================\n\nexport function txBytes(inputs: btc.TransactionInput[], outputs: btc.TransactionOutput[]) {\n  return (\n    OVERHEAD_TX + inputs.map(inputBytes).reduce(plus, 0) + outputs.map(outputBytes).reduce(plus, 0)\n  );\n}\n\n// todo: switch to estimating?\n\nexport function inputBytes(input: btc.TransactionInput) {\n  const tmpTx = new btc.Transaction({ allowUnknownInputs: true });\n  const originalSize = tmpTx.vsize;\n  tmpTx.addInput(input);\n  return tmpTx.vsize - originalSize;\n  // return OVERHEAD_INPUT + (input.finalScriptWitness ? input.finalScriptWitness.byteLength : OVERHEAD_INPUT_P2PKH);\n}\n\nexport function outputBytes(output: btc.TransactionOutput) {\n  const tmpTx = new btc.Transaction({ allowUnknownOutputs: true });\n  const originalSize = tmpTx.vsize;\n  tmpTx.addOutput(output);\n  return tmpTx.vsize - originalSize;\n  // return OVERHEAD_OUTPUT + (output.script ? output.script.byteLength : OVERHEAD_OUTPUT_P2PKH);\n}\n\nexport function dustMinimum(inputVsize: number, feeRate: number) {\n  return Math.ceil(inputVsize * feeRate);\n}\n\nconst plus = (a: number, b: number) => a + b;\n\nexport type Spendable = { input: btc.TransactionInput; vsize?: number };\n\nexport type SpendableByScriptTypes =\n  // prettier-ignore\n  { [Property in 'unknown' | 'sh' | 'wpkh' | 'wsh' | 'pk' | 'pkh' | 'ms' | 'tr' | 'tr_ns' | 'tr_ms']: (opts: UtxoToSpendableOpts) => Spendable | Promise<Spendable>; };\n\nexport const DEFAULT_UTXO_TO_SPENDABLE: Partial<SpendableByScriptTypes> = {\n  wpkh: wpkhUtxoToSpendable,\n  // sh: shUtxoToSpendable, // needs partial applying to work\n};\n\ninterface UtxoToSpendableOpts {\n  tx: btc.Transaction;\n  txHex: string;\n  utxo: UtxoWithTx;\n  output: ReturnType<btc.Transaction['getOutput']>;\n  spendScript: ReturnType<typeof btc.OutScript.decode>;\n}\n\nexport function wpkhUtxoToSpendable(opts: UtxoToSpendableOpts) {\n  if (!opts.output?.script) throw new Error('No script found on utxo tx');\n\n  const spendableInput: btc.TransactionInput = {\n    txid: hexToBytes(opts.utxo.txid),\n    index: opts.utxo.vout,\n    ...opts.output,\n    witnessUtxo: {\n      script: opts.output.script,\n      amount: BigInt(opts.utxo.value),\n    },\n  };\n\n  new btc.Transaction().addInput(spendableInput); // validate, throws if invalid\n  return { input: spendableInput, vsize: VSIZE_INPUT_P2WPKH };\n}\n\nexport function shUtxoToSpendable(\n  net: BitcoinNetwork,\n  paymentPublicKey: string,\n  opts: UtxoToSpendableOpts\n): Spendable | Promise<Spendable> {\n  if (!opts.output?.script) throw new Error('No script found on utxo tx');\n\n  let p2shRet;\n  // Taken from https://github.com/Stacks-Builders/sbtc-bridge-api/blob/97e14f3e1bfb76e215c8f0311555240703ef9d69/sbtc-bridge-lib/src/wallet_utils.ts#L196\n  // todo: refactor!!!\n  for (let i = 0; i < 10; i++) {\n    try {\n      if (i === 0) {\n        p2shRet = btc.p2sh(btc.p2wpkh(hexToBytes(paymentPublicKey)), net);\n      } else if (i === 1) {\n        p2shRet = btc.p2sh(btc.p2wsh(btc.p2wpkh(hexToBytes(paymentPublicKey))), net);\n      } else if (i === 2) {\n        p2shRet = btc.p2sh(btc.p2wsh(btc.p2pkh(hexToBytes(paymentPublicKey)), net));\n      } else if (i === 3) {\n        p2shRet = btc.p2sh(btc.p2ms(1, [hexToBytes(paymentPublicKey)]), net);\n      } else if (i === 4) {\n        p2shRet = btc.p2sh(btc.p2pkh(hexToBytes(paymentPublicKey)), net);\n      } else if (i === 5) {\n        p2shRet = btc.p2sh(btc.p2sh(btc.p2pkh(hexToBytes(paymentPublicKey)), net));\n      } else if (i === 6) {\n        p2shRet = btc.p2sh(btc.p2sh(btc.p2wpkh(hexToBytes(paymentPublicKey)), net));\n      }\n\n      if (!p2shRet) throw new Error('No valid p2sh variant found.');\n\n      // wrapped witness script\n      if (i < 3) {\n        const input: btc.TransactionInput = {\n          txid: hexToBytes(opts.utxo.txid),\n          index: opts.utxo.vout,\n          witnessUtxo: {\n            script: p2shRet.script,\n            amount: BigInt(opts.utxo.value),\n          },\n          redeemScript: p2shRet.redeemScript,\n        };\n        new btc.Transaction().addInput(input);\n        return { input, vsize: VSIZE_INPUT_P2WPKH + (p2shRet.script?.byteLength ?? 0) };\n      }\n\n      const input = {\n        txid: hexToBytes(opts.utxo.txid),\n        index: opts.utxo.vout,\n        nonWitnessUtxo: opts.txHex,\n        redeemScript: p2shRet.redeemScript,\n      } as unknown as btc.TransactionInput; // todo: something wrong with types here?\n      new btc.Transaction().addInput(input);\n      return { input, vsize: p2shRet.script?.byteLength ?? 0 };\n    } catch (e) {}\n  }\n  throw new Error('No valid p2sh variant found.');\n}\n\nexport async function utxoSelect({\n  feeRate,\n  utxos,\n  utxoToSpendable,\n  outputs,\n}: {\n  feeRate: number;\n  utxos: UtxoWithTx[];\n  utxoToSpendable: Partial<SpendableByScriptTypes>;\n  outputs: btc.TransactionOutput[];\n}): Promise<{\n  inputs: btc.TransactionInput[];\n  totalSats: bigint;\n  changeSats: bigint;\n}> {\n  const outputsValue = outputs.reduce(\n    (acc: bigint, o: btc.TransactionOutput) => acc + (o.amount ?? 0n),\n    0n\n  );\n\n  const inputs: btc.TransactionInput[] = []; // collect inputs\n  let inputRunning = 0n;\n\n  let vsizeRunning = txBytes([], outputs);\n\n  for (const utxo of utxos) {\n    try {\n      const { input, vsize } = await switchUtxoToSpendable(utxo, utxoToSpendable);\n      const inputVsize = vsize ?? inputBytes(input);\n      const utxoFee = feeRate * inputVsize;\n\n      if (utxoFee > utxo.value) continue; // skip if utxo is too small to pay fee\n\n      // add input\n      inputs.push(input);\n      inputRunning += BigInt(utxo.value);\n      vsizeRunning += inputVsize;\n\n      // check if we have enough inputs\n      const fee = feeRate * vsizeRunning;\n      if (inputRunning >= outputsValue + BigInt(Math.ceil(fee))) {\n        const changeSats = inputRunning - (outputsValue + BigInt(Math.ceil(fee)));\n        return { inputs, totalSats: inputRunning, changeSats };\n      }\n    } catch (e) {\n      console.warn(`Failed to make UTXO spendable; txid: ${utxo.txid}\\n`, e);\n      continue; // skip if utxo is not spendable\n    }\n  }\n\n  throw new Error('Not enough funds');\n}\n\n// todo: add p2sh for xverse\nexport async function switchUtxoToSpendable(\n  utxo: UtxoWithTx,\n  utxoToSpendable: Partial<SpendableByScriptTypes>\n): Promise<Spendable> {\n  const hex = await utxo.tx;\n  const tx = btc.Transaction.fromRaw(hexToBytes(hex), {\n    allowUnknownOutputs: true,\n    allowUnknownInputs: true,\n  });\n\n  const outputToSpend = tx.getOutput(utxo.vout);\n  if (!outputToSpend?.script) throw new Error('No script found on utxo tx');\n  const spendScript = btc.OutScript.decode(outputToSpend.script);\n\n  try {\n    const fn = utxoToSpendable[spendScript.type];\n    if (!fn) throw new Error(`Unsupported script type: ${spendScript.type}`);\n\n    return await fn({\n      tx,\n      txHex: hex,\n      utxo,\n      output: outputToSpend,\n      spendScript,\n    });\n  } catch (e) {\n    throw new Error(`Failed to make utxo spendable. ${JSON.stringify(utxo)}`, { cause: e });\n  }\n}\n\nconst x: btc.TransactionInput | btc.TransactionOutput = {} as any;\nif ('index' in x) x;\n\n// todo: after DR?\n// async function tryAllToSpendable(\n//   utxo: BlockstreamUtxo | BlockstreamUtxoWithTxHex\n// ): Promise<btc.TransactionInput> {\n//   const utxoWithTx: BlockstreamUtxoWithTxHex =\n//     'hex' in utxo ? utxo : { ...utxo, hex: await fetchTxHex(utxo.txid) };\n\n//   const tx = btc.Transaction.fromRaw(hexToBytes(utxoWithTx.hex), {\n//     allowUnknownOutputs: true,\n//     allowUnknownInputs: true,\n//   });\n\n//   const outputToSpend = tx.getOutput(utxo.vout);\n//   if (!outputToSpend?.script) throw new Error('No script found on utxo tx');\n//   const spendScript = btc.OutScript.decode(outputToSpend.script);\n\n//   try {\n//     switch (spendScript.type) {\n//       case 'wpkh':\n//       //\n//     }\n//   } catch (e) {\n//     throw new Error(`Utxo doesn't match spendable type, ${JSON.stringify(utxo)}`);\n//   }\n// }\n\ntype LazyLoadable<T extends object, K extends string> = T & Record<K, any>;\n\nexport function wrapLazyProxy<\n  T extends {\n    [key: string]: any;\n  },\n  K extends string,\n  R,\n>(target: T, key: K, resolution: () => R | Promise<R>): LazyLoadable<T, K> {\n  return new Proxy(target, {\n    get(obj, prop: string) {\n      if (prop === key && obj[prop] === undefined) {\n        (obj as any)[prop] = Promise.resolve(resolution()).catch(error => {\n          delete obj[prop];\n          throw error;\n        });\n      }\n      return obj[prop];\n    },\n    has(obj, prop) {\n      if (prop === key) return true;\n      return prop in obj;\n    },\n  });\n}\n","import { HDKey } from '@scure/bip32';\nimport * as bip39 from '@scure/bip39';\nimport * as btc from '@scure/btc-signer';\nimport {\n  BufferCV,\n  SomeCV,\n  TransactionVersion,\n  UIntCV,\n  getAddressFromPrivateKey,\n  serializeCV,\n} from '@stacks/transactions';\n\nimport RpcClient from '@btc-helpers/rpc';\nimport { RpcCallSpec } from '@btc-helpers/rpc/dist/callspec';\nimport { bytesToHex } from '@stacks/common';\nimport { compressPrivateKey } from '@stacks/encryption';\nimport { Cl } from '@stacks/transactions';\nimport { BitcoinNetwork, MAINNET, REGTEST, SBTC_FT_ADDRESS_TESTNET, TESTNET } from './constants';\nimport { wrapLazyProxy } from './utils';\nimport { ClarityValue } from '@stacks/transactions';\n\n/** todo */\n// https://blockstream.info/api/address/1KFHE7w8BhaENAswwryaoccDb6qcT6DbYY/utxo\n// [{\"txid\":\"033e44b535c5709d30234921608219ee5ca1e320fa9def44715eaeb2b7ad52d3\",\"vout\":0,\"status\":{\"confirmed\":false},\"value\":42200}]\nexport type BlockstreamUtxo = {\n  txid: string;\n  vout: number;\n  value: number;\n  status: {\n    confirmed: boolean;\n    block_height: number;\n  };\n};\n\n/** todo */\nexport type UtxoWithTx = BlockstreamUtxo & {\n  tx: string | Promise<string>;\n};\n\nexport type SpendableUtxo = BlockstreamUtxo & {\n  input: btc.TransactionInput | Promise<btc.TransactionInput>;\n  vsize?: number | Promise<number>;\n};\n\n/** todo */\nexport type BlockstreamFeeEstimates =\n  // prettier-ignore\n  { [K in | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | '11' | '12' | '13' | '14' | '15' | '16' | '17' | '18' | '19' | '20' | '21' | '22' | '23' | '24' | '25' | '144' | '504' | '1008']: number; };\n\nexport interface BaseUrlConfig {\n  bitcoinElectrsApiUrl: string;\n  stacksApiUrl: string;\n}\n\nexport class SbtcApiHelper {\n  constructor(public config: BaseUrlConfig) {}\n\n  async fetchUtxos(address: string): Promise<UtxoWithTx[]> {\n    return fetch(`${this.config.bitcoinElectrsApiUrl}/address/${address}/utxo`)\n      .then(res => res.json())\n      .then((utxos: BlockstreamUtxo[]) =>\n        utxos.sort((a, b) => a.status.block_height - b.status.block_height)\n      )\n      .then((utxos: BlockstreamUtxo[]) =>\n        utxos.map(u => wrapLazyProxy(u, 'tx', () => this.fetchTxHex(u.txid)))\n      );\n  }\n\n  async fetchTxHex(txid: string): Promise<string> {\n    return fetch(`${this.config.bitcoinElectrsApiUrl}/tx/${txid}/hex`).then(res => res.text());\n  }\n\n  async estimateFeeRates(): Promise<BlockstreamFeeEstimates> {\n    return fetch(`${this.config.bitcoinElectrsApiUrl}/fee-estimates`).then(res => res.json());\n  }\n\n  async estimateFeeRate(target: 'low' | 'medium' | 'high' | number): Promise<number> {\n    const feeEstimates = await this.estimateFeeRates();\n    const t =\n      typeof target === 'number'\n        ? target.toString()\n        : target === 'high'\n        ? '1'\n        : target === 'medium'\n        ? '2'\n        : '3';\n    if (t in feeEstimates) {\n      return feeEstimates[t as keyof BlockstreamFeeEstimates];\n    }\n\n    throw new Error(`Invalid fee target: ${target}`);\n  }\n\n  async broadcastTx(tx: btc.Transaction): Promise<string> {\n    return await fetch(`${this.config.bitcoinElectrsApiUrl}/tx`, {\n      method: 'POST',\n      body: tx.hex,\n    }).then(res => res.text());\n  }\n\n  async stacksCallReadOnly({\n    contractAddress,\n    functionName,\n    sender = 'ST000000000000000000002AMW42H',\n    args = [],\n  }: {\n    contractAddress: string;\n    functionName: string;\n    sender?: string;\n    args?: ClarityValue[];\n  }) {\n    contractAddress = contractAddress.replace('.', '/');\n    return await fetch(\n      `${this.config.stacksApiUrl}/v2/contracts/call-read/${contractAddress}/${encodeURIComponent(\n        functionName\n      )}`,\n      {\n        method: 'POST',\n        headers: {\n          Accept: 'application/json',\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ sender, arguments: args.map(serializeCV).map(bytesToHex) }),\n      }\n    )\n      .then(res => res.json())\n      .then(res => Cl.deserialize(res.result));\n  }\n\n  /**\n   * Get BTC balance (in satoshis)\n   * todo: check if better endpoints now exist\n   */\n  async getBalance(address: string): Promise<number> {\n    const addressInfo = await fetch(`${this.config.bitcoinElectrsApiUrl}/address/${address}`).then(\n      r => r.json()\n    );\n\n    return addressInfo.chain_stats.funded_txo_sum - addressInfo.chain_stats.spent_txo_sum;\n  }\n\n  async getSbtcBalance({\n    holderAddress,\n    sbtcContract,\n  }: {\n    holderAddress: string;\n    sbtcContract: string;\n  }) {\n    const [address, name] = holderAddress.split('.');\n\n    const balance = (await this.stacksCallReadOnly({\n      contractAddress: sbtcContract,\n      functionName: 'get-balance',\n      args: [name ? Cl.contractPrincipal(address, name) : Cl.standardPrincipal(address)],\n    })) as SomeCV<UIntCV>;\n\n    return balance?.value?.value ?? 0;\n  }\n\n  async getBitcoinAccount(mnemonic: string, idx: number = 0) {\n    return await getBitcoinAccount(MAINNET, mnemonic, idx);\n  }\n\n  async getStacksAccount(mnemonic: string, idx: number = 0) {\n    return await getStacksAccount(TransactionVersion.Mainnet, mnemonic, idx);\n  }\n}\n\nexport class TestnetHelper extends SbtcApiHelper {\n  constructor(config?: Partial<BaseUrlConfig>) {\n    super(\n      Object.assign(\n        {\n          bitcoinElectrsApiUrl: 'https://blockstream.info/testnet/api',\n          stacksApiUrl: 'https://stacks-node-api.testnet.stacks.co',\n        },\n        config\n      )\n    );\n  }\n\n  async getSbtcPegAddress(contractAddress = SBTC_FT_ADDRESS_TESTNET): Promise<string> {\n    const publicKey = (\n      (await this.stacksCallReadOnly({\n        contractAddress,\n        functionName: 'get-bitcoin-wallet-public-key',\n      })) as SomeCV<BufferCV>\n    ).value.buffer;\n\n    const tr = btc.p2tr(\n      publicKey.length === 33 ? publicKey.subarray(1) : publicKey, // strip y byte\n      undefined,\n      TESTNET\n    );\n    return tr.address!;\n  }\n\n  async getBitcoinAccount(mnemonic: string, idx: number = 0) {\n    return await getBitcoinAccount(TESTNET, mnemonic, idx);\n  }\n\n  async getStacksAccount(mnemonic: string, idx: number = 0) {\n    return await getStacksAccount(TransactionVersion.Testnet, mnemonic, idx);\n  }\n}\n\nexport class DevEnvHelper extends SbtcApiHelper {\n  btcRpc: RpcClient & RpcCallSpec;\n\n  constructor(config?: Partial<BaseUrlConfig & { bitcoinCoreRpcUrl: string }>) {\n    super(\n      Object.assign(\n        {\n          bitcoinElectrsApiUrl: 'http://127.0.0.1:3002',\n          stacksApiUrl: 'http://127.0.0.1:3999',\n        },\n        config\n      )\n    );\n\n    const bitcoinCoreRpcUrl = config?.bitcoinCoreRpcUrl ?? 'http://devnet:devnet@127.0.0.1:18433';\n    this.btcRpc = new RpcClient(bitcoinCoreRpcUrl).Typed;\n  }\n\n  async getSbtcPegAddress(): Promise<string> {\n    const pegAccount = await this.getBitcoinAccount(WALLET_00);\n    return pegAccount.tr.address;\n  }\n\n  async getBitcoinAccount(mnemonic: string, idx: number = 0) {\n    return await getBitcoinAccount(REGTEST, mnemonic, idx);\n  }\n\n  async getStacksAccount(mnemonic: string, idx: number = 0) {\n    return await getStacksAccount(TransactionVersion.Testnet, mnemonic, idx);\n  }\n}\n\n// == WALLET ===================================================================\n\nexport const WALLET_00 =\n  'twice kind fence tip hidden tilt action fragile skin nothing glory cousin green tomorrow spring wrist shed math olympic multiply hip blue scout claw';\nexport const WALLET_01 =\n  'sell invite acquire kitten bamboo drastic jelly vivid peace spawn twice guilt pave pen trash pretty park cube fragile unaware remain midnight betray rebuild';\nexport const WALLET_02 =\n  'hold excess usual excess ring elephant install account glad dry fragile donkey gaze humble truck breeze nation gasp vacuum limb head keep delay hospital';\n\nexport async function getBitcoinAccount(\n  network: BitcoinNetwork,\n  mnemonic: string,\n  idx: number = 0\n) {\n  const seed = await bip39.mnemonicToSeed(mnemonic);\n  const hdkey = HDKey.fromMasterSeed(seed, network.bip32);\n\n  const path = `m/84'/${network.bip84.coin}'/${idx}'/0/0`;\n  const privateKey = hdkey.derive(path).privateKey!;\n  const publicKey = hdkey.derive(path).publicKey!;\n\n  const trPath = `m/86'/${network.bip84.coin}'/${idx}'/0/0`;\n  const trPrivateKey = hdkey.derive(trPath).privateKey!;\n  const trPublicKey = hdkey.derive(trPath).publicKey!; // not sure if this should be used, but this is what the CLI returns\n\n  return {\n    privateKey,\n    publicKey,\n    wpkh: { address: btc.getAddress('wpkh', privateKey, network)! },\n    tr: {\n      address: btc.getAddress('tr', trPrivateKey, network)!,\n      publicKey: trPublicKey,\n    },\n  };\n}\n\nexport async function getStacksAccount(\n  transactionVersion: TransactionVersion,\n  mnemonic: string,\n  idx: number = 0\n) {\n  const rootPrivateKey = await bip39.mnemonicToSeed(mnemonic);\n  const rootNode = HDKey.fromMasterSeed(rootPrivateKey);\n\n  const childKey = rootNode.derive(`m/44'/5757'/0'/0`).deriveChild(idx);\n  const stxPrivateKey = bytesToHex(compressPrivateKey(childKey.privateKey!));\n\n  return {\n    /** Alias for `privateKey` @deprecated use `.privateKey` instead */\n    stxPrivateKey,\n    privateKey: stxPrivateKey,\n    address: getAddressFromPrivateKey(stxPrivateKey, transactionVersion),\n  };\n}\n\nexport function sleep(ms: number) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n","import * as btc from '@scure/btc-signer';\nimport { asciiToBytes, hexToBytes } from '@stacks/common';\nimport * as P from 'micro-packed';\nimport { UtxoWithTx } from '../api';\nimport {\n  BitcoinNetwork,\n  OpCode,\n  REGTEST,\n  SBTC_PEG_ADDRESS_DEVENV,\n  VSIZE_INPUT_P2WPKH,\n} from '../constants';\nimport {\n  DEFAULT_UTXO_TO_SPENDABLE,\n  SpendableByScriptTypes,\n  dustMinimum,\n  paymentInfo,\n  shUtxoToSpendable,\n  stacksAddressBytes,\n} from '../utils';\n\nconst concat = P.concatBytes;\n\nexport function buildSBtcDepositBtcPayload({\n  network,\n  address,\n}: {\n  network: BitcoinNetwork;\n  address: string;\n}): Uint8Array {\n  const magicBytes = asciiToBytes(network.magicBytes);\n  const opCodeBytes = hexToBytes(OpCode.PegIn);\n  const principalTypeBytes = address.includes('.') ? hexToBytes('06') : hexToBytes('05');\n  return concat(magicBytes, opCodeBytes, principalTypeBytes, stacksAddressBytes(address));\n}\n\n/**  */\nexport const buildSbtcDepositTx = buildSbtcDepositTxOpReturn; // default to OP RETURN for developer release\n\n/**\n *\n */\nexport function buildSbtcDepositTxOpReturn({\n  network = REGTEST,\n  amountSats,\n  stacksAddress,\n  pegAddress = SBTC_PEG_ADDRESS_DEVENV,\n}: {\n  network?: BitcoinNetwork;\n  amountSats: number;\n  stacksAddress: string;\n  pegAddress?: string;\n}) {\n  const data = buildSBtcDepositBtcPayload({ network, address: stacksAddress });\n\n  const tx = new btc.Transaction({\n    allowUnknownInputs: true,\n    allowUnknownOutputs: true,\n  });\n  tx.addOutput({ script: btc.Script.encode(['RETURN', data]), amount: BigInt(0) });\n  tx.addOutputAddress(pegAddress, BigInt(amountSats), network);\n\n  return tx;\n}\n\nexport async function sbtcDepositHelper({\n  network = REGTEST,\n  amountSats,\n  stacksAddress,\n  bitcoinChangeAddress,\n  feeRate,\n  utxos,\n  utxoToSpendable = DEFAULT_UTXO_TO_SPENDABLE,\n  pegAddress = SBTC_PEG_ADDRESS_DEVENV,\n  paymentPublicKey,\n}: {\n  network?: BitcoinNetwork;\n  amountSats: number;\n  stacksAddress: string;\n  bitcoinChangeAddress: string;\n  feeRate: number;\n  utxos: UtxoWithTx[];\n  /**\n   * Tries to convert p2wpk and p2sh utxos to spendable inputs by default.\n   * To extend, add your own function that takes a {@link UtxoToSpendableOpts}\n   * and returns a {@link Spendable}.\n   */\n  utxoToSpendable?: Partial<SpendableByScriptTypes>;\n  pegAddress?: string;\n  paymentPublicKey?: string;\n}) {\n  if (paymentPublicKey) {\n    utxoToSpendable.sh = shUtxoToSpendable.bind(null, network, paymentPublicKey);\n  }\n\n  const tx = buildSbtcDepositTxOpReturn({ network, amountSats, stacksAddress, pegAddress });\n\n  // we separate this part, since wallets could handle it themselves\n  const pay = await paymentInfo({ tx, feeRate, utxos, utxoToSpendable });\n  for (const input of pay.inputs) tx.addInput(input);\n\n  const changeAfterAdditionalOutput =\n    pay.changeSats - BigInt(Math.ceil(VSIZE_INPUT_P2WPKH * feeRate));\n  if (changeAfterAdditionalOutput > dustMinimum(VSIZE_INPUT_P2WPKH, feeRate)) {\n    tx.addOutputAddress(bitcoinChangeAddress, changeAfterAdditionalOutput, network);\n  }\n\n  return tx;\n}\n","import * as btc from '@scure/btc-signer';\nimport { asciiToBytes, bytesToHex, hexToBytes } from '@stacks/common';\nimport * as P from 'micro-packed';\nimport { UtxoWithTx } from '../api';\nimport {\n  BitcoinNetwork,\n  OpCode,\n  REGTEST,\n  SBTC_PEG_ADDRESS_DEVENV,\n  VSIZE_INPUT_P2WPKH,\n} from '../constants';\n\nimport {\n  DEFAULT_UTXO_TO_SPENDABLE,\n  SpendableByScriptTypes,\n  dustMinimum,\n  paymentInfo,\n  shUtxoToSpendable,\n} from '../utils';\n\nconst concat = P.concatBytes;\n\nexport async function sbtcWithdrawHelper({\n  network = REGTEST,\n  amountSats,\n  signature,\n  fulfillmentFeeSats,\n  bitcoinAddress,\n  bitcoinChangeAddress,\n  pegAddress = SBTC_PEG_ADDRESS_DEVENV,\n  feeRate,\n  utxos,\n  utxoToSpendable = DEFAULT_UTXO_TO_SPENDABLE,\n  paymentPublicKey,\n}: {\n  network?: BitcoinNetwork;\n  amountSats: number;\n  signature: string;\n  fulfillmentFeeSats: number;\n  /**\n   * Recipient address.\n   * ~(Will also be used as change address if `bitcoinChangeAddress` is not specified)~ todo\n   */\n  bitcoinAddress: string;\n  bitcoinChangeAddress: string;\n  pegAddress?: string;\n  feeRate: number;\n  utxos: UtxoWithTx[];\n  /**\n   * Tries to convert p2wpk and p2sh utxos to spendable inputs by default.\n   * To extend, add your own function that takes a {@link UtxoToSpendableOpts}\n   * and returns a {@link Spendable}.\n   */\n  utxoToSpendable?: Partial<SpendableByScriptTypes>;\n  paymentPublicKey?: string;\n}) {\n  // bitcoinChangeAddress ??= bitcoinAddress; // todo: maybe not expected\n\n  if (paymentPublicKey) {\n    utxoToSpendable.sh = shUtxoToSpendable.bind(null, network, paymentPublicKey);\n  }\n\n  const tx = buildSbtcWithdrawTxOpReturn({\n    network,\n    amountSats,\n    signature,\n    bitcoinAddress,\n  });\n  tx.addOutputAddress(pegAddress, BigInt(fulfillmentFeeSats), network);\n\n  // we separate this part, since wallets could handle it themselves\n  const pay = await paymentInfo({ tx, feeRate, utxos, utxoToSpendable });\n  for (const input of pay.inputs) tx.addInput(input);\n\n  const changeAfterAdditionalOutput =\n    pay.changeSats - BigInt(Math.ceil(VSIZE_INPUT_P2WPKH * feeRate));\n  if (changeAfterAdditionalOutput > dustMinimum(VSIZE_INPUT_P2WPKH, feeRate)) {\n    tx.addOutputAddress(bitcoinChangeAddress, changeAfterAdditionalOutput, network);\n  }\n\n  return tx;\n}\n\nexport const buildSbtcWithdrawTx = buildSbtcWithdrawTxOpReturn; // default to OP RETURN for developer release\n\nexport function buildSbtcWithdrawTxOpReturn({\n  network = REGTEST,\n  amountSats,\n  signature,\n  bitcoinAddress,\n}: {\n  network?: BitcoinNetwork;\n  amountSats: number;\n  signature: string;\n  bitcoinAddress: string;\n}) {\n  const data = buildSBtcWithdrawBtcPayload({ network, amountSats, signature });\n\n  const tx = new btc.Transaction({\n    allowUnknownInputs: true,\n    allowUnknownOutputs: true,\n  });\n  tx.addOutput({ script: btc.Script.encode(['RETURN', data]), amount: BigInt(0) });\n  tx.addOutputAddress(bitcoinAddress, BigInt(amountSats), network);\n\n  return tx;\n}\n\nexport function buildSBtcWithdrawBtcPayload({\n  network = REGTEST,\n  amountSats,\n  signature,\n}: {\n  network?: BitcoinNetwork;\n  amountSats: number;\n  signature: string;\n}): Uint8Array {\n  const magicBytes = asciiToBytes(network.magicBytes);\n  const opCodeBytes = hexToBytes(OpCode.PegOut);\n  const amountBytes = P.U64BE.encode(BigInt(amountSats));\n  const signatureBytes = hexToBytes(signature.slice(signature.length - 2) + signature.slice(0, -2)); // todo: maybe auto-detectable?\n  return concat(magicBytes, opCodeBytes, amountBytes, signatureBytes);\n}\n\nexport function sbtcWithdrawMessage({\n  network = REGTEST,\n  amountSats,\n  bitcoinAddress,\n}: {\n  network?: BitcoinNetwork;\n  amountSats: number;\n  bitcoinAddress: string;\n}): string {\n  const amountBytes = P.U64BE.encode(BigInt(amountSats));\n  const scriptOut = btc.OutScript.encode(btc.Address(network).decode(bitcoinAddress));\n  const data = concat(amountBytes, scriptOut);\n\n  // prettier-ignore\n  return `Withdraw request for ${amountSats} satoshis to the bitcoin address ${bitcoinAddress} (${bytesToHex(data)})`;\n}\n"],"names":["root","factory","exports","module","define","amd","this","leafPrototypes","getProto","mod","__defProp","Object","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__hasOwnProp","prototype","hasOwnProperty","lib_exports","target","all","name","get","enumerable","__export","default","RpcClient","to","from","except","desc","key","call","__copyProps","value","import_base","hostname","port","protocol","auth","constructor","opts","url","parsedUrl","URL","host","parseInt","user","username","pass","password","decodeUrl","options","assign","base64","encode","TextEncoder","Typed","Proxy","property","receiver","Reflect","async","params","jsonrpc","method","toString","toLowerCase","id","Math","random","body","headers","Authorization","JSON","stringify","errorPrefix","res","fetch","status","Error","text","exceededError","code","json","parse","ok","error","message","result","number","n","Number","isSafeInteger","bool","b","bytes","lengths","Uint8Array","TypeError","length","includes","hash","create","outputLen","blockLen","exists","instance","checkFinished","destroyed","finished","output","out","min","assert","SHA2","_assert_js_1","utils_js_1","Hash","padOffset","isLE","super","pos","buffer","view","createView","update","data","len","toBytes","take","set","subarray","process","dataView","roundClean","digestInto","fill","i","byteOffset","setBigUint64","_32n","BigInt","_u32_max","wh","wl","h","l","setUint32","oview","outLen","state","digest","slice","destroy","_cloneInto","crypto","node","undefined","web","self","sha224","sha256","_sha2_js_1","Maj","a","c","SHA256_K","Uint32Array","IV","SHA256_W","SHA256","A","B","C","D","E","F","G","H","offset","getUint32","W15","W2","s0","rotr","s1","T1","T2","SHA224","wrapConstructor","randomBytes","wrapConstructorWithOpts","checkOpts","concatBytes","utf8ToBytes","asyncLoop","nextTick","hexToBytes","bytesToHex","u32","u8","crypto_1","arr","byteLength","floor","DataView","word","shift","hexes","Array","v","padStart","str","uint8a","hex","array","j","hexByte","byte","isNaN","iters","tick","cb","ts","Date","now","diff","arrays","every","reduce","pad","clone","defaults","obj","hashConstructor","hashC","tmp","hashCons","msg","bytesLength","getRandomValues","assertNumber","chain","args","wrap","reverse","acc","decode","alphabet","digits","isArray","map","input","letter","index","indexOf","join","separator","split","padding","bits","chr","push","end","normalize","fn","convertRadix","forEach","d","carry","done","digit","digitBase","rounded","stringToBytes","bytesToString","utf8","bech32m","bech32","base58check","base58xmr","base58xrp","base58flickr","base58","base64urlnopad","base64url","base32crockford","base32hex","base32","base16","utils","gcd","radix2carry","convertRadix2","mask","radix","num","radix2","revPadding","unsafeWrapper","apply","e","checksum","payload","newChecksum","oldChecksum","s","toUpperCase","replace","genBase58","abc","XMR_BLOCK_LEN","block","concat","BECH_ALPHABET","POLYMOD_GENERATORS","bech32Polymod","pre","chk","bechChecksum","prefix","words","encodingConst","charCodeAt","genBech32","encoding","ENCODING_CONST","_words","fromWords","toWords","fromWordsUnsafe","limit","lowered","sepIndex","lastIndexOf","sum","endsWith","actualLength","decodeToBytes","decodeUnsafe","TextDecoder","CODERS","coderTypeError","type","ALPHABET","BASE_MAP","x","charAt","xc","BASE","LEADER","FACTOR","log","iFACTOR","source","psz","zeroes","size","b256","it3","it4","vch","ArrayBuffer","isView","pbegin","pend","b58","it1","it2","repeat","string","basex","c32ToB58","b58ToC32","c32addressDecode","c32address","versions","checksum_1","utils_1","mainnet","p2pkh","p2sh","testnet","ADDR_BITCOIN_TO_STACKS","ADDR_STACKS_TO_BITCOIN","version","hash160hex","match","c32checkEncode","c32addr","c32checkDecode","b58check","addrInfo","hash160String","addrVersion","stacksVersion","c32string","bitcoinVersion","sha256_1","dataBytes","prefixBytes","check","encoding_1","c32checksum","dataHex","dataHash","versionHex","checksumHex","c32str","c32encode","c32","c32data","c32normalize","c32decode","versionChar","substring","c32input","inputHex","minLength","currentCode","nextCode","nextBits","nextLowBits","curC32Digit","unshift","C32leadingZeros","zeroPrefix","numLeadingZeroBytesInHex","count","numLeadingZeroBytes","carryBits","currentValue","currentHexDigit","hexLeadingZeros","hexStr","address_1","support","Symbol","Blob","viewClasses","isArrayBufferView","normalizeName","String","test","normalizeValue","iteratorFor","items","iterator","next","Headers","append","header","consumed","bodyUsed","Promise","reject","fileReaderReady","reader","resolve","onload","onerror","readBlobAsArrayBuffer","blob","FileReader","promise","readAsArrayBuffer","bufferClone","buf","Body","_initBody","_bodyInit","_bodyText","isPrototypeOf","_bodyBlob","FormData","_bodyFormData","URLSearchParams","_bodyArrayBuffer","rejected","arrayBuffer","then","readAsText","chars","fromCharCode","readArrayBufferAsText","formData","oldValue","has","callback","thisArg","keys","values","entries","methods","Request","upcased","credentials","mode","signal","referrer","form","trim","decodeURIComponent","Response","bodyInit","statusText","response","redirectStatuses","redirect","RangeError","location","DOMException","err","stack","init","request","aborted","xhr","XMLHttpRequest","abortXhr","abort","rawHeaders","getAllResponseHeaders","line","parts","responseURL","responseText","ontimeout","onabort","open","withCredentials","responseType","setRequestHeader","addEventListener","onreadystatechange","readyState","removeEventListener","send","polyfill","HASH_UNDEFINED","MAX_SAFE_INTEGER","argsTag","boolTag","dateTag","funcTag","genTag","mapTag","numberTag","objectTag","promiseTag","regexpTag","setTag","stringTag","symbolTag","weakMapTag","arrayBufferTag","dataViewTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","reFlags","reIsHostCtor","reIsUint","cloneableTags","freeGlobal","g","freeSelf","Function","freeExports","nodeType","freeModule","moduleExports","addMapEntry","pair","addSetEntry","add","arrayReduce","iteratee","accumulator","initAccum","isHostObject","mapToArray","overArg","func","transform","arg","setToArray","uid","arrayProto","funcProto","objectProto","coreJsData","maskSrcKey","exec","IE_PROTO","funcToString","objectToString","reIsNative","RegExp","Buffer","getPrototype","getPrototypeOf","objectCreate","propertyIsEnumerable","splice","nativeGetSymbols","getOwnPropertySymbols","nativeIsBuffer","isBuffer","nativeKeys","getNative","Map","Set","WeakMap","nativeCreate","dataViewCtorString","toSource","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","symbolProto","symbolValueOf","valueOf","clear","entry","ListCache","MapCache","Stack","__data__","assignValue","object","objValue","eq","assocIndexOf","baseClone","isDeep","isFull","customizer","isObject","isArr","initCloneArray","copyArray","tag","getTag","isFunc","copy","cloneBuffer","isPrototype","proto","initCloneObject","copyObject","getSymbols","copySymbols","baseAssign","cloneFunc","symbol","Ctor","cloneArrayBuffer","cloneDataView","typedArray","cloneTypedArray","cloneMap","regexp","lastIndex","cloneRegExp","cloneSet","initCloneByTag","stacked","props","keysFunc","symbolsFunc","arrayPush","baseGetAllKeys","getAllKeys","arrayEach","subValue","newValue","getMapData","getValue","isFunction","baseIsNative","pop","cache","pairs","LARGE_ARRAY_SIZE","isIndex","other","ctorString","isArrayLike","isLength","inherited","isObjectLike","isArrayLikeObject","isArguments","baseTimes","skipIndexes","arrayLikeKeys","baseKeys","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","loaded","__webpack_modules__","getter","__esModule","t","ns","r","def","current","definition","o","globalThis","window","prop","toStringTag","nmd","paths","children","u8a","_","toStr","HMAC","_key","iHash","oHash","hmac","Rho","Id","idxL","idxR","k","shifts","shiftsL","idx","shiftsR","Kl","Kr","rotl","f","group","y","z","BUF","RIPEMD160","h0","h1","h2","h3","h4","al","ar","bl","br","cl","cr","dl","dr","el","er","rGroup","hbl","hbr","rl","rr","sl","sr","tl","tr","ripemd160","U32_MASK64","fromBig","le","lst","Ah","Al","_l","Bh","Bl","Cl","low","Ch","Dl","Dh","Eh","El","SHA512_Kh","SHA512_Kl","SHA512_W_H","SHA512_W_L","SHA512","Fh","Fl","Gh","Gl","Hh","Hl","W15h","W15l","s0h","s0l","W2h","W2l","s1h","s1l","SUMl","SUMh","sigma1h","sigma1l","CHIh","T1ll","T1h","T1l","sigma0h","sigma0l","MAJh","MAJl","All","_1n","_2n","hexToNumber","numberToBytesBE","numberToBytesLE","title","expectedLength","bitMask","u8n","u8fr","createHmacDrbg","hashLen","qByteLen","hmacFn","reset","reseed","seed","gen","pred","validatorFns","bigint","val","function","boolean","stringOrUint8Array","field","Fp","isValid","validateObject","validators","optValidators","checkField","fieldName","isOptional","checkVal","_3n","_4n","_5n","_8n","pow","power","modulo","pow2","invert","u","q","m","FIELD_FIELDS","nLength","nBitLength","_nBitLength","nByteLength","ceil","getFieldBytesLength","fieldOrder","bitLength","getMinHashLength","validateBasic","curve","ORDER","MASK","BYTES","BITS","Gx","Gy","freeze","p","bytesToNumberBE","b2n","h2b","DER","Err","_parseInt","toSig","sBytes","rBytesLeft","hexFromSig","sig","shl","rhl","weierstrass","curveDef","CURVE","bits2int","bits2int_modN","lowS","validateOpts","compressedLen","uncompressedLen","modN","CURVE_ORDER","invN","ProjectivePoint","Point","normPrivateKeyToScalar","weierstrassEquation","isWithinCurveOrder","allowedPrivateKeyLengths","wrapPrivateKey","isTorsionFree","clearCofactor","allowInfinityPoint","fromBytes","endo","eql","ZERO","beta","splitScalar","validatePointOpts","_c","point","_isCompressed","toAffine","tail","x2","sqr","x3","mul","assertGE","pointPrecomputes","assertPrjPoint","px","py","pz","fromAffine","is0","ONE","normalizeZ","points","toInv","invertBatch","fromHex","P","assertValidity","fromPrivateKey","privateKey","multiply","_setWindowSize","windowSize","_WINDOW_SIZE","delete","left","right","hasEvenY","isOdd","equals","X1","Y1","Z1","X2","Y2","Z2","U1","U2","negate","neg","double","b3","X3","Y3","Z3","t0","t1","t2","t3","sub","t4","t5","subtract","wNAF","wnaf","wNAFCached","comp","multiplyUnsafe","I","unsafeLadder","k1neg","k1","k2neg","k2","k1p","k2p","scalar","fake","f1p","f2p","constTimeNegate","multiplyAndAddUnsafe","Q","iz","inv","ax","ay","zz","cofactor","toRawBytes","isCompressed","toHex","_bits","condition","item","W","windows","elm","precomputeWindow","base","precomputes","maxNumber","shiftBy","wbits","offset1","offset2","abs","cond1","cond2","precomputesMap","weierstrassPoints","cat","head","y2","sqrt","numToNByteStr","isBiggerThanHalfOrder","slcNum","Signature","recovery","fromCompact","fromDER","addRecoveryBit","recoverPublicKey","msgHash","rec","radj","R","ir","u1","u2","hasHighS","normalizeS","toDERRawBytes","toDERHex","toCompactRawBytes","toCompactHex","isValidPrivateKey","randomPrivateKey","fieldLen","minLen","reduced","precompute","isProbPub","delta","ORDER_MASK","int2octets","defaultSigOpts","prehash","defaultVerOpts","getPublicKey","getSharedSecret","privateA","publicB","sign","privKey","k2sig","some","extraEntropy","ent","h1int","seedArgs","kBytes","ik","normS","prepSig","drbg","verify","signature","publicKey","sg","_sig","derError","is","getHash","msgs","secp256k1P","secp256k1N","divNearest","sqrtMod","_6n","_11n","_22n","_23n","_44n","_88n","b2","b6","b9","b11","b22","b44","b88","b176","b220","b223","bitLen","redef","sqrtP","p1div4","c1","n2","nv","legendreC","S","Z","Q1div2","ge","tonelliShanks","FpSqrt","lhs","rhs","FpPow","div","sqrN","addN","subN","mulN","nums","lastMultiplied","inverted","reduceRight","FpInvertBatch","cmov","Field","secp256k1","defHash","createCurve","a1","b1","a2","POW_2_128","c2","fe","TAGGED_HASH_PREFIXES","taggedHash","messages","tagP","tagH","pointToBytes","numTo32b","modP","GmulAdd","schnorrGetExtPubKey","priv","d_","lift_x","xx","challenge","schnorrGetPublicKey","schnorrSign","auxRand","rand","k_","rx","schnorrVerify","pub","schnorr","bytesToNumber","MASTER_SECRET","BITCOIN_VERSIONS","private","public","HARDENED_OFFSET","toU32","HDKey","fingerprint","pubHash","identifier","pubKeyHash","privKeyBytes","pubKey","privateExtendedKey","serialize","publicExtendedKey","fromMasterSeed","chainCode","fromExtendedKey","base58key","keyBuffer","keyView","opt","depth","parentFingerprint","isPriv","fromJSON","xpriv","derive","path","child","m1","deriveChild","childTweak","added","wipePrivateData","toJSON","xpub","nfkd","salt","passphrase","mnemonicToSeed","mnemonic","dkLen","asyncTick","DK","PRF","PRFSalt","_password","_salt","_opts","pbkdf2Init","prfW","ti","Ti","setInt32","pbkdf2Output","pbkdf2Async","norm","EMPTY","NULL","isBytes","Reader","fieldPath","hasPtr","bitBuf","bitPos","absBytes","peek","isFinite","leftBytes","isEnd","byteLen","isCoder","decodeStream","getPath","find","needle","finish","fieldPathPush","fieldPathPop","Writer","buffers","ptrs","ptr","encodeStream","swap","checkBounds","signed","signBit","inner","w","objPath","cur","coders","dict","precision","decimalMask","sep","int","frac","startsWith","intS","fracS","fracLen","_value","bLen","U256BE","U64LE","U64BE","I64LE","U32LE","U32BE","I32LE","U16LE","U8","tPos","innerValue","validate","magic","constant","sizeof","fields","struct","startPos","ProjPoint","_signECDSA","_pubECDSA","sha256x2","cloneDeep","fromEntries","PubT","validatePubkey","ecdsa","isValidPubkey","hasLowR","tapTweak","tn","taprootTweakPubkey","parity","PubKeyECDSA","PubKeySchnorr","SignatureSchnorr","NETWORK","scriptHash","wif","DEFAULT_SEQUENCE","EMPTY32","_cmpBytes","OP","decimal","Script","OP_1","ScriptNum","PUSHDATA1","PUSHDATA2","PUSHDATA4","OP_0","OP_16","op","bytesLimit","forceMinimal","last","CSLimits","CompactSize","flag","start","stop","b0","CompactSizeLen","BTCArray","VarBytes","RawInput","txid","finalScriptSig","sequence","RawOutput","amount","script","EMPTY_OUTPUT","RawWitness","RawTx","segwitFlag","flagValue","xor","hasFlag","inputs","outputs","witnesses","lockTime","tx","PSBTKeyInfo","info","kc","vc","reqInc","allowInc","silentIgnore","BIP32Der","TaprootControlBlock","internalKey","merklePath","TaprootBIP32Der","hashes","der","GlobalXPUB","tapScriptSigKey","leafHash","tapTree","BytesInf","Bytes20","Bytes32","PSBTGlobal","unsignedTx","txVersion","fallbackLocktime","inputCount","outputCount","txModifiable","proprietary","PSBTInput","nonWitnessUtxo","witnessUtxo","partialSig","sighashType","redeemScript","witnessScript","bip32Derivation","finalScriptWitness","porCommitment","hash160","hash256","requiredTimeLocktime","requiredHeightLocktime","tapKeySig","tapScriptSig","tapLeafScript","tapBip32Derivation","tapInternalKey","tapMerkleRoot","PSBTInputFinalKeys","PSBTInputUnsignedKeys","PSBTOutput","PSBTOutputUnsignedKeys","PSBTKeyPair","wChild","PSBTKeyMap","psbtEnum","byType","kv","sort","unknown","raw","noKey","_name","checkWSH","OutScript","checkScript","PSBTInputCoder","prevOut","Transaction","fromRaw","PSBTOutputCoder","PSBTGlobalCoder","inp","_RawPSBTV0","global","_RawPSBTV2","validatePSBTFields","cleanPSBTFields","_k","validatePSBT","inputsLeft","outputsLeft","mergeKeyMap","allowedFields","kC","vC","cannotChange","oldKV","newKV","kStr","oldVal","newVal","withZero","RawPSBTV0","RawPSBTV2","TxHashIdx","OutPK","pubkey","OutPKH","network","address","Address","OutSH","cs","OutWSH","p2wsh","OutWPKH","p2wpkh","OutMS","pubkeys","p2ms","allowSamePubkeys","uniqPubkey","OutTR","taprootHashTree","tree","internalPubKey","allowUnknownOutputs","leafVersion","leafScript","outms","TAPROOT_UNSPENDABLE_KEY","checkTaprootScript","tapLeafHash","taprootList","weight","childs","taprootListToTree","lH","rH","taprootAddPath","taprootWalkTree","p2tr","hashedTree","tweakedPubkey","leaves","controlBlock","TAP_LEAF_VERSION","OutScripts","OpToNum","validateWitness","programToWitness","coder","formatKey","hashed","program","SignatureHash","SigHash","validateSigHash","unpackSighash","hashType","masked","isAny","ANYONECANPAY","isNone","NONE","isSingle","SINGLE","inputBeforeSign","cleanFinalInput","outputBeforeSign","PSBTVersion","allowUnknowInput","allowUnknownInputs","allowUnknowOutput","parsed","addOutput","fromPSBT","psbt","e0","e2","unsigned","toPSBT","bip174jsCompat","height","heightCnt","time","timeCnt","max","inputStatus","checkInputIdx","inputSighash","sighash","inputType","sigOutputs","DEFAULT","ALL","sigInputs","signStatus","addInput","isFinal","hasWitnesses","vsize","withScriptSig","withWitness","getInput","inputsLength","normalizeInput","disableScriptCheck","_ignoreSignStatus","updateInput","checkOutputIdx","getOutput","outputsLength","normalizeOutput","updateOutput","addOutputAddress","fee","preimageLegacy","prevOutScript","filter","inputIdx","tmpTx","preimageWitnessV0","inputHash","sequenceHash","outputHash","preimageWitnessV1","codeSeparator","leafVer","annex","outType","inType","spendType","txType","defaultSighash","first","lastScript","allowLegacyWitnessUtxo","signIdx","allowedSighash","_auxRand","signers","prevOuts","schnorrPub","merkleRoot","seckey0","seckey","taprootTweakPrivKey","getTaprootKeys","taprootPubKey","_script","scriptDecoded","ver","findIndex","hasPubkey","lowR","cnt","signECDSA","finalizeIdx","leafs","outScript","scriptSig","signatures","sigIdx","inputScript","witness","finalize","extract","combine","getAddress","intToBigInt","parsedValue","isInteger","SyntaxError","bn","width","nthBit","fromTwos","integer","lengthBytes","bigIntToBytes","paddedHex","isNotOctet","octet","octetsToBytes","numbers","elements","writeUInt32BE","destination","ChainID","Mainnet","MAX_STRING_LENGTH_BYTES","CLARITY_INT_SIZE","CLARITY_INT_BYTE_SIZE","PayloadType","ClarityVersion","AnchorMode","StacksMessageType","TransactionVersion","PostConditionMode","AuthType","AssetType","TxRejectedReason","PostConditionPrincipalID","NonFungibleConditionCode","FungibleConditionCode","PubKeyEncoding","AddressVersion","AddressHashMode","PostConditionType","OnChainOnly","OffChainOnly","Any","groupLen","USE_ENDOMORPHISM","ShaError","assertJacPoint","JacobianPoint","toAffineBatch","scratch","Z1Z1","Z2Z2","S1","S2","x1b","HH","HHH","V","P0","normalizeScalar","affinePoint","invZ","iz1","iz2","iz3","fromCompressedHex","isShort","isValidFieldElement","rt","isYOdd","fromUncompressedHex","normalizePrivateKey","fromSignature","normalizeSignature","truncateOnly","bits2int_2","truncateHash","rinv","numTo32bStr","toHexX","toRawX","aP","bQ","sliceDER","parseDERInt","parseDERSignature","HALF","sHex","rHex","sHexL","rHexL","sLen","rLen","POW_2_256","_sha256Sync","_hmacSha256Sync","_bigintTo32Bytes","_normalizePrivateKey","hashToPrivateKey","cached","subtle","createHash","hmacSha256","ckey","importKey","createHmac","sha256Sync","hmacSha256Sync","taggedHashSync","_JacobianPoint","defineProperties","configurable","maxLengthBytes","content","lengthPrefixBytes","prefixLength","maxLength","LengthPrefixedString","createAddress","c32AddressString","addressData","serializeAddress","bytesArray","deserializeAddress","bytesReader","readBytes","serializeLPString","lps","contentBytes","deserializeLPString","ClarityType","TransactionError","captureStackTrace","SerializationError","bytesWithTypeID","typeId","serializeStringCV","cv","byteArray","BoolTrue","BoolFalse","serializeBoolCV","OptionalNone","OptionalSome","serializeBufferCV","UInt","serializeUIntCV","Int","toTwos","serializeIntCV","PrincipalStandard","serializeStandardPrincipalCV","PrincipalContract","contractName","serializeContractPrincipalCV","ResponseOk","ResponseErr","serializeResponseCV","List","list","serializedValue","serializeListCV","Tuple","lexicographicOrder","localeCompare","nameWithLength","serializeTupleCV","StringASCII","serializeStringAsciiCV","StringUTF8","serializeStringUtf8CV","privateKeyBuffer","PRIVATE_KEY_COMPRESSED_LENGTH","getAddressFromPrivateKey","transactionVersion","addrVer","hashMode","SerializeP2PKH","MainnetSingleSig","Testnet","TestnetSingleSig","SerializeP2SH","SerializeP2WPKH","SerializeP2WSH","MainnetMultiSig","TestnetMultiSig","getAddressFromPublicKey","compressed","createStacksPrivateKey","PublicKey","pubKeyfromPrivKey","contractPrincipalCVFromAddress","MAX_U128","MIN_U128","MAX_I128","MIN_I128","enumCheckFunctions","isEnum","enumVariable","checker","newChecker","enumValues","enumValueSet","createEnumChecker","BytesReader","readUInt32BE","readUInt8","readUInt16BE","readBigUIntLE","readBigUIntBE","readOffset","internalBytes","readUInt8Enum","invalidEnumErrorFormatter","contractPrincipal","addressString","standardPrincipal","addr","deserialize","serializedClarityValue","hasHexPrefix","bigInt","bufferLength","listLength","listContents","tupleLength","tupleContents","clarityName","asciiStrLen","asciiStr","utf8StrLen","SBTC_PEG_ADDRESS_TESTNET","SBTC_PEG_ADDRESS_DEVENV","SBTC_FT_ADDRESS_TESTNET","SBTC_FT_ADDRESS_DEVENV","MagicBytes","OpCode","MAINNET","bip32","bip84","coin","magicBytes","TESTNET","REGTEST","OVERHEAD_TX","VSIZE_INPUT_P2WPKH","stacksAddressBytes","versionBytes","hashBytes","contractNameBytes","lengthPrefixedString","something","maxByteLength","prefixByteLength","paymentInfo","feeRate","utxos","utxoToSpendable","utxoSelect","txBytes","inputBytes","plus","outputBytes","originalSize","dustMinimum","inputVsize","DEFAULT_UTXO_TO_SPENDABLE","wpkh","wpkhUtxoToSpendable","spendableInput","utxo","vout","shUtxoToSpendable","net","paymentPublicKey","p2shRet","txHex","outputsValue","inputRunning","vsizeRunning","switchUtxoToSpendable","totalSats","changeSats","console","warn","outputToSpend","spendScript","cause","wrapLazyProxy","resolution","catch","SbtcApiHelper","config","fetchUtxos","bitcoinElectrsApiUrl","block_height","fetchTxHex","estimateFeeRates","estimateFeeRate","feeEstimates","broadcastTx","stacksCallReadOnly","contractAddress","functionName","sender","stacksApiUrl","encodeURIComponent","Accept","arguments","getBalance","addressInfo","chain_stats","funded_txo_sum","spent_txo_sum","getSbtcBalance","holderAddress","sbtcContract","balance","getBitcoinAccount","getStacksAccount","TestnetHelper","getSbtcPegAddress","DevEnvHelper","bitcoinCoreRpcUrl","btcRpc","WALLET_00","WALLET_01","WALLET_02","hdkey","trPath","trPrivateKey","trPublicKey","rootPrivateKey","stxPrivateKey","privateKeyBytes","compressPrivateKey","sleep","ms","setTimeout","buildSBtcDepositBtcPayload","opCodeBytes","PegIn","principalTypeBytes","buildSbtcDepositTx","buildSbtcDepositTxOpReturn","amountSats","stacksAddress","pegAddress","sbtcDepositHelper","bitcoinChangeAddress","sh","bind","pay","changeAfterAdditionalOutput","sbtcWithdrawHelper","fulfillmentFeeSats","bitcoinAddress","buildSbtcWithdrawTxOpReturn","buildSbtcWithdrawTx","buildSBtcWithdrawBtcPayload","PegOut","amountBytes","signatureBytes","sbtcWithdrawMessage","scriptOut"],"sourceRoot":""}