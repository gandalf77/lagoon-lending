"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapLazyProxy = exports.switchUtxoToSpendable = exports.utxoSelect = exports.shUtxoToSpendable = exports.wpkhUtxoToSpendable = exports.DEFAULT_UTXO_TO_SPENDABLE = exports.dustMinimum = exports.outputBytes = exports.inputBytes = exports.txBytes = exports.paymentInfo = exports.lengthPrefixedString = exports.stacksAddressBytes = void 0;
const btc = __importStar(require("@scure/btc-signer"));
const common_1 = require("@stacks/common");
const c32check_1 = require("c32check");
const P = __importStar(require("micro-packed"));
const constants_1 = require("./constants");
const concat = P.concatBytes;
function stacksAddressBytes(address) {
    const [addr, contractName] = address.split('.');
    const [version, hash] = (0, c32check_1.c32addressDecode)(addr);
    const versionBytes = (0, common_1.hexToBytes)(version.toString(16));
    const hashBytes = (0, common_1.hexToBytes)(hash);
    const contractNameBytes = lengthPrefixedString(contractName, common_1.utf8ToBytes);
    return concat(versionBytes, hashBytes, contractNameBytes);
}
exports.stacksAddressBytes = stacksAddressBytes;
function lengthPrefixedString(something, map = common_1.utf8ToBytes, maxByteLength = 40, prefixByteLength = 1) {
    if (!something)
        return new Uint8Array(0);
    const bytes = map(something);
    if (maxByteLength >= 0 && bytes.byteLength > maxByteLength)
        throw new RangeError(`Content byteLength exceeds maximum length of ${maxByteLength}`);
    const prefixBytes = (0, common_1.hexToBytes)((0, common_1.intToHex)(bytes.byteLength, prefixByteLength));
    if (prefixBytes.byteLength > prefixByteLength)
        throw new RangeError(`Prefix byteLength exceeds maximum length of ${prefixByteLength}`);
    return concat(prefixBytes, bytes);
}
exports.lengthPrefixedString = lengthPrefixedString;
async function paymentInfo({ tx, feeRate, utxos, utxoToSpendable, }) {
    const outputs = [];
    for (let i = 0; i < tx.outputsLength; i++)
        outputs.push(tx.getOutput(i));
    return await utxoSelect({ feeRate, utxos, utxoToSpendable, outputs });
}
exports.paymentInfo = paymentInfo;
function txBytes(inputs, outputs) {
    return (constants_1.OVERHEAD_TX + inputs.map(inputBytes).reduce(plus, 0) + outputs.map(outputBytes).reduce(plus, 0));
}
exports.txBytes = txBytes;
function inputBytes(input) {
    const tmpTx = new btc.Transaction({ allowUnknownInputs: true });
    const originalSize = tmpTx.vsize;
    tmpTx.addInput(input);
    return tmpTx.vsize - originalSize;
}
exports.inputBytes = inputBytes;
function outputBytes(output) {
    const tmpTx = new btc.Transaction({ allowUnknownOutputs: true });
    const originalSize = tmpTx.vsize;
    tmpTx.addOutput(output);
    return tmpTx.vsize - originalSize;
}
exports.outputBytes = outputBytes;
function dustMinimum(inputVsize, feeRate) {
    return Math.ceil(inputVsize * feeRate);
}
exports.dustMinimum = dustMinimum;
const plus = (a, b) => a + b;
exports.DEFAULT_UTXO_TO_SPENDABLE = {
    wpkh: wpkhUtxoToSpendable,
};
function wpkhUtxoToSpendable(opts) {
    if (!opts.output?.script)
        throw new Error('No script found on utxo tx');
    const spendableInput = {
        txid: (0, common_1.hexToBytes)(opts.utxo.txid),
        index: opts.utxo.vout,
        ...opts.output,
        witnessUtxo: {
            script: opts.output.script,
            amount: BigInt(opts.utxo.value),
        },
    };
    new btc.Transaction().addInput(spendableInput);
    return { input: spendableInput, vsize: constants_1.VSIZE_INPUT_P2WPKH };
}
exports.wpkhUtxoToSpendable = wpkhUtxoToSpendable;
function shUtxoToSpendable(net, paymentPublicKey, opts) {
    if (!opts.output?.script)
        throw new Error('No script found on utxo tx');
    let p2shRet;
    for (let i = 0; i < 10; i++) {
        try {
            if (i === 0) {
                p2shRet = btc.p2sh(btc.p2wpkh((0, common_1.hexToBytes)(paymentPublicKey)), net);
            }
            else if (i === 1) {
                p2shRet = btc.p2sh(btc.p2wsh(btc.p2wpkh((0, common_1.hexToBytes)(paymentPublicKey))), net);
            }
            else if (i === 2) {
                p2shRet = btc.p2sh(btc.p2wsh(btc.p2pkh((0, common_1.hexToBytes)(paymentPublicKey)), net));
            }
            else if (i === 3) {
                p2shRet = btc.p2sh(btc.p2ms(1, [(0, common_1.hexToBytes)(paymentPublicKey)]), net);
            }
            else if (i === 4) {
                p2shRet = btc.p2sh(btc.p2pkh((0, common_1.hexToBytes)(paymentPublicKey)), net);
            }
            else if (i === 5) {
                p2shRet = btc.p2sh(btc.p2sh(btc.p2pkh((0, common_1.hexToBytes)(paymentPublicKey)), net));
            }
            else if (i === 6) {
                p2shRet = btc.p2sh(btc.p2sh(btc.p2wpkh((0, common_1.hexToBytes)(paymentPublicKey)), net));
            }
            if (!p2shRet)
                throw new Error('No valid p2sh variant found.');
            if (i < 3) {
                const input = {
                    txid: (0, common_1.hexToBytes)(opts.utxo.txid),
                    index: opts.utxo.vout,
                    witnessUtxo: {
                        script: p2shRet.script,
                        amount: BigInt(opts.utxo.value),
                    },
                    redeemScript: p2shRet.redeemScript,
                };
                new btc.Transaction().addInput(input);
                return { input, vsize: constants_1.VSIZE_INPUT_P2WPKH + (p2shRet.script?.byteLength ?? 0) };
            }
            const input = {
                txid: (0, common_1.hexToBytes)(opts.utxo.txid),
                index: opts.utxo.vout,
                nonWitnessUtxo: opts.txHex,
                redeemScript: p2shRet.redeemScript,
            };
            new btc.Transaction().addInput(input);
            return { input, vsize: p2shRet.script?.byteLength ?? 0 };
        }
        catch (e) { }
    }
    throw new Error('No valid p2sh variant found.');
}
exports.shUtxoToSpendable = shUtxoToSpendable;
async function utxoSelect({ feeRate, utxos, utxoToSpendable, outputs, }) {
    const outputsValue = outputs.reduce((acc, o) => acc + (o.amount ?? 0n), 0n);
    const inputs = [];
    let inputRunning = 0n;
    let vsizeRunning = txBytes([], outputs);
    for (const utxo of utxos) {
        try {
            const { input, vsize } = await switchUtxoToSpendable(utxo, utxoToSpendable);
            const inputVsize = vsize ?? inputBytes(input);
            const utxoFee = feeRate * inputVsize;
            if (utxoFee > utxo.value)
                continue;
            inputs.push(input);
            inputRunning += BigInt(utxo.value);
            vsizeRunning += inputVsize;
            const fee = feeRate * vsizeRunning;
            if (inputRunning >= outputsValue + BigInt(Math.ceil(fee))) {
                const changeSats = inputRunning - (outputsValue + BigInt(Math.ceil(fee)));
                return { inputs, totalSats: inputRunning, changeSats };
            }
        }
        catch (e) {
            console.warn(`Failed to make UTXO spendable; txid: ${utxo.txid}\n`, e);
            continue;
        }
    }
    throw new Error('Not enough funds');
}
exports.utxoSelect = utxoSelect;
async function switchUtxoToSpendable(utxo, utxoToSpendable) {
    const hex = await utxo.tx;
    const tx = btc.Transaction.fromRaw((0, common_1.hexToBytes)(hex), {
        allowUnknownOutputs: true,
        allowUnknownInputs: true,
    });
    const outputToSpend = tx.getOutput(utxo.vout);
    if (!outputToSpend?.script)
        throw new Error('No script found on utxo tx');
    const spendScript = btc.OutScript.decode(outputToSpend.script);
    try {
        const fn = utxoToSpendable[spendScript.type];
        if (!fn)
            throw new Error(`Unsupported script type: ${spendScript.type}`);
        return await fn({
            tx,
            txHex: hex,
            utxo,
            output: outputToSpend,
            spendScript,
        });
    }
    catch (e) {
        throw new Error(`Failed to make utxo spendable. ${JSON.stringify(utxo)}`, { cause: e });
    }
}
exports.switchUtxoToSpendable = switchUtxoToSpendable;
const x = {};
if ('index' in x)
    x;
function wrapLazyProxy(target, key, resolution) {
    return new Proxy(target, {
        get(obj, prop) {
            if (prop === key && obj[prop] === undefined) {
                obj[prop] = Promise.resolve(resolution()).catch(error => {
                    delete obj[prop];
                    throw error;
                });
            }
            return obj[prop];
        },
        has(obj, prop) {
            if (prop === key)
                return true;
            return prop in obj;
        },
    });
}
exports.wrapLazyProxy = wrapLazyProxy;
//# sourceMappingURL=utils.js.map