import { HDKey } from '@scure/bip32';
import * as bip39 from '@scure/bip39';
import * as btc from '@scure/btc-signer';
import { TransactionVersion, getAddressFromPrivateKey, serializeCV, } from '@stacks/transactions';
import RpcClient from '@btc-helpers/rpc';
import { bytesToHex } from '@stacks/common';
import { compressPrivateKey } from '@stacks/encryption';
import { Cl } from '@stacks/transactions';
import { MAINNET, REGTEST, SBTC_FT_ADDRESS_TESTNET, TESTNET } from './constants';
import { wrapLazyProxy } from './utils';
export class SbtcApiHelper {
    constructor(config) {
        this.config = config;
    }
    async fetchUtxos(address) {
        return fetch(`${this.config.bitcoinElectrsApiUrl}/address/${address}/utxo`)
            .then(res => res.json())
            .then((utxos) => utxos.sort((a, b) => a.status.block_height - b.status.block_height))
            .then((utxos) => utxos.map(u => wrapLazyProxy(u, 'tx', () => this.fetchTxHex(u.txid))));
    }
    async fetchTxHex(txid) {
        return fetch(`${this.config.bitcoinElectrsApiUrl}/tx/${txid}/hex`).then(res => res.text());
    }
    async estimateFeeRates() {
        return fetch(`${this.config.bitcoinElectrsApiUrl}/fee-estimates`).then(res => res.json());
    }
    async estimateFeeRate(target) {
        const feeEstimates = await this.estimateFeeRates();
        const t = typeof target === 'number'
            ? target.toString()
            : target === 'high'
                ? '1'
                : target === 'medium'
                    ? '2'
                    : '3';
        if (t in feeEstimates) {
            return feeEstimates[t];
        }
        throw new Error(`Invalid fee target: ${target}`);
    }
    async broadcastTx(tx) {
        return await fetch(`${this.config.bitcoinElectrsApiUrl}/tx`, {
            method: 'POST',
            body: tx.hex,
        }).then(res => res.text());
    }
    async stacksCallReadOnly({ contractAddress, functionName, sender = 'ST000000000000000000002AMW42H', args = [], }) {
        contractAddress = contractAddress.replace('.', '/');
        return await fetch(`${this.config.stacksApiUrl}/v2/contracts/call-read/${contractAddress}/${encodeURIComponent(functionName)}`, {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ sender, arguments: args.map(serializeCV).map(bytesToHex) }),
        })
            .then(res => res.json())
            .then(res => Cl.deserialize(res.result));
    }
    async getBalance(address) {
        const addressInfo = await fetch(`${this.config.bitcoinElectrsApiUrl}/address/${address}`).then(r => r.json());
        return addressInfo.chain_stats.funded_txo_sum - addressInfo.chain_stats.spent_txo_sum;
    }
    async getSbtcBalance({ holderAddress, sbtcContract, }) {
        const [address, name] = holderAddress.split('.');
        const balance = (await this.stacksCallReadOnly({
            contractAddress: sbtcContract,
            functionName: 'get-balance',
            args: [name ? Cl.contractPrincipal(address, name) : Cl.standardPrincipal(address)],
        }));
        return balance?.value?.value ?? 0;
    }
    async getBitcoinAccount(mnemonic, idx = 0) {
        return await getBitcoinAccount(MAINNET, mnemonic, idx);
    }
    async getStacksAccount(mnemonic, idx = 0) {
        return await getStacksAccount(TransactionVersion.Mainnet, mnemonic, idx);
    }
}
export class TestnetHelper extends SbtcApiHelper {
    constructor(config) {
        super(Object.assign({
            bitcoinElectrsApiUrl: 'https://blockstream.info/testnet/api',
            stacksApiUrl: 'https://stacks-node-api.testnet.stacks.co',
        }, config));
    }
    async getSbtcPegAddress(contractAddress = SBTC_FT_ADDRESS_TESTNET) {
        const publicKey = (await this.stacksCallReadOnly({
            contractAddress,
            functionName: 'get-bitcoin-wallet-public-key',
        })).value.buffer;
        const tr = btc.p2tr(publicKey.length === 33 ? publicKey.subarray(1) : publicKey, undefined, TESTNET);
        return tr.address;
    }
    async getBitcoinAccount(mnemonic, idx = 0) {
        return await getBitcoinAccount(TESTNET, mnemonic, idx);
    }
    async getStacksAccount(mnemonic, idx = 0) {
        return await getStacksAccount(TransactionVersion.Testnet, mnemonic, idx);
    }
}
export class DevEnvHelper extends SbtcApiHelper {
    constructor(config) {
        super(Object.assign({
            bitcoinElectrsApiUrl: 'http://127.0.0.1:3002',
            stacksApiUrl: 'http://127.0.0.1:3999',
        }, config));
        const bitcoinCoreRpcUrl = config?.bitcoinCoreRpcUrl ?? 'http://devnet:devnet@127.0.0.1:18433';
        this.btcRpc = new RpcClient(bitcoinCoreRpcUrl).Typed;
    }
    async getSbtcPegAddress() {
        const pegAccount = await this.getBitcoinAccount(WALLET_00);
        return pegAccount.tr.address;
    }
    async getBitcoinAccount(mnemonic, idx = 0) {
        return await getBitcoinAccount(REGTEST, mnemonic, idx);
    }
    async getStacksAccount(mnemonic, idx = 0) {
        return await getStacksAccount(TransactionVersion.Testnet, mnemonic, idx);
    }
}
export const WALLET_00 = 'twice kind fence tip hidden tilt action fragile skin nothing glory cousin green tomorrow spring wrist shed math olympic multiply hip blue scout claw';
export const WALLET_01 = 'sell invite acquire kitten bamboo drastic jelly vivid peace spawn twice guilt pave pen trash pretty park cube fragile unaware remain midnight betray rebuild';
export const WALLET_02 = 'hold excess usual excess ring elephant install account glad dry fragile donkey gaze humble truck breeze nation gasp vacuum limb head keep delay hospital';
export async function getBitcoinAccount(network, mnemonic, idx = 0) {
    const seed = await bip39.mnemonicToSeed(mnemonic);
    const hdkey = HDKey.fromMasterSeed(seed, network.bip32);
    const path = `m/84'/${network.bip84.coin}'/${idx}'/0/0`;
    const privateKey = hdkey.derive(path).privateKey;
    const publicKey = hdkey.derive(path).publicKey;
    const trPath = `m/86'/${network.bip84.coin}'/${idx}'/0/0`;
    const trPrivateKey = hdkey.derive(trPath).privateKey;
    const trPublicKey = hdkey.derive(trPath).publicKey;
    return {
        privateKey,
        publicKey,
        wpkh: { address: btc.getAddress('wpkh', privateKey, network) },
        tr: {
            address: btc.getAddress('tr', trPrivateKey, network),
            publicKey: trPublicKey,
        },
    };
}
export async function getStacksAccount(transactionVersion, mnemonic, idx = 0) {
    const rootPrivateKey = await bip39.mnemonicToSeed(mnemonic);
    const rootNode = HDKey.fromMasterSeed(rootPrivateKey);
    const childKey = rootNode.derive(`m/44'/5757'/0'/0`).deriveChild(idx);
    const stxPrivateKey = bytesToHex(compressPrivateKey(childKey.privateKey));
    return {
        stxPrivateKey,
        privateKey: stxPrivateKey,
        address: getAddressFromPrivateKey(stxPrivateKey, transactionVersion),
    };
}
export function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
//# sourceMappingURL=api.js.map