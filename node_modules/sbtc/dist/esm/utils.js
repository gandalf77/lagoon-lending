import * as btc from '@scure/btc-signer';
import { hexToBytes, intToHex, utf8ToBytes } from '@stacks/common';
import { c32addressDecode } from 'c32check';
import * as P from 'micro-packed';
import { OVERHEAD_TX, VSIZE_INPUT_P2WPKH } from './constants';
const concat = P.concatBytes;
export function stacksAddressBytes(address) {
    const [addr, contractName] = address.split('.');
    const [version, hash] = c32addressDecode(addr);
    const versionBytes = hexToBytes(version.toString(16));
    const hashBytes = hexToBytes(hash);
    const contractNameBytes = lengthPrefixedString(contractName, utf8ToBytes);
    return concat(versionBytes, hashBytes, contractNameBytes);
}
export function lengthPrefixedString(something, map = utf8ToBytes, maxByteLength = 40, prefixByteLength = 1) {
    if (!something)
        return new Uint8Array(0);
    const bytes = map(something);
    if (maxByteLength >= 0 && bytes.byteLength > maxByteLength)
        throw new RangeError(`Content byteLength exceeds maximum length of ${maxByteLength}`);
    const prefixBytes = hexToBytes(intToHex(bytes.byteLength, prefixByteLength));
    if (prefixBytes.byteLength > prefixByteLength)
        throw new RangeError(`Prefix byteLength exceeds maximum length of ${prefixByteLength}`);
    return concat(prefixBytes, bytes);
}
export async function paymentInfo({ tx, feeRate, utxos, utxoToSpendable, }) {
    const outputs = [];
    for (let i = 0; i < tx.outputsLength; i++)
        outputs.push(tx.getOutput(i));
    return await utxoSelect({ feeRate, utxos, utxoToSpendable, outputs });
}
export function txBytes(inputs, outputs) {
    return (OVERHEAD_TX + inputs.map(inputBytes).reduce(plus, 0) + outputs.map(outputBytes).reduce(plus, 0));
}
export function inputBytes(input) {
    const tmpTx = new btc.Transaction({ allowUnknownInputs: true });
    const originalSize = tmpTx.vsize;
    tmpTx.addInput(input);
    return tmpTx.vsize - originalSize;
}
export function outputBytes(output) {
    const tmpTx = new btc.Transaction({ allowUnknownOutputs: true });
    const originalSize = tmpTx.vsize;
    tmpTx.addOutput(output);
    return tmpTx.vsize - originalSize;
}
export function dustMinimum(inputVsize, feeRate) {
    return Math.ceil(inputVsize * feeRate);
}
const plus = (a, b) => a + b;
export const DEFAULT_UTXO_TO_SPENDABLE = {
    wpkh: wpkhUtxoToSpendable,
};
export function wpkhUtxoToSpendable(opts) {
    if (!opts.output?.script)
        throw new Error('No script found on utxo tx');
    const spendableInput = {
        txid: hexToBytes(opts.utxo.txid),
        index: opts.utxo.vout,
        ...opts.output,
        witnessUtxo: {
            script: opts.output.script,
            amount: BigInt(opts.utxo.value),
        },
    };
    new btc.Transaction().addInput(spendableInput);
    return { input: spendableInput, vsize: VSIZE_INPUT_P2WPKH };
}
export function shUtxoToSpendable(net, paymentPublicKey, opts) {
    if (!opts.output?.script)
        throw new Error('No script found on utxo tx');
    let p2shRet;
    for (let i = 0; i < 10; i++) {
        try {
            if (i === 0) {
                p2shRet = btc.p2sh(btc.p2wpkh(hexToBytes(paymentPublicKey)), net);
            }
            else if (i === 1) {
                p2shRet = btc.p2sh(btc.p2wsh(btc.p2wpkh(hexToBytes(paymentPublicKey))), net);
            }
            else if (i === 2) {
                p2shRet = btc.p2sh(btc.p2wsh(btc.p2pkh(hexToBytes(paymentPublicKey)), net));
            }
            else if (i === 3) {
                p2shRet = btc.p2sh(btc.p2ms(1, [hexToBytes(paymentPublicKey)]), net);
            }
            else if (i === 4) {
                p2shRet = btc.p2sh(btc.p2pkh(hexToBytes(paymentPublicKey)), net);
            }
            else if (i === 5) {
                p2shRet = btc.p2sh(btc.p2sh(btc.p2pkh(hexToBytes(paymentPublicKey)), net));
            }
            else if (i === 6) {
                p2shRet = btc.p2sh(btc.p2sh(btc.p2wpkh(hexToBytes(paymentPublicKey)), net));
            }
            if (!p2shRet)
                throw new Error('No valid p2sh variant found.');
            if (i < 3) {
                const input = {
                    txid: hexToBytes(opts.utxo.txid),
                    index: opts.utxo.vout,
                    witnessUtxo: {
                        script: p2shRet.script,
                        amount: BigInt(opts.utxo.value),
                    },
                    redeemScript: p2shRet.redeemScript,
                };
                new btc.Transaction().addInput(input);
                return { input, vsize: VSIZE_INPUT_P2WPKH + (p2shRet.script?.byteLength ?? 0) };
            }
            const input = {
                txid: hexToBytes(opts.utxo.txid),
                index: opts.utxo.vout,
                nonWitnessUtxo: opts.txHex,
                redeemScript: p2shRet.redeemScript,
            };
            new btc.Transaction().addInput(input);
            return { input, vsize: p2shRet.script?.byteLength ?? 0 };
        }
        catch (e) { }
    }
    throw new Error('No valid p2sh variant found.');
}
export async function utxoSelect({ feeRate, utxos, utxoToSpendable, outputs, }) {
    const outputsValue = outputs.reduce((acc, o) => acc + (o.amount ?? 0n), 0n);
    const inputs = [];
    let inputRunning = 0n;
    let vsizeRunning = txBytes([], outputs);
    for (const utxo of utxos) {
        try {
            const { input, vsize } = await switchUtxoToSpendable(utxo, utxoToSpendable);
            const inputVsize = vsize ?? inputBytes(input);
            const utxoFee = feeRate * inputVsize;
            if (utxoFee > utxo.value)
                continue;
            inputs.push(input);
            inputRunning += BigInt(utxo.value);
            vsizeRunning += inputVsize;
            const fee = feeRate * vsizeRunning;
            if (inputRunning >= outputsValue + BigInt(Math.ceil(fee))) {
                const changeSats = inputRunning - (outputsValue + BigInt(Math.ceil(fee)));
                return { inputs, totalSats: inputRunning, changeSats };
            }
        }
        catch (e) {
            console.warn(`Failed to make UTXO spendable; txid: ${utxo.txid}\n`, e);
            continue;
        }
    }
    throw new Error('Not enough funds');
}
export async function switchUtxoToSpendable(utxo, utxoToSpendable) {
    const hex = await utxo.tx;
    const tx = btc.Transaction.fromRaw(hexToBytes(hex), {
        allowUnknownOutputs: true,
        allowUnknownInputs: true,
    });
    const outputToSpend = tx.getOutput(utxo.vout);
    if (!outputToSpend?.script)
        throw new Error('No script found on utxo tx');
    const spendScript = btc.OutScript.decode(outputToSpend.script);
    try {
        const fn = utxoToSpendable[spendScript.type];
        if (!fn)
            throw new Error(`Unsupported script type: ${spendScript.type}`);
        return await fn({
            tx,
            txHex: hex,
            utxo,
            output: outputToSpend,
            spendScript,
        });
    }
    catch (e) {
        throw new Error(`Failed to make utxo spendable. ${JSON.stringify(utxo)}`, { cause: e });
    }
}
const x = {};
if ('index' in x)
    x;
export function wrapLazyProxy(target, key, resolution) {
    return new Proxy(target, {
        get(obj, prop) {
            if (prop === key && obj[prop] === undefined) {
                obj[prop] = Promise.resolve(resolution()).catch(error => {
                    delete obj[prop];
                    throw error;
                });
            }
            return obj[prop];
        },
        has(obj, prop) {
            if (prop === key)
                return true;
            return prop in obj;
        },
    });
}
//# sourceMappingURL=utils.js.map