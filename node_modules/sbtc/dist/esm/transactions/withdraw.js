import * as btc from '@scure/btc-signer';
import { asciiToBytes, bytesToHex, hexToBytes } from '@stacks/common';
import * as P from 'micro-packed';
import { OpCode, REGTEST, SBTC_PEG_ADDRESS_DEVENV, VSIZE_INPUT_P2WPKH, } from '../constants';
import { DEFAULT_UTXO_TO_SPENDABLE, dustMinimum, paymentInfo, shUtxoToSpendable, } from '../utils';
const concat = P.concatBytes;
export async function sbtcWithdrawHelper({ network = REGTEST, amountSats, signature, fulfillmentFeeSats, bitcoinAddress, bitcoinChangeAddress, pegAddress = SBTC_PEG_ADDRESS_DEVENV, feeRate, utxos, utxoToSpendable = DEFAULT_UTXO_TO_SPENDABLE, paymentPublicKey, }) {
    if (paymentPublicKey) {
        utxoToSpendable.sh = shUtxoToSpendable.bind(null, network, paymentPublicKey);
    }
    const tx = buildSbtcWithdrawTxOpReturn({
        network,
        amountSats,
        signature,
        bitcoinAddress,
    });
    tx.addOutputAddress(pegAddress, BigInt(fulfillmentFeeSats), network);
    const pay = await paymentInfo({ tx, feeRate, utxos, utxoToSpendable });
    for (const input of pay.inputs)
        tx.addInput(input);
    const changeAfterAdditionalOutput = pay.changeSats - BigInt(Math.ceil(VSIZE_INPUT_P2WPKH * feeRate));
    if (changeAfterAdditionalOutput > dustMinimum(VSIZE_INPUT_P2WPKH, feeRate)) {
        tx.addOutputAddress(bitcoinChangeAddress, changeAfterAdditionalOutput, network);
    }
    return tx;
}
export const buildSbtcWithdrawTx = buildSbtcWithdrawTxOpReturn;
export function buildSbtcWithdrawTxOpReturn({ network = REGTEST, amountSats, signature, bitcoinAddress, }) {
    const data = buildSBtcWithdrawBtcPayload({ network, amountSats, signature });
    const tx = new btc.Transaction({
        allowUnknownInputs: true,
        allowUnknownOutputs: true,
    });
    tx.addOutput({ script: btc.Script.encode(['RETURN', data]), amount: BigInt(0) });
    tx.addOutputAddress(bitcoinAddress, BigInt(amountSats), network);
    return tx;
}
export function buildSBtcWithdrawBtcPayload({ network = REGTEST, amountSats, signature, }) {
    const magicBytes = asciiToBytes(network.magicBytes);
    const opCodeBytes = hexToBytes(OpCode.PegOut);
    const amountBytes = P.U64BE.encode(BigInt(amountSats));
    const signatureBytes = hexToBytes(signature.slice(signature.length - 2) + signature.slice(0, -2));
    return concat(magicBytes, opCodeBytes, amountBytes, signatureBytes);
}
export function sbtcWithdrawMessage({ network = REGTEST, amountSats, bitcoinAddress, }) {
    const amountBytes = P.U64BE.encode(BigInt(amountSats));
    const scriptOut = btc.OutScript.encode(btc.Address(network).decode(bitcoinAddress));
    const data = concat(amountBytes, scriptOut);
    return `Withdraw request for ${amountSats} satoshis to the bitcoin address ${bitcoinAddress} (${bytesToHex(data)})`;
}
//# sourceMappingURL=withdraw.js.map