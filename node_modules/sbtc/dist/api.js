"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sleep = exports.getStacksAccount = exports.getBitcoinAccount = exports.WALLET_02 = exports.WALLET_01 = exports.WALLET_00 = exports.DevEnvHelper = exports.TestnetHelper = exports.SbtcApiHelper = void 0;
const bip32_1 = require("@scure/bip32");
const bip39 = __importStar(require("@scure/bip39"));
const btc = __importStar(require("@scure/btc-signer"));
const transactions_1 = require("@stacks/transactions");
const rpc_1 = __importDefault(require("@btc-helpers/rpc"));
const common_1 = require("@stacks/common");
const encryption_1 = require("@stacks/encryption");
const transactions_2 = require("@stacks/transactions");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
class SbtcApiHelper {
    constructor(config) {
        this.config = config;
    }
    async fetchUtxos(address) {
        return fetch(`${this.config.bitcoinElectrsApiUrl}/address/${address}/utxo`)
            .then(res => res.json())
            .then((utxos) => utxos.sort((a, b) => a.status.block_height - b.status.block_height))
            .then((utxos) => utxos.map(u => (0, utils_1.wrapLazyProxy)(u, 'tx', () => this.fetchTxHex(u.txid))));
    }
    async fetchTxHex(txid) {
        return fetch(`${this.config.bitcoinElectrsApiUrl}/tx/${txid}/hex`).then(res => res.text());
    }
    async estimateFeeRates() {
        return fetch(`${this.config.bitcoinElectrsApiUrl}/fee-estimates`).then(res => res.json());
    }
    async estimateFeeRate(target) {
        const feeEstimates = await this.estimateFeeRates();
        const t = typeof target === 'number'
            ? target.toString()
            : target === 'high'
                ? '1'
                : target === 'medium'
                    ? '2'
                    : '3';
        if (t in feeEstimates) {
            return feeEstimates[t];
        }
        throw new Error(`Invalid fee target: ${target}`);
    }
    async broadcastTx(tx) {
        return await fetch(`${this.config.bitcoinElectrsApiUrl}/tx`, {
            method: 'POST',
            body: tx.hex,
        }).then(res => res.text());
    }
    async stacksCallReadOnly({ contractAddress, functionName, sender = 'ST000000000000000000002AMW42H', args = [], }) {
        contractAddress = contractAddress.replace('.', '/');
        return await fetch(`${this.config.stacksApiUrl}/v2/contracts/call-read/${contractAddress}/${encodeURIComponent(functionName)}`, {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ sender, arguments: args.map(transactions_1.serializeCV).map(common_1.bytesToHex) }),
        })
            .then(res => res.json())
            .then(res => transactions_2.Cl.deserialize(res.result));
    }
    async getBalance(address) {
        const addressInfo = await fetch(`${this.config.bitcoinElectrsApiUrl}/address/${address}`).then(r => r.json());
        return addressInfo.chain_stats.funded_txo_sum - addressInfo.chain_stats.spent_txo_sum;
    }
    async getSbtcBalance({ holderAddress, sbtcContract, }) {
        const [address, name] = holderAddress.split('.');
        const balance = (await this.stacksCallReadOnly({
            contractAddress: sbtcContract,
            functionName: 'get-balance',
            args: [name ? transactions_2.Cl.contractPrincipal(address, name) : transactions_2.Cl.standardPrincipal(address)],
        }));
        return balance?.value?.value ?? 0;
    }
    async getBitcoinAccount(mnemonic, idx = 0) {
        return await getBitcoinAccount(constants_1.MAINNET, mnemonic, idx);
    }
    async getStacksAccount(mnemonic, idx = 0) {
        return await getStacksAccount(transactions_1.TransactionVersion.Mainnet, mnemonic, idx);
    }
}
exports.SbtcApiHelper = SbtcApiHelper;
class TestnetHelper extends SbtcApiHelper {
    constructor(config) {
        super(Object.assign({
            bitcoinElectrsApiUrl: 'https://blockstream.info/testnet/api',
            stacksApiUrl: 'https://stacks-node-api.testnet.stacks.co',
        }, config));
    }
    async getSbtcPegAddress(contractAddress = constants_1.SBTC_FT_ADDRESS_TESTNET) {
        const publicKey = (await this.stacksCallReadOnly({
            contractAddress,
            functionName: 'get-bitcoin-wallet-public-key',
        })).value.buffer;
        const tr = btc.p2tr(publicKey.length === 33 ? publicKey.subarray(1) : publicKey, undefined, constants_1.TESTNET);
        return tr.address;
    }
    async getBitcoinAccount(mnemonic, idx = 0) {
        return await getBitcoinAccount(constants_1.TESTNET, mnemonic, idx);
    }
    async getStacksAccount(mnemonic, idx = 0) {
        return await getStacksAccount(transactions_1.TransactionVersion.Testnet, mnemonic, idx);
    }
}
exports.TestnetHelper = TestnetHelper;
class DevEnvHelper extends SbtcApiHelper {
    constructor(config) {
        super(Object.assign({
            bitcoinElectrsApiUrl: 'http://127.0.0.1:3002',
            stacksApiUrl: 'http://127.0.0.1:3999',
        }, config));
        const bitcoinCoreRpcUrl = config?.bitcoinCoreRpcUrl ?? 'http://devnet:devnet@127.0.0.1:18433';
        this.btcRpc = new rpc_1.default(bitcoinCoreRpcUrl).Typed;
    }
    async getSbtcPegAddress() {
        const pegAccount = await this.getBitcoinAccount(exports.WALLET_00);
        return pegAccount.tr.address;
    }
    async getBitcoinAccount(mnemonic, idx = 0) {
        return await getBitcoinAccount(constants_1.REGTEST, mnemonic, idx);
    }
    async getStacksAccount(mnemonic, idx = 0) {
        return await getStacksAccount(transactions_1.TransactionVersion.Testnet, mnemonic, idx);
    }
}
exports.DevEnvHelper = DevEnvHelper;
exports.WALLET_00 = 'twice kind fence tip hidden tilt action fragile skin nothing glory cousin green tomorrow spring wrist shed math olympic multiply hip blue scout claw';
exports.WALLET_01 = 'sell invite acquire kitten bamboo drastic jelly vivid peace spawn twice guilt pave pen trash pretty park cube fragile unaware remain midnight betray rebuild';
exports.WALLET_02 = 'hold excess usual excess ring elephant install account glad dry fragile donkey gaze humble truck breeze nation gasp vacuum limb head keep delay hospital';
async function getBitcoinAccount(network, mnemonic, idx = 0) {
    const seed = await bip39.mnemonicToSeed(mnemonic);
    const hdkey = bip32_1.HDKey.fromMasterSeed(seed, network.bip32);
    const path = `m/84'/${network.bip84.coin}'/${idx}'/0/0`;
    const privateKey = hdkey.derive(path).privateKey;
    const publicKey = hdkey.derive(path).publicKey;
    const trPath = `m/86'/${network.bip84.coin}'/${idx}'/0/0`;
    const trPrivateKey = hdkey.derive(trPath).privateKey;
    const trPublicKey = hdkey.derive(trPath).publicKey;
    return {
        privateKey,
        publicKey,
        wpkh: { address: btc.getAddress('wpkh', privateKey, network) },
        tr: {
            address: btc.getAddress('tr', trPrivateKey, network),
            publicKey: trPublicKey,
        },
    };
}
exports.getBitcoinAccount = getBitcoinAccount;
async function getStacksAccount(transactionVersion, mnemonic, idx = 0) {
    const rootPrivateKey = await bip39.mnemonicToSeed(mnemonic);
    const rootNode = bip32_1.HDKey.fromMasterSeed(rootPrivateKey);
    const childKey = rootNode.derive(`m/44'/5757'/0'/0`).deriveChild(idx);
    const stxPrivateKey = (0, common_1.bytesToHex)((0, encryption_1.compressPrivateKey)(childKey.privateKey));
    return {
        stxPrivateKey,
        privateKey: stxPrivateKey,
        address: (0, transactions_1.getAddressFromPrivateKey)(stxPrivateKey, transactionVersion),
    };
}
exports.getStacksAccount = getStacksAccount;
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
exports.sleep = sleep;
//# sourceMappingURL=api.js.map